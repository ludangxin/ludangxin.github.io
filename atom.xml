<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://blog.ludangxin.club</id>
    <title>断剑重铸之日，骑士归来之时。</title>
    <updated>2020-08-23T08:19:16.313Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://blog.ludangxin.club"/>
    <link rel="self" href="http://blog.ludangxin.club/atom.xml"/>
    <subtitle>念念不忘 , 必有回响~</subtitle>
    <logo>http://blog.ludangxin.club/images/avatar.png</logo>
    <icon>http://blog.ludangxin.club/favicon.ico</icon>
    <rights>All rights reserved 2020, 断剑重铸之日，骑士归来之时。</rights>
    <entry>
        <title type="html"><![CDATA[SpringBoot]]></title>
        <id>http://blog.ludangxin.club/post/springboot/</id>
        <link href="http://blog.ludangxin.club/post/springboot/">
        </link>
        <updated>2020-08-23T08:11:49.000Z</updated>
        <content type="html"><![CDATA[<h1 id="spring-boot-简介">spring boot 简介</h1>
<h2 id="概述">概述</h2>
<p>Spring Boot 可以称之为 <strong>新一代 JavaEE 开发标准</strong>；随着动态语言的流行 (Ruby、Groovy、Scala、Node.js)，Java 的开发显得格外的笨重：繁多的配置、低下的开发效率、复杂的部署流程以及第三方技术集成难度大。</p>
<p>在上述环境下，Spring Boot 应运而生。它使用 “<strong>习惯优于配置</strong>” （项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速的运行起来,即<strong>开箱即用</strong>。使用 Spring Boot 很容易创建一个独立运行（运行 Jar，内嵌 Servlet 容器）准生产级别的基于 Spring 框架的项目，使用 Spring Boot 你可以不用或者只需很少的 Spring 配置。</p>
<h2 id="spring-简史">Spring 简史</h2>
<h3 id="spring-1x-时代">Spring 1.x 时代</h3>
<p>在 Spring1.x 时代，都是通过 xml 文件配置 bean，随着项目的不断扩大，需要将 xml 配置分放到不同的配置文件中，需要频繁的在 java 类和 xml 配置文件中切换。</p>
<h3 id="spring-2x-时代">Spring 2.x 时代</h3>
<p>随着 JDK 1.5 带来的注解支持，Spring2.x 可以使用注解对 Bean 进行申明和注入，大大的减少了 xml 配置文件，同时也大大简化了项目的开发。</p>
<p>那么，问题来了，究竟是应该使用 xml 还是注解呢？</p>
<p>最佳实践：</p>
<ul>
<li>应用的基本配置用 xml，比如：数据源、资源文件等</li>
<li>业务开发用注解，比如：Service 中注入 bean 等</li>
</ul>
<h3 id="spring-3x-时代">Spring 3.x 时代</h3>
<p>从 Spring3.x 开始提供了 Java 配置方式，使用 Java 配置方式可以更好的理解你配置的 Bean，现在我们就处于这个时代，并且 Spring4.x 和 Spring boot 都推荐使用 java 配置的方式。</p>
<h3 id="spring-5x-时代">Spring 5.x 时代</h3>
<p>Spring5.x 是 Java 界首个支持响应式的 Web 框架，是 Spring 的一个重要版本，距离 Spring4.x 差不多四年。在此期间，大多数增强都是在 Spring Boot 项目中完成的，其最大的亮点就是提供了完整的端到端响应式编程的支持（新增 Spring WebFlux 模块）。</p>
<p>Spring WebFlux 同时支持使用旧的 Spring MVC 注解声明 <code>Reactive Controller</code>。和传统的 <code>MVC Controller</code> 不同，<code>Reactive Controller</code> 操作的是 <strong>非阻塞</strong> 的 <code>ServerHttpRequest</code> 和 <code>ServerHttpResponse</code>，而不再是 Spring MVC 里的 HttpServletRequest 和 HttpServletResponse。</p>
<p>至此也代表着 Java 正式迎来了响应式异步编程的时代。</p>
<h2 id="spring-boot-优缺点">Spring Boot 优缺点</h2>
<h3 id="优点">优点</h3>
<ul>
<li>快速构建项目</li>
<li>对主流开发框架的无配置集成</li>
<li>项目可独立运行，无需外部依赖 Servlet 容器</li>
<li>提供运行时的应用监控</li>
<li>极大地提高了开发、部署效率</li>
<li>与云计算的天然集成</li>
</ul>
<h3 id="缺点">缺点</h3>
<ul>
<li>版本迭代速度很快，一些模块改动很大</li>
<li>由于不用自己做配置，报错时很难定位</li>
</ul>
<h1 id="spring-boot-常用配置">spring boot 常用配置</h1>
<h2 id="概述-2">概述</h2>
<p>本章节主要介绍一下 Spring Boot 中的一些常用配置，比如：自定义 Banner、配置日志、关闭特定的自动配置等。</p>
<h2 id="自定义-banner">自定义 Banner</h2>
<p>在 Spring Boot 启动的时候会有一个默认的启动图案</p>
<pre><code> .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.1.6.RELEASE)
</code></pre>
<p>我们在 <code>src/main/resources</code> 目录下新建一个 banner.txt</p>
<p>通过 <a href="http://www.qfdmy.com/wp-content/themes/quanbaike/go.php?url=aHR0cDovL3BhdG9yamsuY29tL3NvZnR3YXJlL3RhYWc=">http://patorjk.com/software/taag</a> 网站生成字符串，将网站生成的字符复制到 banner.txt 中</p>
<p>再次运行这个程序</p>
<pre><code class="language-bash">${AnsiColor.BRIGHT_RED}
////////////////////////////////////////////////////////////////////
//                          _ooOoo_                               //
//                         o8888888o                              //
//                         88&quot; . &quot;88                              //
//                         (| ^_^ |)                              //
//                         O\  =  /O                              //
//                      ____/`---'\____                           //
//                    .'  \\|     |//  `.                         //
//                   /  \\|||  :  |||//  \                        //
//                  /  _||||| -:- |||||-  \                       //
//                  |   | \\\  -  /// |   |                       //
//                  | \_|  ''\---/''  |   |                       //
//                  \  .-\__  `-`  ___/-. /                       //
//                ___`. .'  /--.--\  `. . ___                     //
//              .&quot;&quot; '&lt;  `.___\_&lt;|&gt;_/___.'  &gt;'&quot;&quot;.                  //
//            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //
//            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //
//      ========`-.____`-.___\_____/___.-`____.-'========         //
//                           `=---='                              //
//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //
//            佛祖保佑       永不宕机     永无BUG                  //
////////////////////////////////////////////////////////////////////
</code></pre>
<p>常用属性设置：</p>
<ul>
<li><code>${AnsiColor.BRIGHT_RED}</code>：设置控制台中输出内容的颜色</li>
<li><code>${application.version}</code>：用来获取 <code>MANIFEST.MF</code> 文件中的版本号</li>
<li><code>${application.formatted-version}</code>：格式化后的 <code>${application.version}</code> 版本信息</li>
<li><code>${spring-boot.version}</code>：Spring Boot 的版本号</li>
<li><code>${spring-boot.formatted-version}</code>：格式化后的 <code>${spring-boot.version}</code> 版本信息</li>
</ul>
<h2 id="配置文件">配置文件</h2>
<p>Spring Boot 项目使用一个全局的配置文件 <code>application.properties</code> 或者是 <code>application.yml</code>，在 <code>resources</code> 目录下或者类路径下的 <code>/config</code> 下，一般我们放到 <code>resources</code> 下。</p>
<p>修改 Tomcat 的端口为 9090，并将默认的访问路径 &quot;/&quot; 修改为 &quot;boot&quot;，可以在 <code>application.properties</code> 中添加：</p>
<pre><code class="language-properties">server.port=9090
server.context-path=/boot
</code></pre>
<p>或在 application.yml 中添加：</p>
<pre><code class="language-yaml">server:
  port: 9090
  context-path: /boot
</code></pre>
<p><a href="http://www.qfdmy.com/wp-content/themes/quanbaike/go.php?url=aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctYm9vdC9kb2NzLzIuMC4yLlJFTEVBU0UvcmVmZXJlbmNlL2h0bWwvY29tbW9uLWFwcGxpY2F0aW9uLXByb3BlcnRpZXMuaHRtbA==">更多配置</a></p>
<h2 id="starter-pom">Starter POM</h2>
<p>Spring Boot 为我们提供了简化企业级开发绝大多数场景的 starter pom ，只要使用了应用场景所需要的 starter pom ，相关的技术配置将会消除，就可以得到 Spring Boot 为我们提供的自动配置的 Bean。</p>
<p><a href="http://www.qfdmy.com/wp-content/themes/quanbaike/go.php?url=aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctYm9vdC9kb2NzLzIuMC4yLlJFTEVBU0UvcmVmZXJlbmNlL2h0bWwvdXNpbmctYm9vdC1idWlsZC1zeXN0ZW1zLmh0bWwjdXNpbmctYm9vdC1zdGFydGVy">更多 Starter POM</a></p>
<h2 id="日志配置">日志配置</h2>
<p>Spring Boot 对各种日志框架都做了支持，我们可以通过配置来修改默认的日志的配置</p>
<p>默认情况下，Spring Boot 使用 Logback 作为日志框架</p>
<pre><code class="language-yaml">logging:
  file: ../logs/spring-boot-hello.log
  level.org.springframework.web: DEBUG
</code></pre>
<h2 id="关闭特定的自动配置">关闭特定的自动配置</h2>
<p>关闭特定的自动配置使用 <code>@SpringBootApplication</code> 注解的 <code>exclude</code> 参数即可，这里以关闭数据源的自动配置为例</p>
<pre><code class="language-java">@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})
</code></pre>
<p>https://www.zhihu.com/question/28594409/answer/74003996)</p>
<h2 id="读取配置文件">读取配置文件</h2>
<ol>
<li>@Value</li>
<li>Environment</li>
<li>@ConfigurationProperties</li>
</ol>
<h2 id="多环境配置">多环境配置</h2>
<p>我们在开发Spring Boot应用时，通常同一套程序会被安装到不同环境，比如：开发、测试、生产等。其中数据库地址、服务器端口等等配置都不同，如果每次打包时，都要修改配置文件，那么非常麻烦。profile功能就是来进行动态配置切换的。</p>
<ol>
<li>profile配置方式</li>
</ol>
<ul>
<li>多profile文件方式</li>
<li>yml多文档方式</li>
</ul>
<pre><code class="language-tex">多profile文件方式：提供多个配置文件，每个代表一种环境:
    application-dev.properties/yml 开发环境
    application-test.properties/yml 测试环境
    application-pro.properties/yml 生产环境
yml多文档方式：
    在yml中使用  --- 分隔不同配置
</code></pre>
<ol start="2">
<li>profile激活方式</li>
</ol>
<ul>
<li>配置文件</li>
<li>虚拟机参数</li>
<li>命令行参数</li>
</ul>
<pre><code class="language-tex">配置文件： 再配置文件中配置：spring.profiles.active=dev
虚拟机参数：在VM options 指定：-Dspring.profiles.active=dev
命令行参数：java –jar xxx.jar  --spring.profiles.active=dev
</code></pre>
<h2 id="spring-boot-内部配置加载顺序">spring boot 内部配置加载顺序</h2>
<p>Springboot程序启动时，会从以下位置加载配置文件：</p>
<ol>
<li>file:./config/：当前项目下的/config目录下</li>
<li>file:./           ：当前项目的根目录</li>
<li>classpath:/config/：classpath的/config目录</li>
<li>classpath:/  ：classpath的根目录</li>
</ol>
<h1 id="spring-boot-高级">spring boot 高级</h1>
<h2 id="spring-boot-自动配置">spring boot 自动配置</h2>
<h3 id="1问题">1问题</h3>
<p>SpringBoot是如何知道要创建哪个Bean的？比如SpringBoot是如何知道要创建RedisTemplate的？</p>
<h4 id="11-获取redistemplate">1.1 获取RedisTemplate</h4>
<h5 id="111-创建一个干净的springboot项目并修改启动类">1.1.1 创建一个干净的springboot项目并修改启动类</h5>
<pre><code class="language-java">@SpringBootApplication
public class SpringbootStudyApplication {

    public static void main(String[] args) {
        //启动SpringBoot的应用，返回Spring的IOC容器
        ConfigurableApplicationContext context = SpringApplication.run(SpringbootStudyApplication.class, args);
        //获取Bean，redisTemplate
        Object redisTemplate = context.getBean(&quot;redisTemplate&quot;);
        System.out.println(redisTemplate);
    }

}
</code></pre>
<h5 id="112-启动项目">1.1.2 启动项目</h5>
<ul>
<li>报错找不到redisTemplate bean</li>
</ul>
<pre><code class="language-shell">Exception in thread &quot;main&quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'redisTemplate' available
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBeanDefinition(DefaultListableBeanFactory.java:816)
	...
</code></pre>
<h5 id="113-添加依赖">1.1.3  添加依赖</h5>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="114-再启动项目">1.1.4 再启动项目</h5>
<ul>
<li>启动不报错 输出redisTemplate 对象信息</li>
</ul>
<pre><code class="language-shell">org.springframework.data.redis.core.RedisTemplate@287f94b1
</code></pre>
<h4 id="12-思考">1.2 思考</h4>
<p>为什么添加了redis的依赖后,就能获取到redisTemplate bean了?</p>
<h3 id="2-做一个condition小练习">2 做一个Condition小练习</h3>
<h4 id="21-需求">2.1 需求</h4>
<p>在 Spring 的 IOC 容器中有一个 User 的 Bean，现要求：</p>
<ol>
<li>导入Jedis坐标后，加载该Bean，没导入，则不加载。</li>
<li>将类的判断定义为动态的。判断哪个字节码文件存在可以动态指定。</li>
</ol>
<h4 id="22-conditional">2.2 @Conditional</h4>
<h5 id="231-查看conditional源码">2.3.1 查看<code>@Conditional</code>源码</h5>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Conditional {
    Class&lt;? extends Condition&gt;[] value();
}
</code></pre>
<ul>
<li>Conditional 注解参数为 Condition 的子类的Class对象</li>
</ul>
<h5 id="232-继续查看condition">2.3.2  继续查看Condition</h5>
<pre><code class="language-java">@FunctionalInterface
public interface Condition {
    boolean matches(ConditionContext var1, AnnotatedTypeMetadata var2);
}
</code></pre>
<ul>
<li>Condition 为接口,其中方法matches</li>
<li>matches 作用: 当实现类的 matches 方法返回true时,则注册标识的类或方法,false反之</li>
</ul>
<h4 id="22-创建pojo">2.2 创建pojo</h4>
<pre><code class="language-java">public class User {
}
</code></pre>
<h4 id="23-创建配置类">2.3 创建配置类</h4>
<pre><code class="language-java">@Configuration
public class UserConfig {
    @Bean
    @Conditional(ClassCondition.class)
    public User user(){
        return new User();
    }
}
</code></pre>
<h4 id="24-条件实现类">2.4 条件实现类</h4>
<pre><code class="language-java">public class ClassCondition implements Condition {
   /**
    * @param context  上下文对象。用于获取环境，IOC容器，ClassLoader对象
    * @param metadata 注解元对象。 可以用于获取注解定义的属性值
    * @return
   */
   @Override
   public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata){
        return true;
    }
}
</code></pre>
<ul>
<li>直接返回true,测试能不能直接获取到user bean</li>
</ul>
<h4 id="25-修改启动类">2.5 修改启动类</h4>
<pre><code class="language-java">@SpringBootApplication
public class SpringbootStudyApplication {

    public static void main(String[] args) {
        //启动SpringBoot的应用，返回Spring的IOC容器
        ConfigurableApplicationContext context = SpringApplication.run(SpringbootStudyApplication.class, args);
        //获取Bean，redisTemplate
//        Object redisTemplate = context.getBean(&quot;redisTemplate&quot;);

        Object user = context.getBean(&quot;user&quot;);
        System.out.println(user);
    }

}
</code></pre>
<ul>
<li>启动运行之后,可以直接获取到user bean.</li>
<li>验证猜想后,继续完善需求</li>
</ul>
<h4 id="26-引入jedis依赖">2.6 引入jedis依赖</h4>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;redis.clients&lt;/groupId&gt;
   &lt;artifactId&gt;jedis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h4 id="27-完善条件类逻辑">2.7 完善条件类逻辑</h4>
<pre><code class="language-java">public class ClassCondition implements Condition {
   /**
    *
    * @param context 上下文对象。用于获取环境，IOC容器，ClassLoader对象
    * @param metadata 注解元对象。 可以用于获取注解定义的属性值
    * @return
   */
   @Override
   public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata){
        //1.需求： 导入Jedis坐标后创建Bean
        //思路：判断redis.clients.jedis.Jedis.class文件是否存在
        boolean flag = true;
        try {
            Class&lt;?&gt; cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);
        } catch (ClassNotFoundException e) {
            flag = false;
        }
        return flag;
    }
}
</code></pre>
<h4 id="28-再次启动项目">2.8 再次启动项目</h4>
<pre><code class="language-shell">com.ludangxin.springbootstudy.domain.User@7dac3fd8
</code></pre>
<ul>
<li>正常获取user bean</li>
<li>到这里需求一完成</li>
</ul>
<h4 id="29-动态的判断依赖坐标创建注解">2.9 动态的判断依赖坐标创建注解</h4>
<pre><code class="language-java">@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(ClassCondition.class)
public @interface ConditionOnClass {
    String[] value();
}
</code></pre>
<h4 id="210-修改user-bean">2.10 修改user bean</h4>
<pre><code class="language-java">    @Bean
//    @Conditional(ClassCondition.class)
    @ConditionOnClass(&quot;redis.clients.jedis.Jedis&quot;)
    public User user(){
        return new User();
    }
</code></pre>
<h4 id="修改条件实现">修改条件实现</h4>
<pre><code class="language-java">public class ClassCondition implements Condition {
    /**
     *
     * @param context 上下文对象。用于获取环境，IOC容器，ClassLoader对象
     * @param metadata 注解元对象。 可以用于获取注解定义的属性值
     * @return
     */
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        /*
        //1.需求： 导入Jedis坐标后创建Bean
        //思路：判断redis.clients.jedis.Jedis.class文件是否存在
        boolean flag = true;
        try {
            Class&lt;?&gt; cls = Class.forName(&quot;redis.clients.jedis.Jedis&quot;);
        } catch (ClassNotFoundException e) {
            flag = false;
        }
        return flag;
        */

        //2.需求： 导入通过注解属性值value指定坐标后创建Bean

        //获取注解属性值  value
        Map&lt;String, Object&gt; map = metadata.getAnnotationAttributes(ConditionOnClass.class.getName());
        //System.out.println(map);
        String[] value = (String[]) map.get(&quot;value&quot;);

        boolean flag = true;
        try {
            for (String className : value) {
                Class&lt;?&gt; cls = Class.forName(className);
            }
        } catch (ClassNotFoundException e) {
            flag = false;
        }
        return flag;

    }
}
</code></pre>
<h4 id="启动项目">启动项目</h4>
<pre><code class="language-shell">com.ludangxin.springbootstudy.domain.User@62573c86
</code></pre>
<ul>
<li>正常获取user bean</li>
<li>到这里需求完成</li>
<li>练习做完后大概明白了condition注解的作用</li>
</ul>
<h3 id="3-condition">3  Condition</h3>
<p>Condition 是在Spring 4.0 增加的条件判断功能，通过这个可以功能可以实现选择性的创建 Bean 操作.</p>
<h4 id="springboot-提供的常用条件注解">SpringBoot 提供的常用条件注解：</h4>
<p>Spring提供的一些成品的(不需要自行扩展的)条件注解<br>
<code>@ConditionOnClass</code> 判断环境中是否有对应字节码文件才初始化Bean<br>
<code>@ConditionOnBean</code> 判断环境中是否有对应bean才初始化Bean<br>
<code>@ConditionOnWebApplication</code> 当前项目是Web项目的条件<br>
<code>@ConditionOnExpression</code> 基于SpEL表达式作为判断条件<br>
<code>@ConditionOnJndi</code> 在JNDI存在时查找指定的位置<br>
<code>@ConditionMissingBean</code> 当SpringIoc容器内不存在指定的Bean的条件<br>
<code>@ConditionMissingClass</code> 当SpringIoc容器内不存在指定的Class的条件<br>
<code>@ConditionOnNotWebApplication</code> 当前项目不是Web项目的条件<br>
<code>@ConditionOnProperty</code> 指定的属性是否有指定的值<br>
<code>@ConditionOnResource</code> 类路径是否有指定的值<br>
<code>@ConditionOnSingleCandidate</code> 当指定Bean在IOC容器内只有一个，或者虽然有多个但时指定首选的Bean</p>
<h3 id="4-做一个enable小练习">4 做一个Enable小练习</h3>
<p>SpringBoot中提供了很多Enable开头的注解，这些注解都是用于动态启用某些功能的。而其底层原理是使用@Import注解导入一些配置类，实现Bean的动态加载。</p>
<h4 id="41-思考">4.1 思考</h4>
<p>SpringBoot 工程是否可以直接获取jar包中定义的Bean？</p>
<h4 id="42-验证">4.2 验证</h4>
<h5 id="421-新建一个model">4.2.1 新建一个model</h5>
<p>创建模块</p>
<pre><code class="language-xml">&lt;groupId&gt;com.ludangxin&lt;/groupId&gt;
&lt;artifactId&gt;springboot-study-other&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
</code></pre>
<h5 id="422-新建pojo">4.2.2 新建pojo</h5>
<pre><code class="language-java">public class User {
}
</code></pre>
<h5 id="423-新建config类">4.2.3 新建config类</h5>
<pre><code class="language-java">@Configuration
public class UserConfig {
    @Bean
    public User user() {
        return new User();
    }
}
</code></pre>
<h5 id="424-springbootstudy-模块引用刚创建的other模块">4.2.4 springbootstudy 模块引用刚创建的other模块</h5>
<pre><code class="language-xml">&lt;dependency&gt;
   &lt;groupId&gt;com.ludangxin&lt;/groupId&gt;
   &lt;artifactId&gt;springboot-study-other&lt;/artifactId&gt;
   &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<h5 id="425-注释掉study模块中的config配置类">4.2.5 注释掉study模块中的config配置类</h5>
<pre><code class="language-java">//@Configuration
public class UserConfig {
    @Bean
//    @Conditional(ClassCondition.class)
    @ConditionOnClass(&quot;redis.clients.jedis.Jedis&quot;)
    public User user() {
        return new User();
    }
}
</code></pre>
<h5 id="426-验证-是否能获取到other模块中的user-bean">4.2.6 验证 是否能获取到other模块中的user bean</h5>
<pre><code class="language-shell">Exception in thread &quot;main&quot; org.springframework.beans.factory.NoSuchBeanDefinitionException: No bean named 'user' available
</code></pre>
<ul>
<li>启动项目后发现无法获取到user bean</li>
</ul>
<h5 id="427-为什么获取不到呢">4.2.7 为什么获取不到呢?</h5>
<ul>
<li>因为spring boot 默认只扫描当前项目的启动引导类的同级或者同级以下的类,也就是只会注册当前启动类所在包下的springbean</li>
<li>因为新模块的报名和study模块的报名不同导致扫描不到bean ,所以无法自动注入无法直接使用引用包中的bean</li>
</ul>
<h5 id="428-那是不是只要让扫描上配置类就可以了呢">4.2.8 那是不是只要让扫描上配置类就可以了呢?</h5>
<h6 id="4281-componentscan">4.2.8.1 @ComponentScan</h6>
<p>ComponentScan  扫描指定包</p>
<pre><code class="language-java">@SpringBootApplication
@ComponentScan({&quot;com.ludangxin.springbootstudyother.config&quot;})
public class SpringbootStudyApplication {
    public static void main(String[] args) {
        //启动SpringBoot的应用，返回Spring的IOC容器
        ConfigurableApplicationContext context = SpringApplication.run(SpringbootStudyApplication.class, args);
        //获取Bean，redisTemplate
//        Object redisTemplate = context.getBean(&quot;redisTemplate&quot;);

        Object user = context.getBean(&quot;user&quot;);
        System.out.println(user);
    }
}
</code></pre>
<p>启动项目</p>
<pre><code class="language-shell">com.ludangxin.springbootstudyother.domain.User@602c4656
</code></pre>
<ul>
<li>可以获取,验证猜想</li>
</ul>
<h6 id="4282-import">4.2.8.2 @Import</h6>
<p>Import  指定想要导入的配置类,这些类会被spring创建,并放入ioc容器</p>
<pre><code class="language-java">@SpringBootApplication
//@ComponentScan({&quot;com.ludangxin.springbootstudyother.config&quot;})
@Import(com.ludangxin.springbootstudyother.config.UserConfig.class)
public class SpringbootStudyApplication {
    public static void main(String[] args) {
        //启动SpringBoot的应用，返回Spring的IOC容器
        ConfigurableApplicationContext context = SpringApplication.run(SpringbootStudyApplication.class, args);
        //获取Bean，redisTemplate
//        Object redisTemplate = context.getBean(&quot;redisTemplate&quot;);
        Object user = context.getBean(&quot;user&quot;);
        System.out.println(user);
    }
}
</code></pre>
<p>启动项目</p>
<pre><code class="language-shell">com.ludangxin.springbootstudyother.domain.User@712cfb63
</code></pre>
<ul>
<li>可以获取,验证猜想</li>
</ul>
<h5 id="429-改造import">4.2.9  改造import</h5>
<ol>
<li>在springboot-study-other 模块中添加配置 用于激活UserConfig 配置类</li>
</ol>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(UserConfig.class)
public @interface EnableUser {
}
</code></pre>
<ol start="2">
<li>
<p>在springboot-study 启动类上添加该配置</p>
<pre><code class="language-java">@SpringBootApplication
//@ComponentScan({&quot;com.ludangxin.springbootstudyother.config&quot;})
//@Import(com.ludangxin.springbootstudyother.config.UserConfig.class)
@EnableUser
public class SpringbootStudyApplication {
    public static void main(String[] args) {
        //启动SpringBoot的应用，返回Spring的IOC容器
        ConfigurableApplicationContext context = SpringApplication.run(SpringbootStudyApplication.class, args);
        //获取Bean，redisTemplate
//        Object redisTemplate = context.getBean(&quot;redisTemplate&quot;);

        Object user = context.getBean(&quot;user&quot;);
        System.out.println(user);
    }
}
</code></pre>
</li>
<li>
<p>启动项目</p>
</li>
</ol>
<pre><code class="language-shell">com.ludangxin.springbootstudyother.domain.User@ca66933
</code></pre>
<ul>
<li>改造后 比前两种方法更好用,不错</li>
</ul>
<h3 id="5-import">5 Import</h3>
<p>@Enable*底层依赖于@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中。而@Import提供4中用法：</p>
<ol>
<li>导入Bean</li>
<li>导入配置类</li>
<li>导入 ImportSelector 实现类。一般用于加载配置文件中的类</li>
<li>导入 ImportBeanDefinitionRegistrar 实现类。</li>
</ol>
<h3 id="6-enableautoconfiguration">6 EnableAutoConfiguration</h3>
<h4 id="61-源码追踪">6.1 源码追踪</h4>
<ol>
<li>
<p>查看@SpringBootApplication源码</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = { @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
		@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {...}
</code></pre>
</li>
<li>
<p>查看@EnableAutoConfiguration源码</p>
<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import(AutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {...}
</code></pre>
</li>
<li>
<p>查看AutoConfigurationImportSelector 类</p>
<pre><code class="language-java">public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,
		ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {
	...
    /**
     * 核心代码(实现了DeferredImportSelector接口,重写selectImports方法)
    */
	@Override
	public String[] selectImports(AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return NO_IMPORTS;
		}
		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);
		return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
	}
</code></pre>
</li>
<li>
<p>查看getAutoConfigurationEntry方法</p>
<pre><code class="language-java">protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return EMPTY_ENTRY;
		}
		AnnotationAttributes attributes = getAttributes(annotationMetadata);
		List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);
		configurations = removeDuplicates(configurations);
		Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);
		checkExcludedClasses(configurations, exclusions);
		configurations.removeAll(exclusions);
		configurations = getConfigurationClassFilter().filter(configurations);
		fireAutoConfigurationImportEvents(configurations, exclusions);
		return new AutoConfigurationEntry(configurations, exclusions);
	}
</code></pre>
</li>
<li>
<p>继续查看getCandidateConfigurations方法</p>
<pre><code class="language-java">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) {
		List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
				getBeanClassLoader());
		Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;
				+ &quot;are using a custom packaging, make sure that file is correct.&quot;);
		return configurations;
	}
</code></pre>
<ul>
<li>从该方法断言可以得知,默认读取的是META-INF/spring.factories 下的配置</li>
</ul>
</li>
<li>
<p>查看spring.factories文件(这里只列举了一部分)</p>
<pre><code class="language-properties"># Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\
org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener

# Application Listeners
org.springframework.context.ApplicationListener=\
org.springframework.boot.autoconfigure.BackgroundPreinitializer

# Auto Configuration Import Listeners
org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\
org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener

# Auto Configuration Import Filters
org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\
org.springframework.boot.autoconfigure.condition.OnBeanCondition,\
org.springframework.boot.autoconfigure.condition.OnClassCondition,\
org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition...
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration...
</code></pre>
</li>
<li>
<p>查看最后一行的RedisAutoConfiguration文件信息</p>
<pre><code class="language-java">@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RedisOperations.class)
@EnableConfigurationProperties(RedisProperties.class)
@Import({ LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class })
public class RedisAutoConfiguration {

	@Bean
	@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)
	public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)
			throws UnknownHostException {
		RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
		template.setConnectionFactory(redisConnectionFactory);
		return template;
	}
	
	@Bean
	@ConditionalOnMissingBean
	public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory)
			throws UnknownHostException {
		StringRedisTemplate template = new StringRedisTemplate();
		template.setConnectionFactory(redisConnectionFactory);
		return template;
	}

}
</code></pre>
</li>
</ol>
<h4 id="62-真相了">6.2 真相了</h4>
<ul>
<li>原来springboot 是同过import的第三种方式(导入 ImportSelector 实现类。一般用于加载配置文件中的类),通过实现<code>ImportSelector</code> 的<code>selectImports</code>方法来默认读取<code>spring.factories</code>中的配置类信息,然后再通过<code>spring.factories</code>中的配置信息,默认去加载一些配置类,然后再通过配置类中的条件注解去加载一些默认配置.</li>
<li>大功告成</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot 集成 Mybatis-Plus]]></title>
        <id>http://blog.ludangxin.club/post/mybatis-plus/</id>
        <link href="http://blog.ludangxin.club/post/mybatis-plus/">
        </link>
        <updated>2020-08-19T16:11:48.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-mybatis-plus简介">1 Mybatis-Plus简介</h2>
<h3 id="11-简介">1.1 简介</h3>
<p>MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。该框架由baomidou（苞米豆）组织开发并且开源的。官网：<a href="https://mp.baomidou.com/">https://mp.baomidou.com/</a>，码云地址：<a href="https://gitee.com/organizations/baomidou">https://gitee.com/organizations/baomidou</a><br>
<img src="http://blog.ludangxin.club/post-images/1597928865765.png" alt="" loading="lazy"><br>
<strong>愿景</strong><br>
我们的愿景是成为 MyBatis 最好的搭档，就像魂斗罗 中的 1P、2P，基友搭配，效率翻倍。<br>
<img src="http://blog.ludangxin.club/post-images/1597928952406.png" alt="" loading="lazy"></p>
<h3 id="12-特性">1.2 特性</h3>
<ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li>
<li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li>
<li><strong>支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer 等多种数据库</li>
<li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li>
<li><strong>支持 XML 热加载</strong>：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML 启动</li>
<li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li>
<li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li>
<li><strong>支持关键词自动转义</strong>：支持数据库关键词（order、key......）自动转义，还可自定义关键词</li>
<li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li>
<li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li>
<li><strong>内置性能分析插件</strong>：可输出 Sql 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li>
<li><strong>内置全局拦截插件</strong>：提供全表 delete 、update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li>
<li><strong>内置 Sql 注入剥离器</strong>：支持 Sql 注入剥离，有效预防 Sql 注入攻击</li>
</ul>
<h2 id="2-快速入门">2 快速入门</h2>
<h3 id="21-创建数据库及表">2.1 创建数据库及表</h3>
<figure data-type="image" tabindex="1"><img src="http://blog.ludangxin.club/post-images/1597928994208.png" alt="" loading="lazy"></figure>
<pre><code class="language-sql">-- 创建测试表
CREATE TABLE `sys_user` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `user_name` varchar(20) NOT NULL COMMENT '用户名',
  `name` varchar(30) DEFAULT NULL COMMENT '姓名',
  `age` int(11) DEFAULT NULL COMMENT '年龄',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

-- 插入测试数据
INSERT INTO `sys_user` (`id`, `user_name`, `name`, `age`) VALUES ('1', 'zhangsan', '张三', '18');
INSERT INTO `sys_user` (`id`, `user_name`, `name`, `age`) VALUES ('2', 'lisi', '李四', '20');
INSERT INTO `sys_user` (`id`, `user_name`, `name`, `age`) VALUES ('3', 'wangwu', '王五', '28');
INSERT INTO `sys_user` (`id`, `user_name`, `name`, `age`) VALUES ('4', 'zhaoliu', '赵六', '21');
INSERT INTO `sys_user` (`id`, `user_name`, `name`, `age`) VALUES ('5', 'sunqi', '孙七', '24');
~~~![](http://blog.ludangxin.club/post-images/1597929873595.jpg)
### 2.2 工程搭建
#### 完整的项目结构图示
![](http://blog.ludangxin.club/post-images/1597929500996.jpg)
#### 2.2.1 添加所需依赖
~~~xml
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--简化代码的工具包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;!--mybatis-plus的springboot支持--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;3.3.2&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--mysql驱动--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
<h4 id="222-配置-applicationyml">2.2.2 配置 application.yml</h4>
<pre><code class="language-yaml">spring:
  datasource:
    # Oracle: oracle.jdbc.OracleDriver
    #  5.7之前版本使用 com.mysql.jdbc.Driver 
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/mp?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8
    username: root
    password: root
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      minimum-idle: 5
      maximum-pool-size: 5
      auto-commit: true
      idle-timeout: 30000
      pool-name: DatebookHikariCP
      max-lifetime: 1800000
      connection-timeout: 30000
      connection-test-query: SELECT 1  # Oracle: SELECT 1 FROM DUAL

mybatis-plus:
  # 设置Mapper接口所对应的XML文件位置，如果你在Mapper接口中有自定义方法，需要进行该配置
  mapper-locations: classpath*:mybatis/*.xml
  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名
  type-aliases-package: com.ludangxin.mp.pojo
  configuration:
    # 控制台sql打印
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl

</code></pre>
<h4 id="223-编写pojo">2.2.3 编写pojo</h4>
<pre><code class="language-java">import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@TableName(&quot;sys_user&quot;)
public class User {
    @TableId(&quot;ID&quot;)
    private Long id;
    //驼峰命名,则无需注解
    @TableField(&quot;USER_NAME&quot;) 
    private String userName; 
    @TableField(&quot;NAME&quot;)
    private String name;
    @TableField(&quot;AGE&quot;)
    private Integer age;
}
</code></pre>
<h4 id="225-编写mapper接口和配置文件">2.2.5 编写mapper接口和配置文件</h4>
<pre><code class="language-java">import com.ludangxin.mp.pojo.User;
import com.baomidou.mybatisplus.core.mapper.BaseMapper;

public interface UserMapper extends BaseMapper&lt;User&gt; {
}
</code></pre>
<p>在resources目录下新建一个文件夹mybatis，专门存放mapper配置文件</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.ludangxin.mp.mapper.UserMapper&quot;&gt;
    
&lt;/mapper&gt;
</code></pre>
<h4 id="226-修改启动类">2.2.6 修改启动类</h4>
<pre><code class="language-java">import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.WebApplicationType;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.builder.SpringApplicationBuilder;

//设置mapper接口的扫描包
@MapperScan(&quot;com.ludangxin.mp.mapper&quot;) 
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
</code></pre>
<h4 id="227-编写测试用例">2.2.7 编写测试用例</h4>
<pre><code class="language-java">import com.ludangxin.mp.mapper.UserMapper;
import com.ludangxin.mp.pojo.User;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.List;

@RunWith(SpringRunner.class)
@SpringBootTest
public class TestMybatisSpringBoot {

    @Autowired
    private UserMapper userMapper;

    @Test
    public void testSelect() {
        //根据id查询数据
        User user = userMapper.selectById(2L);
        System.out.println(user);
    }

}
</code></pre>
<p>测试结果：</p>
<pre><code class="language-shell">JDBC Connection [HikariProxyConnection@358849801 wrapping com.mysql.cj.jdbc.ConnectionImpl@4fba8eec] will not be managed by Spring
==&gt;  Preparing: SELECT ID,USER_NAME,NAME,AGE FROM sys_user WHERE ID=? 
==&gt; Parameters: 2(Long)
&lt;==    Columns: ID, USER_NAME, NAME, AGE
&lt;==        Row: 2, lisi, 李四, 20
&lt;==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@39da5e49]
User(id=2, userName=lisi, name=李四, age=20)
</code></pre>
<h2 id="3-通用crud">3 通用CRUD</h2>
<pre><code>在入门案例中，我们的Mapper接口继承了BaseMapper，然后就可以进行到各种各样的单表操作，接下来我们将详细讲解这些操作。
</code></pre>
<figure data-type="image" tabindex="2"><img src="http://blog.ludangxin.club/post-images/1597929052973.png" alt="" loading="lazy"></figure>
<h3 id="31-插入操作">3.1 插入操作</h3>
<h4 id="311-insert方法">3.1.1 insert方法</h4>
<pre><code class="language-java">/**
 * 插入一条记录
 * @param entity 实体对象
*/
int insert(T entity);
</code></pre>
<h4 id="312-测试用例">3.1.2 测试用例</h4>
<pre><code class="language-java">import com.ludangxin.mp.mapper.UserMapper;
import com.ludangxin.mp.pojo.User;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.junit4.SpringRunner;

import java.util.List;

@RunWith(SpringRunner.class)
@SpringBootTest
public class TestUserMapper {

    @Autowired
    private UserMapper userMapper;

    @Test
    public void testInsert(){
        User user = new User();
        user.setAge(301);
        user.setUserName(&quot;caocao&quot;);
        user.setName(&quot;曹操&quot;);

        //返回的result是受影响的行数，并不是自增后的id
        int result = userMapper.insert(user); 
        System.out.println(&quot;result = &quot; + result); 

        //自增后的id会回填到对象中
        System.out.println(user.getId()); 
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code class="language-shell">JDBC Connection [HikariProxyConnection@1240320816 wrapping com.mysql.cj.jdbc.ConnectionImpl@59303963] will not be managed by Spring
==&gt;  Preparing: INSERT INTO sys_user ( ID, USER_NAME, NAME, AGE ) VALUES ( ?, ?, ?, ? ) 
==&gt; Parameters: 1295736901034086401(Long), caocao(String), 曹操(String), 301(Integer)
&lt;==    Updates: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@108e9837]
result = 1
1295736901034086401
</code></pre>
<h4 id="313-主键生成策略">3.1.3 主键生成策略</h4>
<pre><code>在刚才的例子中，数据已经保存到了数据库，但是id的值不是我们期望的自增长，而是MP生成了id的值并写入到了数据库。我们也可以通过IdType类自己设置id的生成策略。
</code></pre>
<pre><code class="language-java">package com.baomidou.mybatisplus.annotation;
import lombok.Getter;

/**
 * 生成ID类型枚举类
 */
@Getter
public enum IdType {
    /**
     * 数据库ID自增
     */
    AUTO(0),
    /**
     * 该类型为未设置主键类型，这是默认值
     */
    NONE(1),
    /**
     * 用户输入ID
     * &lt;p&gt;该类型可以通过自己注册自动填充插件进行填充&lt;/p&gt;
     */
    INPUT(2),

    /* 以下3种类型、只有当插入对象ID为空，才自动填充。 */
    /**
     * 全局唯一ID (idWorker)
     */
    ID_WORKER(3),
    /**
     * 全局唯一ID (UUID)
     */
    UUID(4),
    /**
     * 字符串全局唯一ID (idWorker的字符串表示)
     */
    ID_WORKER_STR(5);

    private final int key;

    IdType(int key) {
        this.key = key;
    }
}

</code></pre>
<p>修改User对象，设置id为自增长：</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
@TableName(&quot;sys_user&quot;)
public class User {

    @TableId(type = IdType.AUTO) //指定id为自增长
    private Long id;
    ... ...
}
</code></pre>
<h3 id="32-更新操作">3.2 更新操作</h3>
<h4 id="321-updatebyid方法">3.2.1 updateById方法</h4>
<pre><code class="language-java">/**
 * 根据ID修改
 * @param entity 实体对象
 */
int updateById(@Param(Constants.ENTITY) T entity);
</code></pre>
<p>####　3.2.2 测试用例</p>
<pre><code class="language-java">    @Test
    public void testUpdateById() {
        User user = new User();
        user.setId(5L); //主键
        user.setAge(21); //更新的字段

        //根据id更新，更新不为null的字段
        this.userMapper.updateById(user);
    }

}
</code></pre>
<p>测试结果：</p>
<pre><code class="language-shell">JDBC Connection [HikariProxyConnection@864078397 wrapping com.mysql.cj.jdbc.ConnectionImpl@23310248] will not be managed by Spring
==&gt;  Preparing: UPDATE sys_user SET AGE=? WHERE id=? 
==&gt; Parameters: 21(Integer), 5(Long)
&lt;==    Updates: 1
</code></pre>
<h3 id="33-删除操作">3.3 删除操作</h3>
<h4 id="331-deletebyid">3.3.1 deleteById</h4>
<pre><code class="language-java">/**
 * 根据 ID 删除
 * @param id 主键ID
 */
int deleteById(Serializable id);
</code></pre>
<h4 id="332-测试用例">3.3.2 测试用例</h4>
<pre><code class="language-java">	@Test
    public void testDeleteById() {
        //执行删除操作
        int result = this.userMapper.deleteById(6L);
        System.out.println(&quot;result = &quot; + result);
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code class="language-shell">JDBC Connection [HikariProxyConnection@103068963 wrapping com.mysql.cj.jdbc.ConnectionImpl@50b46e24] will not be managed by Spring
==&gt;  Preparing: DELETE FROM sys_user WHERE id=? 
==&gt; Parameters: 5(Long)
&lt;==    Updates: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@5934ca1e]
result = 1
</code></pre>
<h4 id="333-批量删除">3.3.3 批量删除</h4>
<pre><code class="language-java">	@Test 
    public void testDeleteByIds() { 
        //根据id集合批量删除 
        int result = this.userMapper.deleteBatchIds(Arrays.asList(1L,10L,20L));
        System.out.println(&quot;result = &quot; + result); 
    }
</code></pre>
<h3 id="34-查询操作">3.4 查询操作</h3>
<p>MP提供了多种查询操作，包括根据id查询、批量查询、查询单条数据、查询列表、分页查询等操作。</p>
<h4 id="341-selectbyid">3.4.1 selectById</h4>
<pre><code class="language-java">/**
 * 根据ID查询
 * @param id 主键ID
 */
T selectById(Serializable id);
</code></pre>
<h4 id="342-测试用例">3.4.2 测试用例</h4>
<pre><code class="language-java">    @Test
    public void testSelectById() {
        //根据id查询数据
        User user = this.userMapper.selectById(2L);
        System.out.println(&quot;result = &quot; + user);
    }
}
</code></pre>
<p>测试结果：</p>
<pre><code class="language-shell">JDBC Connection [HikariProxyConnection@1317052417 wrapping com.mysql.cj.jdbc.ConnectionImpl@624b523] will not be managed by Spring
==&gt;  Preparing: SELECT id,USER_NAME,NAME,AGE FROM sys_user WHERE id=? 
==&gt; Parameters: 2(Long)
&lt;==    Columns: id, USER_NAME, NAME, AGE
&lt;==        Row: 2, lisi, 李四, 20
&lt;==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@1cbc5693]
result = User(id=2, userName=lisi, name=李四, age=20)
</code></pre>
<h2 id="4-条件构造器">4 条件构造器</h2>
<pre><code>在增删改查中，最复杂的就是带有各种条件的操作。在MP中，专门针对sql条件进行了封装，提供了各种Wrapper接口及其实现类。XxxWrapper类提供了各种方法来封装sql条件。
</code></pre>
<figure data-type="image" tabindex="3"><img src="http://blog.ludangxin.club/post-images/1597929075718.png" alt="" loading="lazy"></figure>
<p>MP提供了各种方法用来支持带有条件的查询方法、修改方法和删除方法：</p>
<pre><code class="language-java">/**
根据 entity 条件，查询一条记录
@param queryWrapper 实体对象封装操作类（可以为null）
*/
T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);

/**
根据 Wrapper 条件，查询总记录数
@param queryWrapper 实体对象封装操作类（可以为null）
*/
Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);

/**
根据 entity 条件，查询全部记录
@param queryWrapper 实体对象封装操作类（可以为null）
*/
List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);
</code></pre>
<p>下面我们以查询方法为例学习条件构造器的具体用法。</p>
<h3 id="41-比较操作">4.1 比较操作</h3>
<ul>
<li>eq
<ul>
<li>等于 =</li>
</ul>
</li>
<li>ne
<ul>
<li>不等于 &lt;&gt;</li>
</ul>
</li>
<li>gt
<ul>
<li>大于 &gt;</li>
</ul>
</li>
<li>ge
<ul>
<li>大于等于 &gt;=</li>
</ul>
</li>
<li>lt
<ul>
<li>小于 &lt;</li>
</ul>
</li>
<li>le
<ul>
<li>小于等于 &lt;=</li>
</ul>
</li>
<li>between
<ul>
<li>BETWEEN 值1 AND 值2</li>
</ul>
</li>
<li>notBetween
<ul>
<li>NOT BETWEEN 值1 AND 值2</li>
</ul>
</li>
<li>in
<ul>
<li>字段 IN (value.get(0), value.get(1), ...)</li>
</ul>
</li>
<li>notIn
<ul>
<li>字段 NOT IN (v0, v1, ...)</li>
</ul>
</li>
</ul>
<p>测试用例：</p>
<pre><code class="language-java">    @Test
    public void testEq() {
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();

        //SELECT id,user_name,name,age FROM sys_user WHERE 
        // AND age &gt;= ? AND name IN (?,?,?)
        wrapper.ge(&quot;age&quot;, 20)
               .in(&quot;name&quot;, &quot;李四&quot;, &quot;王五&quot;, &quot;赵六&quot;);

        List&lt;User&gt; users = this.userMapper.selectList(wrapper);
        for (User user : users) {
            System.out.println(user);
        }
    }
}
</code></pre>
<p>测试结果:</p>
<pre><code class="language-shell">JDBC Connection [HikariProxyConnection@525275084 wrapping com.mysql.cj.jdbc.ConnectionImpl@46c10083] will not be managed by Spring
==&gt;  Preparing: SELECT id,USER_NAME,NAME,AGE FROM sys_user WHERE age &gt;= ? AND name IN (?,?,?) 
==&gt; Parameters: 20(Integer), 李四(String), 王五(String), 赵六(String)
&lt;==    Columns: id, USER_NAME, NAME, AGE
&lt;==        Row: 2, lisi, 李四, 20
&lt;==        Row: 3, wangwu, 王五, 28
&lt;==        Row: 4, zhaoliu, 赵六, 21
&lt;==      Total: 3
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@61149fa5]
User(id=2, userName=lisi, name=李四, age=20)
User(id=3, userName=wangwu, name=王五, age=28)
User(id=4, userName=zhaoliu, name=赵六, age=21)
</code></pre>
<h3 id="42-模糊查询">4.2 模糊查询</h3>
<ul>
<li>like
<ul>
<li>LIKE '%值%'</li>
<li>例: <code>like(&quot;name&quot;, &quot;王&quot;)</code>---&gt;<code>name like '%王%'</code></li>
</ul>
</li>
<li>notLike
<ul>
<li>NOT LIKE '%值%'</li>
<li>例: <code>notLike(&quot;name&quot;, &quot;王&quot;)</code>---&gt;<code>name not like '%王%'</code></li>
</ul>
</li>
<li>likeLeft
<ul>
<li>LIKE '%值'</li>
<li>例: <code>likeLeft(&quot;name&quot;, &quot;王&quot;)</code>---&gt;<code>name like '%王'</code></li>
</ul>
</li>
<li>likeRight
<ul>
<li>LIKE '值%'</li>
<li>例: <code>likeRight(&quot;name&quot;, &quot;王&quot;)</code>---&gt;<code>name like '王%'</code></li>
</ul>
</li>
</ul>
<p>测试用例：</p>
<pre><code class="language-java">    @Test
    public void testLike() {
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();

        //SELECT id,user_name,name,age FROM sys_user WHERE name LIKE ?
        //Parameters: %曹%(String)
        wrapper.like(&quot;name&quot;, &quot;曹&quot;);

        List&lt;User&gt; users = this.userMapper.selectList(wrapper);
        for (User user : users) {
            System.out.println(user);
        }
    }
}
</code></pre>
<h3 id="43-排序">4.3 排序</h3>
<ul>
<li>orderBy
<ul>
<li>排序：ORDER BY 字段, ...</li>
<li>例: <code>orderBy(true, true, &quot;id&quot;, &quot;name&quot;)</code>---&gt;<code>order by id ASC,name ASC</code></li>
</ul>
</li>
<li>orderByAsc
<ul>
<li>排序：ORDER BY 字段, ... ASC</li>
<li>例: <code>orderByAsc(&quot;id&quot;, &quot;name&quot;)</code>---&gt;<code>order by id ASC,name ASC</code></li>
</ul>
</li>
<li>orderByDesc
<ul>
<li>排序：ORDER BY 字段, ... DESC</li>
<li>例: <code>orderByDesc(&quot;id&quot;, &quot;name&quot;)</code>---&gt;<code>order by id DESC,name DESC</code></li>
</ul>
</li>
</ul>
<p>测试用例：</p>
<pre><code class="language-java">    @Test
    public void testOrderByAgeDesc() {
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();

        //SELECT id,user_name,name,age FROM sys_user ORDER BY age DESC
        wrapper.orderByDesc(&quot;age&quot;);

        List&lt;User&gt; users = this.userMapper.selectList(wrapper);
        for (User user : users) {
            System.out.println(user);
        }
    }
}
</code></pre>
<h3 id="44-逻辑查询">4.4 逻辑查询</h3>
<ul>
<li>or
<ul>
<li>拼接 OR</li>
<li>主动调用<code>or</code>表示紧接着下一个<strong>方法</strong>不是用<code>and</code>连接!(不调用<code>or</code>则默认为使用<code>and</code>连接)</li>
</ul>
</li>
<li>and
<ul>
<li>AND 嵌套</li>
<li>例: <code>and(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))</code>---&gt;<code>and (name = '李白' and status &lt;&gt; '活着')</code></li>
</ul>
</li>
</ul>
<p>测试用例：</p>
<pre><code class="language-java">	@Test
    public void testOr() {
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();

        //SELECT id,user_name,name,age FROM sys_user WHERE 
        //name = ? OR age = ?
        wrapper.eq(&quot;name&quot;,&quot;李四&quot;).or().eq(&quot;age&quot;, 24);

        List&lt;User&gt; users = this.userMapper.selectList(wrapper);
        for (User user : users) {
            System.out.println(user);
        }
    }
}
</code></pre>
<pre><code class="language-java">	@Test
    public void testAnd() {
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;&gt;();

        //SELECT id,USER_NAME,NAME,AGE FROM sys_user WHERE age = ? AND ( name = ? OR user_Name = ? ) 
        wrapper.eq(&quot;age&quot;, 20)
        .and(obj -&gt; obj.eq(&quot;name&quot;,&quot;李四&quot;).or().eq(&quot;user_name&quot;, &quot;王五&quot;));

        List&lt;User&gt; users = this.userMapper.selectList(wrapper);
        for (User user : users) {
            System.out.println(user);
        }
    }
</code></pre>
<h3 id="45-分页查询">4.5 分页查询</h3>
<p>selectPage方法：</p>
<pre><code class="language-java">/**
 * 根据 entity 条件，查询全部记录（并翻页）
 * @param page         分页查询条件（可以为 RowBounds.DEFAULT）
 * @param queryWrapper 实体对象封装操作类（可以为 null）
 */
IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper);
</code></pre>
<p>配置分页插件：</p>
<pre><code class="language-java">import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MybatisPlusConfig {

    /**
     * 分页插件
     */
    @Bean
    public PaginationInterceptor paginationInterceptor() {
        PaginationInterceptor paginationInterceptor = new PaginationInterceptor();
        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false
        // paginationInterceptor.setOverflow(false);
        // 设置最大单页限制数量，默认 500 条，-1 不受限制
        // paginationInterceptor.setLimit(500);
        // 开启 count 的 join 优化,只针对部分 left join
        paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));
        return paginationInterceptor;
    }
}
</code></pre>
<p>测试用例：</p>
<pre><code class="language-java">    @Test
    public void testSelectPage() {
        QueryWrapper&lt;User&gt; wrapper = new QueryWrapper&lt;User&gt;();
        wrapper.gt(&quot;age&quot;, 20); //年龄大于20岁

        Page&lt;User&gt; page = new Page&lt;&gt;(1,1);

        //根据条件查询数据
        IPage&lt;User&gt; iPage = this.userMapper.selectPage(page, wrapper);
        System.out.println(&quot;数据总条数：&quot; + iPage.getTotal());
        System.out.println(&quot;总页数：&quot; + iPage.getPages());

        List&lt;User&gt; users = iPage.getRecords();
        for (User user : users) {
            System.out.println(&quot;user = &quot; + user);
        }
    }
}
</code></pre>
<p>测试结果:</p>
<pre><code class="language-sh">JDBC Connection [HikariProxyConnection@1663774813 wrapping com.mysql.cj.jdbc.ConnectionImpl@44598ef7] will not be managed by Spring
JsqlParserCountOptimize sql=SELECT  id,USER_NAME,NAME,AGE  FROM sys_user WHERE age &gt; ?
==&gt;  Preparing: SELECT COUNT(1) FROM sys_user WHERE age &gt; ? 
==&gt; Parameters: 20(Integer)
&lt;==    Columns: COUNT(1)
&lt;==        Row: 3
==&gt;  Preparing: SELECT id,USER_NAME,NAME,AGE FROM sys_user WHERE age &gt; ? LIMIT ?,? 
==&gt; Parameters: 20(Integer), 0(Long), 1(Long)
&lt;==    Columns: id, USER_NAME, NAME, AGE
&lt;==        Row: 3, wangwu, 王五, 28
&lt;==      Total: 1
Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@11d4d979]
数据总条数：3
总页数：3
user = User(id=3, userName=wangwu, name=王五, age=28)
</code></pre>
<h3 id="46-修改和删除">4.6 修改和删除</h3>
<pre><code>前面都是以查询为例讲解条件构造器，那么在进行修改和删除操作时也可以带条件，和查询基本一样，这里不再讲解，后面用到时再说。
</code></pre>
<pre><code class="language-java">/**
根据wrapper封装的条件进行更新操作
*/
int delete(@Param(&quot;ew&quot;) Wrapper&lt;T&gt; wrapper);

/**
根据wrapper封装的条件进行删除操作
*/
int update(@Param(&quot;et&quot;) T entity, @Param(&quot;ew&quot;) Wrapper&lt;T&gt; updateWrapper);
</code></pre>
<h3 id="47-lambda">4.7  lambda</h3>
<p>​	获取 <code>LambdaWrapper</code><br>
​	在<code>QueryWrapper</code>中是获取<code>LambdaQueryWrapper</code><br>
​	在<code>UpdateWrapper</code>中是获取<code>LambdaUpdateWrapper</code></p>
<p>​	<strong>强烈使用lambda表达式构建wrapper，无需再担心字段写错</strong></p>
<h4 id="471-测试用例">4.7.1 测试用例</h4>
<pre><code class="language-java">	@Test
    public void testLambdaSelect(){
        LambdaQueryWrapper lambdaQueryWrapper = new LambdaQueryWrapper&lt;User&gt;().eq(User::getUserName,&quot;zhangsan&quot;);
        //QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();
        //queryWrapper.lambda().eq(User::getName, &quot;zhangsan&quot;);
        int result = this.userMapper.selectCount(lambdaQueryWrapper);
        System.out.println(&quot;result = &quot; + result);
    }
</code></pre>
<h2 id="5-mybatis-plus的service封装">5 Mybatis-Plus的Service封装</h2>
<pre><code>Mybatis-Plus为了开发更加快捷，对业务层也进行了封装，直接提供了相关的接口和实现类。我们在进行业务层开发时，可以继承它提供的接口和实现类，使得编码更加高效。
</code></pre>
<ol>
<li>
<p>com.baomidou.mybatisplus.extension.service.IService接口</p>
<p>该接口是一个泛型接口，里面提供了很多方法，包括基本的增删改查。<br>
<img src="http://blog.ludangxin.club/post-images/1597929094373.png" alt="" loading="lazy"></p>
</li>
<li>
<p>com.baomidou.mybatisplus.extension.service.impl.ServiceImpl类</p>
<p>该类实现了上面接口中的所有方法。</p>
</li>
<li>
<p>测试用例</p>
<p>1）自定义业务层接口，继承IService：</p>
<pre><code class="language-java">public interface UserService extends IService&lt;User&gt; {

}
</code></pre>
<p>2）自定义业务层实现类，继承ServiceImpl：</p>
<pre><code class="language-java">@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper,User&gt; implements UserService {

}
</code></pre>
<p>3）测试类：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class TestUserService {
    @Autowired
    private UserService userService;

    @Test
    public void testInsert() {
        User user = new User();
        user.setAge(301);
        user.setUserName(&quot;caocao1&quot;);
        user.setName(&quot;曹操1&quot;);

        userService.save(user);

        //获取自增长后的id值, 自增长后的id值会回填到user对象中
        System.out.println(&quot;id =&gt; &quot; + user.getId());
    }

    @Test
    public void testSelectById() {
        User user = userService.getById(2);
        System.out.println(user);
    }

    @Test
    public void testUpdateById() {
        User user = new User();
        user.setId(1L); //条件，根据id更新
        user.setAge(19); //更新的字段

        userService.updateById(user);
    }

    @Test
    public void testDeleteById(){
        // 根据id删除数据
        userService.removeById(2L);
    }

}
</code></pre>
</li>
</ol>
<h2 id="6-oracle-主键-sequence">6 oracle 主键 Sequence</h2>
<p>在mysql中，主键往往是自增长的，这样使用起来是比较方便的，如果使用的是Oracle数据库，那么就不能使用自增长了，就得使用Sequence 序列生成id值了。</p>
<h3 id="61修改applicationproperties">6.1修改application.properties</h3>
<pre><code class="language-yaml">mybatis-plus:
  # 设置Mapper接口所对应的XML文件位置，如果你在Mapper接口中有自定义方法，需要进行该配置
  mapper-locations: classpath*:mybatis/*.xml
  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名
  type-aliases-package: com.ludangxin.mp.pojo
  configuration:
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  # id 生成策略
  global-config:
    db-config:
      id-type: input
</code></pre>
<h3 id="62-mybatisplusconfig-增加序列生成器配置">6.2 MybatisPlusConfig 增加序列生成器配置</h3>
<pre><code class="language-java">/*** 序列生成器 */ 
@Bean 
public OracleKeyGenerator oracleKeyGenerator(){ 
    return new OracleKeyGenerator();
}
</code></pre>
<h2 id="7-逻辑删除">7 逻辑删除</h2>
<p>开发系统时，有时候在实现功能时，删除操作需要实现逻辑删除，所谓逻辑删除就是将数据标记为删除，而并非真正的物理删除（非DELETE操作），查询时需要携带状态条件，确保被标记的数据不被查询到。这样做的目的就是避免数据被真正的删除。</p>
<h3 id="71-增加字段">7.1 增加字段</h3>
<pre><code class="language-sql">ALTER TABLE sys_user ADD COLUMN deleted int(1) NULL DEFAULT 0 COMMENT '1代表删除，0代表未删除';
</code></pre>
<h3 id="72-修改pojo">7.2 修改pojo</h3>
<pre><code class="language-java">@TableLogic 
private Integer deleted;
</code></pre>
<h3 id="73-修改applicationyml">7.3 修改application.yml</h3>
<pre><code class="language-yaml">mybatis-plus:
  # 设置Mapper接口所对应的XML文件位置，如果你在Mapper接口中有自定义方法，需要进行该配置
  mapper-locations: classpath*:mybatis/*.xml
  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名
  type-aliases-package: com.ludangxin.mp.pojo
  configuration:
    # 控制台sql打印
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      # 逻辑删除值为1
      logic-delete-value: 1
      # 逻辑未删除值为 0
      logic-not-delete-value: 0
</code></pre>
<h3 id="74-测试用例">7.4 测试用例</h3>
<pre><code class="language-java">@Test
    public void testDeleteById2() {
        this.userMapper.deleteById(3L);
    }
</code></pre>
<h3 id="75-测试结果">7.5 测试结果</h3>
<pre><code class="language-shell">JDBC Connection [HikariProxyConnection@2098830440 wrapping com.mysql.cj.jdbc.ConnectionImpl@63411512] will not be managed by Spring
==&gt;  Preparing: UPDATE sys_user SET deleted=1 WHERE id=? AND deleted=0 
==&gt; Parameters: 3(Long)
&lt;==    Updates: 1
</code></pre>
<h2 id="8-乐观锁">8   乐观锁</h2>
<h3 id="主要适用场景">主要适用场景</h3>
<p>意图：</p>
<p>当要更新一条记录的时候，希望这条记录没有被别人更新</p>
<p>乐观锁实现方式：</p>
<ul>
<li>取出记录时，获取当前version</li>
<li>更新时，带上这个version</li>
<li>执行更新时， set version = newVersion where version = oldVersion</li>
<li>如果version不对，就更新失败</li>
</ul>
<p><strong>乐观锁配置需要2步 记得两步</strong></p>
<h3 id="81-增加字段">8.1 增加字段</h3>
<pre><code class="language-sql">ALTER TABLE `sys_user` ADD COLUMN `version` int(10) NULL COMMENT '乐观锁' ;
</code></pre>
<h3 id="82-修改pojo">8.2  修改pojo</h3>
<pre><code class="language-java">@Version 
private Integer version;
</code></pre>
<h3 id="83-增加乐观锁配置">8.3 增加乐观锁配置</h3>
<pre><code class="language-java">/**
 * 乐观锁配置
 * @return
*/
@Bean
public OptimisticLockerInterceptor optimisticLockerInterceptor() {
    return new OptimisticLockerInterceptor();
}
</code></pre>
<h3 id="84-测试用例">8.4 测试用例</h3>
<pre><code class="language-java">@Test
    public void testUpdate(){
        User user = new User();
        user.setAge(30);
        user.setId(2L);
        //获取到version为1
        user.setVersion(1);        
        int result = this.userMapper.updateById(user);
        System.out.println(&quot;result = &quot; + result); 
    }
</code></pre>
<h3 id="85-测试结果">8.5 测试结果</h3>
<pre><code class="language-shell">JDBC Connection [HikariProxyConnection@2032547119 wrapping com.mysql.cj.jdbc.ConnectionImpl@5bc63e20] will not be managed by Spring
==&gt;  Preparing: UPDATE sys_user SET AGE=?, version=? WHERE id=? AND version=? AND deleted=0 
==&gt; Parameters: 30(Integer), 2(Integer), 2(Long), 1(Integer)
&lt;==    Updates: 0
</code></pre>
<p><strong>注:</strong> 操作记录数为0说明已经有人update了</p>
<h2 id="9-自动填充功能">9 自动填充功能</h2>
<p>示例工程：</p>
<p>👉 <a href="https://gitee.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-auto-fill-metainfo">mybatis-plus-sample-auto-fill-metainfo</a></p>
<h3 id="91-添加字段">9.1 添加字段</h3>
<pre><code class="language-sql">ALTER TABLE `sys_user` ADD COLUMN `create_by` VARCHAR(50) NULL COMMENT '创建人' ;
ALTER TABLE `sys_user` ADD COLUMN `update_by` VARCHAR(50) NULL COMMENT '修改人' ;
</code></pre>
<h3 id="92-修改pojo">9.2 修改pojo</h3>
<pre><code class="language-java">@TableField(fill = FieldFill.INSERT)
private String createBy;
@TableField(fill = FieldFill.UPDATE)
private String updateBy;
</code></pre>
<h4 id="921-fieldfill提供了多种模式选择">9.2.1 FieldFill提供了多种模式选择</h4>
<pre><code class="language-java">public enum FieldFill {
    /**
     * 默认不处理
     */
    DEFAULT,
    /**
     * 插入填充字段
     */
    INSERT,
    /**
     * 更新填充字段
     */
    UPDATE,
    /**
     * 插入和更新填充字段
     */
    INSERT_UPDATE
}
</code></pre>
<ul>
<li>自定义实现类 MyMetaObjectHandler</li>
</ul>
<pre><code class="language-java">import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;
import lombok.extern.slf4j.Slf4j;
import org.apache.ibatis.reflection.MetaObject;
import org.springframework.stereotype.Component;

@Slf4j
@Component
public class MyMetaObjectHandler implements MetaObjectHandler {

    @Override
    public void insertFill(MetaObject metaObject) {
//            Object createTime = getFieldValByName(&quot;createTime&quot;, metaObject);
//            //字段为空，可以进行填充
//            if (null == createTime) {
//                setFieldValByName(&quot;createTime&quot;, LocalDateTime.now(), metaObject);
//            }
            log.info(&quot;start insert fill ....&quot;);
            this.strictInsertFill(metaObject, &quot;createBy&quot;, String.class, this.getUserId());
        }

        @Override
        public void updateFill (MetaObject metaObject){
            log.info(&quot;start update fill ....&quot;);
            this.strictUpdateFill(metaObject, &quot;updateBy&quot;, String.class, this.getUserId());
        }

        private String getUserId() {
            return &quot;001&quot;;
        }
}
</code></pre>
<p>注意事项：</p>
<ul>
<li>填充原理是直接给<code>entity</code>的属性设置值!!!</li>
<li>注解则是指定该属性在对应情况下必有值,如果无值则入库会是<code>null</code></li>
<li><code>MetaObjectHandler</code>提供的默认方法的策略均为:如果属性有值则不覆盖,如果填充值为<code>null</code>则不填充</li>
<li>字段必须声明<code>TableField</code>注解,属性<code>fill</code>选择对应策略,该声明告知<code>Mybatis-Plus</code>需要预留注入<code>SQL</code>字段</li>
<li>填充处理器<code>MyMetaObjectHandler</code>在 Spring Boot 中需要声明<code>@Component</code>或<code>@Bean</code>注入</li>
<li>要想根据注解<code>FieldFill.xxx</code>和<code>字段名</code>以及<code>字段类型</code>来区分必须使用父类的<code>strictInsertFill</code>或者<code>strictUpdateFill</code>方法</li>
<li>不需要根据任何来区分可以使用父类的<code>fillStrategy</code>方法</li>
</ul>
<h3 id="93-执行新增操作日志">9.3 执行新增操作日志</h3>
<pre><code class="language-shell">JDBC Connection [HikariProxyConnection@897358809 wrapping com.mysql.cj.jdbc.ConnectionImpl@7aea704c] will not be managed by Spring
==&gt;  Preparing: INSERT INTO sys_user ( USER_NAME, NAME, AGE, create_by ) VALUES ( ?, ?, ?, ? ) 
==&gt; Parameters: caocao(String), 曹操(String), 301(Integer), 001(String)
&lt;==    Updates: 1
</code></pre>
<h2 id="10-多数据源配置">10 多数据源配置</h2>
<h3 id="简介">简介</h3>
<p>dynamic-datasource-spring-boot-starter 是一个基于springboot的快速集成多数据源的启动器。</p>
<p>其支持 <strong>Jdk 1.7+, SpringBoot 1.4.x 1.5.x 2.x.x</strong>。</p>
<p><strong>示例项目</strong> 可参考项目下的samples目录。</p>
<h3 id="特性">特性</h3>
<ol>
<li>支持 <strong>数据源分组</strong> ，适用于多种场景 纯粹多库 读写分离 一主多从 混合模式。</li>
<li>支持数据库敏感配置信息 <strong>加密</strong> ENC()。</li>
<li>支持每个数据库独立初始化表结构schema和数据库database。</li>
<li>支持 <strong>自定义注解</strong> ，需继承DS(3.2.0+)。</li>
<li>提供对Druid，Mybatis-Plus，P6sy，Jndi的快速集成。</li>
<li>简化Druid和HikariCp配置，提供 <strong>全局参数配置</strong> 。配置一次，全局通用。</li>
<li>提供 <strong>自定义数据源来源</strong> 方案。</li>
<li>提供项目启动后 <strong>动态增加移除数据源</strong> 方案。</li>
<li>提供Mybatis环境下的 <strong>纯读写分离</strong> 方案。</li>
<li>提供使用 <strong>spel动态参数</strong> 解析数据源方案。内置spel，session，header，支持自定义。</li>
<li>支持 <strong>多层数据源嵌套切换</strong> 。（ServiceA &gt;&gt;&gt; ServiceB &gt;&gt;&gt; ServiceC）。</li>
<li>提供对shiro，sharding-jdbc,quartz等第三方库集成的方案,注意事项和示例。</li>
<li>提供 <strong>基于seata的分布式事务方案。</strong> 附：不支持原生spring事务。</li>
</ol>
<h3 id="约定">约定</h3>
<ol>
<li>本框架只做 <strong>切换数据源</strong> 这件核心的事情，并<strong>不限制你的具体操作</strong>，切换了数据源可以做任何CRUD。</li>
<li>配置文件所有以下划线 <code>_</code> 分割的数据源 <strong>首部</strong> 即为组的名称，相同组名称的数据源会放在一个组下。</li>
<li>切换数据源可以是组名，也可以是具体数据源名称。组名则切换时采用负载均衡算法切换。</li>
<li>默认的数据源名称为 <strong>master</strong> ，你可以通过 <code>spring.datasource.dynamic.primary</code> 修改。</li>
<li>方法上的注解优先于类上注解。</li>
<li>强烈建议只在service的类和方法上添加注解，不建议在mapper上添加注解。</li>
</ol>
<h3 id="使用方法">使用方法</h3>
<ol>
<li>引入dynamic-datasource-spring-boot-starter。</li>
</ol>
<pre><code class="language-xml">&lt;dependency&gt;
  &lt;groupId&gt;com.baomidou&lt;/groupId&gt;
  &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;${version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ol>
<li>配置数据源。</li>
</ol>
<pre><code class="language-yaml">spring:
  datasource:
    dynamic:
      primary: master #设置默认的数据源或者数据源组,默认值即为master
      strict: false #设置严格模式,默认false不启动. 启动后在未匹配到指定数据源时候会抛出异常,不启动则使用默认数据源.
      datasource:
        master:
          url: jdbc:mysql://xx.xx.xx.xx:3306/dynamic
          username: root
          password: 123456
          driver-class-name: com.mysql.jdbc.Driver # 3.2.0开始支持SPI可省略此配置
        slave_1:
          url: jdbc:mysql://xx.xx.xx.xx:3307/dynamic
          username: root
          password: 123456
          driver-class-name: com.mysql.jdbc.Driver
        slave_2:
          url: ENC(xxxxx) # 内置加密,使用请查看详细文档
          username: ENC(xxxxx)
          password: ENC(xxxxx)
          driver-class-name: com.mysql.jdbc.Driver
          schema: db/schema.sql # 配置则生效,自动初始化表结构
          data: db/data.sql # 配置则生效,自动初始化数据
          continue-on-error: true # 默认true,初始化失败是否继续
          separator: &quot;;&quot; # sql默认分号分隔符
          
       #......省略
       #以上会配置一个默认库master，一个组slave下有两个子库slave_1,slave_2
# 多主多从                      纯粹多库（记得设置primary）                   混合配置
spring:                               spring:                               spring:
  datasource:                           datasource:                           datasource:
    dynamic:                              dynamic:                              dynamic:
      datasource:                           datasource:                           datasource:
        master_1:                             mysql:                                master:
        master_2:                             oracle:                               slave_1:
        slave_1:                              sqlserver:                            slave_2:
        slave_2:                              postgresql:                           oracle_1:
        slave_3:                              h2:                                   oracle_2:
</code></pre>
<ol>
<li>使用 <strong>@DS</strong> 切换数据源。</li>
</ol>
<p><strong>@DS</strong> 可以注解在方法上和类上，<strong>同时存在方法注解优先于类上注解</strong>。</p>
<p>强烈建议只注解在service实现上。</p>
<table>
<thead>
<tr>
<th style="text-align:center">注解</th>
<th style="text-align:center">结果</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">没有@DS</td>
<td style="text-align:center">默认数据源</td>
</tr>
<tr>
<td style="text-align:center">@DS(&quot;dsName&quot;)</td>
<td style="text-align:center">dsName可以为组名也可以为具体某个库的名称</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">@Service
@DS(&quot;slave&quot;)
public class UserServiceImpl implements UserService {

  @Autowired
  private JdbcTemplate jdbcTemplate;

  public List selectAll() {
    return  jdbcTemplate.queryForList(&quot;select * from user&quot;);
  }
  
  @Override
  @DS(&quot;slave_1&quot;)
  public List selectByCondition() {
    return  jdbcTemplate.queryForList(&quot;select * from user where age &gt;10&quot;);
  }
}
</code></pre>
<hr>
<p><a href="https://baomidou.com/guide/dynamic-datasource.html#%E8%B5%B6%E7%B4%A7%E9%9B%86%E6%88%90%E4%BD%93%E9%AA%8C%E4%B8%80%E4%B8%8B%E5%90%A7%EF%BC%81-%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E6%9B%B4%E5%A4%9A%E5%8A%9F%E8%83%BD%E8%AF%B7%E7%82%B9%E5%87%BB%E4%B8%8B%E9%9D%A2%E9%93%BE%E6%8E%A5%E6%9F%A5%E7%9C%8B%E8%AF%A6%E7%BB%86%E6%96%87%E6%A1%A3%EF%BC%81">#</a>赶紧集成体验一下吧！ 如果需要更多功能请点击下面链接查看详细文档！</p>
<hr>
<p><a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter/wiki/FAQ">常见问题请点我</a> <a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter/wiki">分布式事务，加密,Druid集成，MybatisPlus集成，动态增减数据源，自定义切换规则,纯读写分离插件等等更多更细致的文档在这里</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot  集成 任务调度]]></title>
        <id>http://blog.ludangxin.club/post/springboot-ji-cheng-ren-wu-diao-du/</id>
        <link href="http://blog.ludangxin.club/post/springboot-ji-cheng-ren-wu-diao-du/">
        </link>
        <updated>2020-06-07T11:29:38.000Z</updated>
        <content type="html"><![CDATA[<h1 id="为什么要使用任务调度">为什么要使用任务调度</h1>
<p>定时任务的场景可以说非常广泛，比如某些视频网站，购买会员后，每天会给会员送成长值，每月会给会员送一些电影券；比如在保证最终一致性的场景中，往往利用定时任务调度进行一些比对工作；比如一些定时需要生成的报表、邮件；比如一些需要定时清理数据的任务等。</p>
<h1 id="scheduled">@Scheduled</h1>
<p><a href="https://spring.io/guides/gs/scheduling-tasks/">springboot scheduling 官方教程</a></p>
<h2 id="快速上手">快速上手</h2>
<p><strong>需求:</strong> 每个五秒打印一次日志</p>
<h2 id="引入所需依赖">引入所需依赖</h2>
<p><strong>因spring-boot-starter中默认引入了scheduler依赖,所以不用额外添加</strong></p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;!-- lombok 工具类 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="修改启动类">修改启动类</h2>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;
// 开启Scheduler
@EnableScheduling
@SpringBootApplication
public class SpringbootApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootApplication.class, args);
    }

}
</code></pre>
<h2 id="创建日志打印任务">创建日志打印任务</h2>
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import java.text.SimpleDateFormat;
import java.util.Date;

@Slf4j
@Component
public class PrintTask {

    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(&quot;HH:mm:ss&quot;);

    /**
     * 每隔5秒打印一次日志
     */
    @Scheduled(fixedRate = 5000)
    public void reportCurrentTime() {
        log.info(&quot;The time is now {}&quot;, DATE_FORMAT.format(new Date()));
    }

}
</code></pre>
<h2 id="输出结果">输出结果</h2>
<pre><code class="language-verilog">2020-06-04 21:33:06.130  INFO 1244 --- [   scheduling-1] com.ldx.springboot.scheduler.PrintTask   : The time is now 21:33:06
2020-06-04 21:33:11.131  INFO 1244 --- [   scheduling-1] com.ldx.springboot.scheduler.PrintTask   : The time is now 21:33:11
2020-06-04 21:33:16.133  INFO 1244 --- [   scheduling-1] com.ldx.springboot.scheduler.PrintTask   : The time is now 21:33:16
2020-06-04 21:33:21.135  INFO 1244 --- [   scheduling-1] com.ldx.springboot.scheduler.PrintTask   : The time is now 21:33:21
2020-06-04 21:33:26.137  INFO 1244 --- [   scheduling-1] com.ldx.springboot.scheduler.PrintTask   : The time is now 21:33:26
2020-06-04 21:33:31.139  INFO 1244 --- [   scheduling-1] com.ldx.springboot.scheduler.PrintTask   : The time is now 21:33:31
2020-06-04 21:33:36.140  INFO 1244 --- [   scheduling-1] com.ldx.springboot.scheduler.PrintTask   : The time is now 21:33:36
2020-06-04 21:33:41.142  INFO 1244 --- [   scheduling-1] com.ldx.springboot.scheduler.PrintTask   : The time is now 21:33:41
</code></pre>
<h2 id="配置taskscheduler线程池">配置TaskScheduler线程池</h2>
<p>在实际项目中，我们一个系统可能会定义多个定时任务。那么多个定时任务之间是可以相互独立且可以并行执行的。</p>
<p>通过查看org.springframework.scheduling.config.ScheduledTaskRegistrar源代码，发现spring默认会创建一个单线程池。这样对于我们的多任务调度可能会是致命的，当多个任务并发（或需要在同一时间）执行时，任务调度器就会出现时间漂移，任务执行时间将不确定。</p>
<h3 id="源码">源码</h3>
<pre><code class="language-java">protected void scheduleTasks() {
    if (this.taskScheduler == null) {
        this.localExecutor = Executors.newSingleThreadScheduledExecutor();
        this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor);
    }
    //省略...
}
</code></pre>
<h3 id="自定义线程池">自定义线程池</h3>
<pre><code class="language-java">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler;

@Configuration
public class ScheduleConfig {

    @Bean
    public TaskScheduler taskScheduler() {
        //org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler
        ThreadPoolTaskScheduler threadPoolTaskScheduler = new ThreadPoolTaskScheduler();
        threadPoolTaskScheduler.setPoolSize(20);
        return threadPoolTaskScheduler;
    }
}
</code></pre>
<h2 id="注解参数介绍">注解参数介绍</h2>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>fixedRate</td>
<td>该属性的含义是上一个调用开始后再次调用的延时（不用等待上一次调用完成），这样就会存在重复执行的问题，所以不是建议使用，但数据量如果不大时在配置的间隔时间内可以执行完也是可以使用的。</td>
</tr>
<tr>
<td>fixedDelay</td>
<td>该属性的功效与上面的fixedRate则是相反的，配置了该属性后会等到方法执行完成后延迟配置的时间再次执行该方法.</td>
</tr>
<tr>
<td>initialDelay</td>
<td>该属性跟上面的fixedDelay、fixedRate有着密切的关系，为什么这么说呢？该属性的作用是第一次执行延迟时间，只是做延迟的设定，并不会控制其他逻辑，所以要配合fixedDelay或者fixedRate来使用</td>
</tr>
<tr>
<td>cron</td>
<td>cron就不做赘述了。<a href="https://www.cnblogs.com/yanghj010/p/10875151.html">传送门</a></td>
</tr>
<tr>
<td>zone</td>
<td>指定解析cron表达式的时区</td>
</tr>
</tbody>
</table>
<h2 id="特点">特点</h2>
<p>优点: 足够简单 , 易上手</p>
<p>缺点:</p>
<ol>
<li>
<p>无法实现复杂的业务场景</p>
</li>
<li>
<p>如果服务器宕机 , 那么内存中的定时任务就会释放,无法支持<code>misfire</code></p>
</li>
<li>
<p>分布式部署会出现重复调用的问题等...</p>
</li>
</ol>
<h1 id="quartz">Quartz</h1>
<p>Quartz是纯Java实现，而且作为Spring的默认调度框架，由于Quartz的强大的调度功能、灵活的使用方式、还具有分布式集群能力，可以说Quartz出马，可以搞定一切定时任务调度！</p>
<figure data-type="image" tabindex="1"><img src="http://blog.ludangxin.club/post-images/1591529517702.jpg" alt="" loading="lazy"></figure>
<h2 id="quartz-中主要对象">Quartz  中主要对象</h2>
<ul>
<li>Scheduler：调度任务的主要API</li>
<li>ScheduleBuilder：用于构建Scheduler，例如其简单实现类SimpleScheduleBuilder</li>
<li>Job：调度任务执行的接口，也即定时任务执行的方法</li>
<li>JobDetail：定时任务作业的实例</li>
<li>JobBuilder：关联具体的Job，用于构建JobDetail</li>
<li>Trigger：定义调度执行计划的组件，即定时执行</li>
<li>TriggerBuilder：构建Trigger</li>
</ul>
<h2 id="快速上手-2">快速上手</h2>
<h3 id="添加所需依赖">添加所需依赖</h3>
<pre><code class="language-xml">	    &lt;!-- spring boot --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- quartz 任务调度 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- mysql依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- mybatis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- lombok 工具类 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="配置applicationyml">配置application.yml</h3>
<pre><code class="language-yaml">spring:
  datasource:
    type: com.zaxxer.hikari.HikariDataSource
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=true&amp;characterEncoding=utf-8
    username: root
    password: root
    hikari:
      minimum-idle: 5
      idle-timeout: 600000
      maximum-pool-size: 10
      auto-commit: true
      pool-name: MyHikariCP
      max-lifetime: 1800000
      connection-timeout: 30000
      connection-test-query: SELECT 1
  quartz:
    # 相关属性配置
    properties:
      org:
        quartz:
          scheduler:
            # 实例名称
            instanceName: TestScheduler
            # 实例id
            instanceId: AUTO
          jobStore:
            class: org.quartz.impl.jdbcjobstore.JobStoreTX
            driverDelegateClass: org.quartz.impl.jdbcjobstore.StdJDBCDelegate
            tablePrefix: QRTZ_
            useProperties: false
            # 开启集群
            isClustered: true
            clusterCheckinInterval: 15000
          threadPool:
            class: org.quartz.simpl.SimpleThreadPool
            threadCount: 20
            threadPriority: 8
            threadsInheritContextClassLoaderOfInitializingThread: true
    # 初始化后是否自动启动调度程序
    auto-startup: true
    # 数据库方式 memory 内存 ; jdbc 数据库
    job-store-type: jdbc
    # 初始化表结构
    jdbc:
      # 项目启动时初始化数据库  never 从不 ; always 每次启动都初始化
      initialize-schema: always
    # 是否覆盖已经持久化的job
    overwrite-existing-jobs: true
</code></pre>
<p><a href="https://github.com/quartz-scheduler/quartz/blob/master/docs/configuration.adoc">quartz官方配置文档</a></p>
<h3 id="创建job">创建Job</h3>
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.quartz.JobExecutionContext;
import org.quartz.JobExecutionException;
import org.springframework.scheduling.quartz.QuartzJobBean;
import java.text.SimpleDateFormat;
import java.util.Date;

@Slf4j
public class LogJob extends QuartzJobBean {

    private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat(&quot;HH:mm:ss&quot;);

    @Override
    protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException {
        log.info(&quot;The time is now {}&quot;, DATE_FORMAT.format(new Date()));
    }
}
</code></pre>
<h3 id="注册job信息">注册Job信息</h3>
<pre><code class="language-java">import org.quartz.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class QuartzConfig {

    @Bean
    public JobDetail logJobDetail(){
        return JobBuilder.newJob(LogJob.class).storeDurably().build();
    }

    @Bean
    public Trigger logTrigger(){
        SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()
                //每一秒执行一次
                .withIntervalInSeconds(1)
                //永久重复，一直执行下去
                .repeatForever();
        return TriggerBuilder.newTrigger()
                .forJob(logJobDetail())
                .withSchedule(scheduleBuilder)
                .build();
    }

}
</code></pre>
<h3 id="启动项目测试">启动项目,测试</h3>
<pre><code class="language-verilog">2020-06-06 17:04:50.904  INFO 9920 --- [eduler_Worker-1] com.ldx.springboot.quartz.LogJob         : The time is now 17:04:50
2020-06-06 17:04:50.914  INFO 9920 --- [eduler_Worker-2] com.ldx.springboot.quartz.LogJob         : The time is now 17:04:50
2020-06-06 17:04:51.791  INFO 9920 --- [eduler_Worker-3] com.ldx.springboot.quartz.LogJob         : The time is now 17:04:51
2020-06-06 17:04:52.791  INFO 9920 --- [eduler_Worker-4] com.ldx.springboot.quartz.LogJob         : The time is now 17:04:52
2020-06-06 17:04:53.792  INFO 9920 --- [eduler_Worker-5] com.ldx.springboot.quartz.LogJob         : The time is now 17:04:53
2020-06-06 17:04:54.791  INFO 9920 --- [eduler_Worker-6] com.ldx.springboot.quartz.LogJob         : The time is now 17:04:54
2020-06-06 17:04:55.791  INFO 9920 --- [eduler_Worker-7] com.ldx.springboot.quartz.LogJob         : The time is now 17:04:55
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[OAuth2.0]]></title>
        <id>http://blog.ludangxin.club/post/oauth20/</id>
        <link href="http://blog.ludangxin.club/post/oauth20/">
        </link>
        <updated>2020-06-03T15:16:03.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>OAUTH协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是OAUTH的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此OAUTH是安全的。oAuth是Open Authorization的简写。</p>
<p>OAuth2.0是OAuth协议的延续版本，但不向前兼容OAuth 1.0(即完全废止了OAuth1.0)。 OAuth 2.0关注客户端开发者的简易性。要么通过组织在资源拥有者和HTTP服务商之间的被批准的交互动作代表用户，要么允许第三方应用代表用户获得访问的权限。同时为Web应用，桌面应用和手机，和起居室设备提供专门的认证流程。<br>
<a href="https://tools.ietf.org/html/rfc6749">RFC文档</a></p>
<h2 id="认证过程">认证过程</h2>
<pre><code class="language-java">     +--------+                               +---------------+
     |        |--(A)- Authorization Request -&gt;|   Resource    |
     |        |                               |     Owner     |
     |        |&lt;-(B)-- Authorization Grant ---|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant --&gt;| Authorization |
     | Client |                               |     Server    |
     |        |&lt;-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------&gt;|    Resource   |
     |        |                               |     Server    |
     |        |&lt;-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
</code></pre>
<p>上图中所涉及到的对象分别为：</p>
<ul>
<li>Client 第三方应用，我们的应用就是一个Client</li>
<li>Resource Owner 资源所有者，即用户</li>
<li>Authorization Server 授权服务器，即提供第三方登录服务的服务器，如Github</li>
<li>Resource Server 拥有资源信息的服务器，通常和授权服务器属于同一应用</li>
</ul>
<p>根据上图的信息，我们可以知道OAuth2的基本流程为：</p>
<ol>
<li>第三方应用请求用户授权。</li>
<li>用户同意授权，并返回一个凭证（code）</li>
<li>第三方应用通过第二步的凭证（code）向授权服务器请求授权</li>
<li>授权服务器验证凭证（code）通过后，同意授权，并返回一个资源访问的凭证（Access Token）。</li>
<li>第三方应用通过第四步的凭证（Access Token）向资源服务器请求相关资源。</li>
<li>资源服务器验证凭证（Access Token）通过后，将第三方应用请求的资源返回。</li>
</ol>
<h2 id="oauth20的具体实现">OAuth2.0的具体实现</h2>
<p>看完OAuth的基本流程后，大家实际上对到底如何做OAuth验证还是不太清楚，同时，也会产生疑问，为什么需要两次获取凭证，而不是直接用户授权拿到凭证后就直接获取资源呢？这和OAuth的具体实现有关，让我们来看看OAuth2的具体实现吧。</p>
<h3 id="用户授权">用户授权</h3>
<p>在用户授权这一步中，我们将得到一个用户凭证（code），我们的应用可以通过该用户凭证（code）来和授权服务器交换一个资源访问凭证（Access Token）。</p>
<p>这里我们只讨论第三方登录功能的实现情况，经过分析，我们可以得出用户凭证（code）具有三个特性：</p>
<ul>
<li>用户凭证（code）需要由用户授权，也就是说该行为是用户的主动行为， 此时为了保证用户身份正确，实际上也需要用户通过授权服务器的验证（登录操作或者已登录状态）</li>
<li>用户凭证（code）需要授权服务器颁发，因为最终用户凭证（code）是由授权服务器验证的，同时用户授权操作为了保证用户身份，也需要在授权服务器上进行操作，因此，用户凭证（code）是由授权服务器进行颁发的</li>
<li>用户凭证（code）需要由授权服务器传递给我们的第三方应用，很明显，由用户在资源服务器上拿到凭证再手动的提交至第三方应用太麻烦，因此，当用户主动授权行为发生后，资源服务器需要将用户凭证（code）发送给第三方应用。</li>
</ul>
<p>我们以Github为例，看看主流的第三方登录是如何满足上述三个特性的。</p>
<p>第0步. 引导用户进行授权：github</p>
<p>当用户希望使用第三方登录进行登录时，第三方应用会通过类似下图&quot;快速登陆图标&quot;的方式将用户引导至授权页面，为了和OAuth基本流程一致，我们将这一步定义为第0步。</p>
<figure data-type="image" tabindex="1"><img src="http://blog.ludangxin.club/post-images/1591192836.jpg" alt="" loading="lazy"></figure>
<p>第0.5步. 用户身份验证</p>
<p>当我们点击Github的图标，我们会进入到Github应用下面，此时实际上进行了一次用户身份的验证，之前没有登录Github的用户需要输入Github的账号密码，已登录的用户Github会根据Session进行身份确认。此操作我们称为0.5步。接下来正式进入OAuth2的流程</p>
<figure data-type="image" tabindex="2"><img src="http://blog.ludangxin.club/post-images/1591193144.jpg" alt="" loading="lazy"></figure>
<p>第1步. 用户授权</p>
<p>用户身份确认后会进入下面这个页面，该页面由授权服务器提供，授权服务器会告诉用户该第三方在授权服务器中提交的相关信息（如果需要实现第三方登录功能，第三方应用需要向Github、微博等应用中提交应用的相关信息，不同服务可能会需要审核等不同的步骤），以及授权后第三方应用能够获取哪些资源。在Github中，最基础的认证可以访问用户的公共信息。如果用户同意授权，需要主动的点击【Authorize application】按钮。</p>
<figure data-type="image" tabindex="3"><img src="http://blog.ludangxin.club/post-images/1591193436.jpg" alt="" loading="lazy"></figure>
<p>第2步. 返回用户凭证（code）</p>
<p>当用户点击按钮同意授权后，授权服务器将生成一个用户凭证（code），此时授权服务器如何将用户凭证（code）传递给第三方应用呢？</p>
<p>当我们向授权服务器提交应用信息时，通常需要填写一个redirect_uri，当我们引导用户进入授权页面时，也会附带一个redirect_uri的信息，当授权服务器验证两个URL一致时，会通知浏览器跳转到redirect_uri，同时，在redirect_uri后附加用户凭证（code）的相关信息，此时，浏览器返回第三方应用同时携带用户凭证（code）的相关信息。授权后访问的redirect_uri如下：</p>
<pre><code class="language-wiki">https://www.csdn.net/oauth/github/callback?code=9e3efa6cea739f9aaab2&amp;state=XXX
</code></pre>
<p>这样，第二步返回用户凭证（code）就完成了。</p>
<h3 id="授权服务器授权">授权服务器授权</h3>
<p>从这一步开始，OAuth2 的授权将有两个重大变化的发生：</p>
<ul>
<li>用户主动行为结束，用户理论上可以不需要再做任何主动的操作，作为第三方应用的我们可以在后台拿到资源服务器上的资源而对用户是不可见的，当用户的浏览器跳到下一个页面时，整个OAuth2的流程已经结束</li>
<li>浏览器端行为结束，从OAuth2 的基本流程可以看出，接下来的流程已经不需要和用户进行交互，接下来的行为都在第三方应用与授权服务器、资源服务器之间的交互。</li>
</ul>
<p>我们知道浏览器端的行为实际上是不安全的，甚至安全凭证的传递都是通过URL直接传递的。但是由于用户凭证（code）不是那么敏感，其他攻击者拿到用户凭证（code）后依然无法获取到相应的用户资源，所以之前的行为是允许的。接下来我们看看服务器如何交互来安全的获得授权服务器授权。</p>
<p>第3步. 请求授权服务器授权</p>
<p>要拿到授权服务器的授权，需要以下几个信息：</p>
<ul>
<li>client_id 标识第三方应用的id，由授权服务器（Github）在第三方应用提交时颁发给第三方应用</li>
<li>client_secret 第三方应用和授权服务器之间的安全凭证，由授权服务器（Github）在第三方应用提交时颁发给第三方应用</li>
<li>code 第一步中返回的用户凭证redirect_uri 第一步生成用户凭证后跳转到第二步时的地址</li>
<li>state 由第三方应用给出的随机码</li>
</ul>
<p>我们看到，上述信息还涉及到第三方应用的安全凭证（client_secret），因此要求OAuth要求该请求必须时POST请求，同时，还必须时HTTPS服务，以此保证获取到的验证凭证（Access Token）的安全性。</p>
<p>第4步. 拿到验证凭证（Access Token）</p>
<p>当授权服务器拿到第3步中的所有信息，验证通过后，会将Access Token返回给第三方应用。</p>
<h3 id="访问资源">访问资源</h3>
<p>第5步. 请求访问用户资源</p>
<p>拿到验证凭证（Access Token）后，剩下的事情就很简单了，资源服务器会提供一系列关于用户资源的API，拿验证凭证（Access Token）访问相应的API即可，例如，在GIthub中，如果你想拿到用户信息，可以访问以下API：</p>
<pre><code class="language-text">GET https://api.github.com/user?access_token=...
</code></pre>
<p>注意，此时的访问不是通过浏览器进行的，而是服务器直接发送HTTP请求，因此其安全性是可以保证的。</p>
<p>第6步. 返回资源</p>
<p>如果验证凭证（Access Token）是正确的，此时资源服务器就会返回资源信息，此时整个OAuth流程就结束了。</p>
<h2 id="第三方登录">第三方登录</h2>
<p>看完OAuth2的资源访问流程，我们的第三方登录是如何做的呢？首先我们需要知道两点：</p>
<ul>
<li>用户授权信息在授权服务器中是有记录的，当用户第一次授权给相应的第三方应用后，不需要进行再次授权</li>
<li>每个用户在资源服务器中都有一个唯一的ID，第三方应用可以将其存储起来并与本地用户系统一一对应起来<br>
这样，当用户第一次授权并且注册后（主动注册或者第三方应用使用用户信息默认注册），当再次点击第三方登录的按钮，浏览器跳转到授权服务器，授权服务器通过Session找到用户的授权信息，发现该用户已经授权给该第三方应用，将直接跳转到redirect_uri，此时第三方应用通过唯一的用户ID找到相应的本地用户，自动帮助其登录。<br>
这样，就可以达到直接点击第三方登录按钮，不需要任何操作，经过几次跳转后自动登录的效果了。大家快去试试吧。</li>
</ul>
<h2 id="客户端授权模式">客户端授权模式</h2>
<p>客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。oAuth 2.0 定义了四种授权方式。</p>
<ul>
<li>implicit：简化模式</li>
<li>authorization code：授权码模式</li>
<li>resource owner password credentials：密码模式</li>
<li>client credentials：客户端模式</li>
</ul>
<h3 id="授权码模式">授权码模式</h3>
<figure data-type="image" tabindex="4"><img src="http://blog.ludangxin.club/post-images/1591195997.jpg" alt="" loading="lazy"></figure>
<ol>
<li>资源拥有者打开客户端，客户端要求资源拥有者给予授权，它将浏览器被重定向到授权服务器，重定向时会 附加客户端的身份信息。如：<pre><code class="language-wiki">/uaa/oauth/authorize?
client_id=c1&amp;response_type=code&amp;scope=all&amp;redirect_uri=http://www.baidu.com
</code></pre>
​	参数列表如下：<br>
​	client_id：客户端准入标识。<br>
​	response_type：授权码模式固定为code。<br>
​	scope：客户端权限。<br>
​	redirect_uri：跳转uri，当授权码申请成功后会跳转到此地址，并在后边带上code参数（授权码）。</li>
<li>浏览器出现向授权服务器授权页面，之后将用户同意授权。</li>
<li>授权服务器将授权码（<strong>AuthorizationCode</strong>）转经浏览器发送给<strong>client</strong>(通过redirect_uri)。</li>
<li>客户端拿着授权码向授权服务器索要访问<strong>access_token</strong>，请求如下：<pre><code class="language-wiki">/uaa/oauth/token? 
client_id=c1&amp;client_secret=secret&amp;grant_type=authorization_code&amp;code=5PgfcD&amp;redirect_uri=http://w ww.baidu.com
</code></pre>
​	参数列表如下<br>
​	client_id：客户端准入标识。<br>
​	client_secret：客户端秘钥。<br>
​	grant_type：授权类型，填写authorization_code，表示授权码模式<br>
​	code：授权码，就是刚刚获取的授权码，注意：授权码只使用一次就无效了，需要重新申请。<br>
​	redirect_uri：申请授权码时的跳转url，一定和申请授权码时用的redirect_uri一致。</li>
<li>授权服务器返回令牌**(access_token)**</li>
</ol>
<p><strong>这种模式是四种模式中最安全的一种模式。一般用于client是Web服务器端应用或第三方的原生App调用资源服务的时候。因为在这种模式中access_token不会经过浏览器或移动端的App，而是直接从服务端去交换，这样就最大限度的减小了令牌泄漏的风险。</strong></p>
<h3 id="简化模式">简化模式</h3>
<figure data-type="image" tabindex="5"><img src="http://blog.ludangxin.club/post-images/1591196409.jpg" alt="" loading="lazy"></figure>
<ol>
<li>资源拥有者打开客户端，客户端要求资源拥有者给予授权，它将浏览器被重定向到授权服务器，重定向时会附加客户端的身份信息。如：<pre><code class="language-wiki">/uaa/oauth/authorize?
client_id=c1&amp;response_type=token&amp;scope=all&amp;redirect_uri=http://www.baidu.com 
</code></pre>
参数描述同<strong>授权码模式</strong> ，注意response_type=token，说明是简化模式。</li>
<li>浏览器出现向授权服务器授权页面，之后将用户同意授权。</li>
<li>授权服务器将授权码将令牌（<strong>access_token</strong>）以<strong>Hash</strong>的形式存放在重定向<strong>uri</strong>的<strong>fargment</strong>中发送给<strong>浏览器。</strong><br>
注：fragment 主要是用来标识 URI 所标识资源里的某个资源，在 URI 的末尾通过 （#）作为 fragment 的开头，其中 # 不属于 fragment 的值。如https://domain/index#L18这个 URI 中 L18 就是 fragment 的值。大家只需要知道js通过响应浏览器地址栏变化的方式能获取到fragment 就行了。</li>
</ol>
<p><strong>一般来说，简化模式用于没有服务器端的第三方单页面应用，因为没有服务器端就无法接收授权码。</strong></p>
<h3 id="密码模式">密码模式</h3>
<figure data-type="image" tabindex="6"><img src="http://blog.ludangxin.club/post-images/1591196923.jpg" alt="" loading="lazy"></figure>
<ol>
<li>
<p>资源拥有者将用户名、密码发送给客户端</p>
</li>
<li>
<p>客户端拿着资源拥有者的用户名、密码向授权服务器请求令牌（<strong>access_token</strong>），请求如下：</p>
<pre><code class="language-wiki">/uaa/oauth/token? 
client_id=c1&amp;client_secret=secret&amp;grant_type=password&amp;username=shangsan&amp;password=123 
</code></pre>
<p>​	参数列表如下：<br>
​	client_id：客户端准入标识。<br>
​	client_secret：客户端秘钥。<br>
​	grant_type：授权类型，填写password表示密码模式<br>
​	username：资源拥有者用户名。<br>
​	password：资源拥有者密码。</p>
</li>
<li>
<p>授权服务器将令牌（<strong>access_token</strong>）发送给<strong>client</strong></p>
</li>
</ol>
<p><strong>这种模式十分简单，但是却意味着直接将用户敏感信息泄漏给了client，因此这就说明这种模式只能用于client是我们自己开发的情况下。因此密码模式一般用于我们自己开发的，第一方原生App或第一方单页面应用。</strong></p>
<h3 id="客户端模式">客户端模式</h3>
<figure data-type="image" tabindex="7"><img src="http://blog.ludangxin.club/post-images/1591197128.jpg" alt="" loading="lazy"></figure>
<ol>
<li>客户端向授权服务器发送自己的身份信息，并请求令牌（<strong>access_token</strong>）</li>
<li>确认客户端身份无误后，将令牌（<strong>access_token</strong>）发送给<strong>client</strong>，请求如下：<pre><code class="language-wiki">/uaa/oauth/token?client_id=c1&amp;client_secret=secret&amp;grant_type=client_credentials 
</code></pre>
​	参数列表如下：<br>
​	client_id：客户端准入标识。<br>
​	client_secret：客户端秘钥。<br>
​	grant_type：授权类型，填写client_credentials表示客户端模式</li>
</ol>
<p><strong>这种模式是最方便但最不安全的模式。因此这就要求我们对client完全的信任，而client本身也是安全的。因此这种模式一般用来提供给我们完全信任的服务器端服务。比如，合作方系统对接，拉取一组用户信息。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Spring Security 详解 及 快速上手]]></title>
        <id>http://blog.ludangxin.club/post/spring-security-xiang-jie-ji-kuai-su-shang-shou/</id>
        <link href="http://blog.ludangxin.club/post/spring-security-xiang-jie-ji-kuai-su-shang-shou/">
        </link>
        <updated>2020-06-02T15:13:26.000Z</updated>
        <content type="html"><![CDATA[<h1 id="什么是认证">什么是认证</h1>
<p>用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信 息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式。<br>
<strong>系统为什么要认证？</strong><br>
认证是为了保护系统的隐私数据与资源，用户的身份合法方可访问该系统的资源。</p>
<h1 id="什么是会话">什么是会话</h1>
<p>用户认证通过后，为了避免用户的每次操作都进行认证可将用户的信息保证在会话中。会话就是系统为了保持当前 用户的登录状态所提供的机制，常见的有基于session方式、基于token方式等。</p>
<h2 id="session-会话">session 会话</h2>
<p>用户认证成功后，在服务端生成用户相关的数据保存在session(当前会话)中，发给客户端的 sesssion_id 存放到 cookie 中，这样用户客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数 据，以此完成用户的合法校验，当用户退出系统或session过期销毁时,客户端的session_id也就无效了。<br>
<img src="http://blog.ludangxin.club/post-images/1591110991875.jpg" alt="" loading="lazy"></p>
<h2 id="token-会话">token 会话</h2>
<p>用户认证成功后，服务端生成一个token发给客户端，客户端可以放到 cookie 或 localStorage等存储中，每次请求时带上 token，服务端收到token通过验证后即可确认用户身份。<br>
<img src="http://blog.ludangxin.club/post-images/1591111017782.jpg" alt="" loading="lazy"><br>
基于session的认证方式由Servlet规范定制，服务端要存储session信息需要占用内存资源，客户端需要支持 cookie；基于token的方式则一般不需要服务端存储token，并且不限制客户端的存储方式。如今移动互联网时代 更多类型的客户端需要接入系统，系统多是采用前后端分离的架构进行实现，所以基于token的方式更适合。</p>
<h1 id="什么是授权">什么是授权</h1>
<p>授权是用户认证通过根据用户的权限来控制用户访问资源的过程，拥有资源的访问权限则正常访问，没有权限则拒绝访问。<br>
<strong>为什么要授权？</strong><br>
认证是为了保证用户身份的合法性，授权则是为了更细粒度的对隐私数据进行划分，授权是在认证通过后发生的，控制不同的用户能够访问不同的资源。</p>
<h1 id="springsecurity">SpringSecurity</h1>
<p>Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。由于它是Spring生态系统中的一员，因此它伴随着整个Spring生态系统不断修正、升级，在spring boot项目中加入spring security更是十分简单，使用Spring Security 减少了为企业系统安全控制编写大量重复代码的工作。</p>
<h2 id="快速上手">快速上手</h2>
<h3 id="引入所需依赖">引入所需依赖</h3>
<pre><code class="language-xml">        &lt;!-- spring security 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- web支持 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="添加spring-security-配置类">添加spring security 配置类</h3>
<pre><code class="language-java">package com.ldx.springboot.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.NoOpPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

/**
 * springsecurity 配置类
 * @author ludangxin
 * @Date 2020-06-01
 **/
@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    /**
     * 定义用户信息服务（查询用户信息）
     */
    @Bean
    @Override
    public UserDetailsService userDetailsService(){
        //基于内存的userDetail
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        //用户zhangsan 拥有访问p1资源权限
        manager.createUser(User.withUsername(&quot;zhangsan&quot;).password(&quot;123&quot;).authorities(&quot;p1&quot;).build());
        //用户lisi 拥有访问p2资源权限
        manager.createUser(User.withUsername(&quot;lisi&quot;).password(&quot;456&quot;).authorities(&quot;p2&quot;).build());
        return manager;
    }

    /**
     * 密码编码器
     */
    @Bean
    public PasswordEncoder passwordEncoder(){
        //无加密机制
        return NoOpPasswordEncoder.getInstance();
    }

    /**
     * 安全拦截机制（最重要）
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers(&quot;/r/r1&quot;).hasAuthority(&quot;p1&quot;)
                .antMatchers(&quot;/r/r2&quot;).hasAuthority(&quot;p2&quot;)
                //所有的请求必须通过认证
                .anyRequest().authenticated()
                .and()
                //允许表单登录
                .formLogin()
                //自定义登录成功的页面地址
                .successForwardUrl(&quot;/login-success&quot;);
    }
}

</code></pre>
<h3 id="编写测试接口">编写测试接口</h3>
<pre><code class="language-java">import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {

    @RequestMapping(value = &quot;/login-success&quot;)
    public String loginSuccess(){
        return &quot; 登录成功&quot;;
    }

    /**
     * 测试资源1
     * @return
     */
    @GetMapping(value = &quot;/r/r1&quot;)
    public String r1(){
        return &quot; 访问资源1&quot;;
    }

    /**
     * 测试资源2
     * @return
     */
    @GetMapping(value = &quot;/r/r2&quot;)
    public String r2(){
        return &quot; 访问资源2&quot;;
    }
}
</code></pre>
<h3 id="测试">测试</h3>
<ol>
<li>测试登陆功能,访问 <code>localhost:8080</code><br>
<img src="http://blog.ludangxin.club/post-images/1591111117908.jpg" alt="" loading="lazy"></li>
<li>输入 账号:<code>zhangsan</code> 密码: <code>123</code>登陆成功<br>
<img src="http://blog.ludangxin.club/post-images/1591111121642.jpg" alt="" loading="lazy"></li>
<li>访问 <code>/r/r1</code>资源<br>
<img src="http://blog.ludangxin.club/post-images/1591111124609.jpg" alt="" loading="lazy"></li>
<li>访问<code>r/r2</code>资源, 403无权限<br>
<img src="http://blog.ludangxin.club/post-images/1591111127688.jpg" alt="" loading="lazy"></li>
</ol>
<h3 id="小结">小结</h3>
<p>通过快速上手，咱们使用Spring Security实现了认证和授权，Spring Security提供了基于账号和密码的认证方式，通过安全配置即可实现请求拦截，授权功能，Spring Security能完成的不仅仅是这些。</p>
<h2 id="工作原理">工作原理</h2>
<h3 id="结构总览">结构总览</h3>
<p>Spring Security所解决的问题就是<strong>安全访问控制</strong>，而安全访问控制功能其实就是对所有进入系统的请求进行拦截，校验每个请求是否能够访问它所期望的资源。<br>
当初始化Spring Security时，会创建一个名为 SpringSecurityFilterChain 的Servlet过滤器，类型为 org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求会经过此类，下图是Spring Security过虑器链结构图：<br>
<img src="http://blog.ludangxin.club/post-images/1591111142292.jpg" alt="" loading="lazy"><br>
FilterChainProxy是一个代理，真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter，同时这些Filter作为Bean被Spring管理，它们是Spring Security核心，各有各的职责，但他们并不直接处理用户的<strong>认证</strong>，也不直接处理用户的<strong>授权</strong>，而是把它们交给了认证管理（AuthenticationManager）和决策管理器（AccessDecisionManager）进行处理.<br>
下面介绍过滤器链中主要的几个过滤器及其作用：<br>
<img src="http://blog.ludangxin.club/post-images/1591111150999.jpg" alt="" loading="lazy"><br>
<strong>SecurityContextPersistenceFilter :</strong><br>
这个Filter是整个拦截过程的入口和出口（也就是第一个和最后一个拦截器），会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext，然后把它设置给SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository，同时清除 securityContextHolder 所持有的SecurityContext；<br>
<strong>UsernamePasswordAuthenticationFilter :</strong><br>
用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码，其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，这些都可以根据需求做相关改变；<br>
<strong>FilterSecurityInterceptor :</strong><br>
是用于保护web资源的，使用AccessDecisionManager对当前用户进行授权访问；<br>
<strong>ExceptionTranslationFilter :</strong><br>
能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常：AuthenticationException 和 AccessDeniedException，其它的异常它会继续抛出。</p>
<h3 id="认证">认证</h3>
<h4 id="流程">流程</h4>
<figure data-type="image" tabindex="1"><img src="http://blog.ludangxin.club/post-images/1591111163947.jpg" alt="" loading="lazy"></figure>
<ol>
<li>用户提交用户名、密码被SecurityFilterChain中的 UsernamePasswordAuthenticationFilter 过滤器获取到，封装为请求Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。</li>
<li>然后过滤器将Authentication提交至认证管理器（AuthenticationManager）进行认证</li>
<li>认证成功后， AuthenticationManager 身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除） Authentication 实例。</li>
<li>SecurityContextHolder 安全上下文容器将第3步填充了信息的 Authentication ，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。可以看出AuthenticationManager接口（认证管理器）是认证相关的核心接口，也是发起认证的出发点，它 的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护着一个 List<AuthenticationProvider> 列表，存放多种认证方式，最终实际的认证工作是由 AuthenticationProvider完成的。咱们知道web表单的对应的AuthenticationProvider实现类为 DaoAuthenticationProvider，它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终AuthenticationProvider将UserDetails填充至Authentication。</li>
</ol>
<h4 id="authenticationprovider">AuthenticationProvider</h4>
<p>通过前面的<strong>Spring Security认证流程</strong>我们得知，认证管理器（AuthenticationManager）委托AuthenticationProvider完成认证工作。<br>
AuthenticationProvider是一个接口，定义如下：</p>
<pre><code class="language-java">public interface AuthenticationProvider { 
    Authentication authenticate(Authentication authentication) throws AuthenticationException; 
    boolean supports(Class&lt;?&gt; var1); 
}
</code></pre>
<p><strong>authenticate</strong>()方法定义了<strong>认证的实现过程</strong>，它的参数是一个Authentication，里面包含了登录用户所提交的用户、密码等。而返回值也是一个Authentication，这个Authentication则是在认证成功后，将用户的权限及其他信息重新组装后生成。<br>
Spring Security中维护着一个 List<AuthenticationProvider> 列表，存放多种认证方式，不同的认证方式使用不同的AuthenticationProvider。如使用用户名密码登录时，使用AuthenticationProvider1，短信登录时使用AuthenticationProvider2等等这样的例子很多。<br>
每个AuthenticationProvider需要实现<strong>supports()<strong>方法来表明自己支持的认证方式，如我们使用表单方式认证，在提交请求时Spring Security会生成UsernamePasswordAuthenticationToken，它是一个Authentication，里面封装着用户提交的用户名、密码信息。而对应的，哪个AuthenticationProvider来处理它？<br>
我们在</strong>DaoAuthenticationProvider</strong>的基类AbstractUserDetailsAuthenticationProvider发现以下代码：</p>
<pre><code class="language-java">public boolean supports(Class&lt;?&gt; authentication) { 
    return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);
}
</code></pre>
<p><strong>也就是说当web表单提交用户名密码时，Spring Security由DaoAuthenticationProvider处理。</strong><br>
最后，我们来看一下<strong>Authentication</strong>(认证信息)的结构，它是一个接口，我们之前提到的<br>
UsernamePasswordAuthenticationToken就是它的实现之一：</p>
<pre><code class="language-java">public interface Authentication extends Principal, Serializable { 
    Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); 
    Object getCredentials(); 
    Object getDetails(); 
    Object getPrincipal();
    boolean isAuthenticated(); 
    void setAuthenticated(boolean var1) throws IllegalArgumentException; 
}
</code></pre>
<ol>
<li>Authentication是spring security包中的接口，直接继承自Principal类，而Principal是位于 java.security包中的。它是表示着一个抽象主体身份，任何主体都有一个名称，因此包含一个getName()方法。</li>
<li>getAuthorities()，权限信息列表，默认是GrantedAuthority接口的一些实现类，通常是代表权限信息的一系列字符串。</li>
<li>getCredentials()，凭证信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。</li>
<li>getDetails()，细节信息，web应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的ip地址和sessionId的值。</li>
<li><strong>getPrincipal()</strong>，身份信息，大部分情况下返回的是UserDetails接口的实现类，UserDetails代表用户的详细信息，那从Authentication中取出来的UserDetails就是当前登录用户信息，它也是框架中的常用接口之一。</li>
</ol>
<h4 id="userdetailsservice">UserDetailsService</h4>
<ol>
<li>认识UserDetailsService<br>
现在咱们现在知道DaoAuthenticationProvider处理了web表单的认证逻辑，认证成功后既得到一个 Authentication(UsernamePasswordAuthenticationToken实现)，里面包含了身份信息（Principal）。这个身份信息就是一个 Object ，大多数情况下它可以被强转为UserDetails对象。 DaoAuthenticationProvider中包含了一个UserDetailsService实例，它负责根据用户名提取用户信息UserDetails(包含密码)，而后DaoAuthenticationProvider会去对比UserDetailsService提取的用户密码与用户提交的密码是否匹配作为认证成功的关键依据，因此可以通过将自定义的 UserDetailsService 公开为spring bean来定义自定义身份验证。</li>
</ol>
<pre><code class="language-java">public interface UserDetailsService { 
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; 
}
</code></pre>
<p>很多人把DaoAuthenticationProvider和UserDetailsService的职责搞混淆，其实UserDetailsService只负责从特定的地方（通常是数据库）加载用户信息，仅此而已。而DaoAuthenticationProvider的职责更大，它完成完整的认证流程，同时会把UserDetails填充至Authentication。上面一直提到UserDetails是用户信息，咱们看一下它的真面目：</p>
<pre><code class="language-java">public interface UserDetails extends Serializable { 
    Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); 
    String getPassword(); 
    String getUsername();
    boolean isAccountNonExpired(); 
    boolean isAccountNonLocked(); 
    boolean isCredentialsNonExpired();
    boolean isEnabled(); 
}
</code></pre>
<p>它和Authentication接口很类似，比如它们都拥有username，authorities。Authentication的getCredentials()与UserDetails中的getPassword()需要被区分对待，前者是用户提交的密码凭证，后者是用户实际存储的密码，认证其实就是对这两者的比对。Authentication中的getAuthorities()实际是由UserDetails的getAuthorities()传递而形成的。还记得Authentication接口中的getDetails()方法吗？其中的UserDetails用户详细信息便是经过了AuthenticationProvider认证之后被填充的。 通过实现UserDetailsService和UserDetails，我们可以完成对用户信息获取方式以及用户信息字段的扩展。<br>
Spring Security提供的InMemoryUserDetailsManager(内存认证)，JdbcUserDetailsManager(jdbc认证)就是UserDetailsService的实现类，主要区别无非就是从内存还是从数据库加载用户。<br>
2. 自定义UserDetailsService</p>
<pre><code class="language-java">@Service 
public class SpringDataUserDetailsService implements UserDetailsService { 
    @Override 
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { 
        //登录账号 
        System.out.println(&quot;username=&quot;+username); 
        //根据账号去数据库查询... 
        //这里暂时使用静态数据 
        UserDetails userDetails = User.withUsername(username).password(&quot;123&quot;).authorities(&quot;p1&quot;).build(); return userDetails; 
    } 
}
</code></pre>
<h4 id="passwordencoder">PasswordEncoder</h4>
<ol>
<li>认识PasswordEncoder<br>
DaoAuthenticationProvider认证处理器通过UserDetailsService获取到UserDetails后，它是如何与请求Authentication中的密码做对比呢？<br>
在这里Spring Security为了适应多种多样的加密类型，又做了抽象，DaoAuthenticationProvider通过PasswordEncoder接口的matches方法进行密码的对比，而具体的密码对比细节取决于实现：</li>
</ol>
<pre><code class="language-java">public interface PasswordEncoder { 
    String encode(CharSequence var1);
    boolean matches(CharSequence var1, String var2); 
    default boolean upgradeEncoding(String encodedPassword) { 
        return false; 
    } 
}
</code></pre>
<p>而Spring Security提供很多内置的PasswordEncoder，能够开箱即用，使用某种PasswordEncoder只需要进行如下声明即可，如下：</p>
<pre><code class="language-java">@Bean 
public PasswordEncoder passwordEncoder() { 
    //NoOpPasswordEncoder采用字符串匹配方法，不对密码进行加密比较处理
    return NoOpPasswordEncoder.getInstance(); 
}
</code></pre>
<ol start="2">
<li>密码比较流程如下
<ol>
<li>用户输入密码（明文 ）</li>
<li>DaoAuthenticationProvider获取UserDetails（其中存储了用户的正确密码）</li>
<li>DaoAuthenticationProvider使用PasswordEncoder对输入的密码和正确的密码进行校验，密码一致则校验通过，否则校验失败。<br>
NoOpPasswordEncoder的校验规则拿 输入的密码和UserDetails中的正确密码进行字符串比较，字符串内容一致则校验通过，否则 校验失败。<br>
实际项目中推荐使用BCryptPasswordEncoder, Pbkdf2PasswordEncoder, SCryptPasswordEncoder等，感兴趣的大家可以看看这些PasswordEncoder的具体实现。</li>
</ol>
</li>
<li>使用BCryptPasswordEncoder
<ol>
<li>配置BCryptPasswordEncoder<br>
在安全配置类中定义：</li>
</ol>
</li>
</ol>
<pre><code class="language-java">@Bean 
public PasswordEncoder passwordEncoder() { 
    return new BCryptPasswordEncoder(); 
}
</code></pre>
<p>测试发现认证失败，提示：<code>Encoded password does not look like BCrypt</code>。<br>
原因：<br>
由于UserDetails中存储的是原始密码（比如：123），它不是BCrypt格式。跟踪 DaoAuthenticationProvider第33行代码查看 userDetails中的内容 ，跟踪第38行代码查看PasswordEncoder的类型。<br>
​	2. 测试BCrypt<br>
通过下边的代码测试BCrypt加密及校验的方法<br>
编写测试方法：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class) 
public class TestBCrypt {
    @Test
    public void test1(){ 
        //对原始密码加密 
        String hashpw = BCrypt.hashpw(&quot;123&quot;,BCrypt.gensalt()); 
        System.out.println(hashpw);
        //校验原始密码和BCrypt密码是否一致 
        boolean checkpw = BCrypt.checkpw(&quot;123&quot;, &quot;$2a$10$NlBC84MVb7F95EXYTXwLneXgCca6/GipyWR5NHm8K0203bSQMLpvm&quot;); 
        System.out.println(checkpw); 
    } 
}
</code></pre>
<h3 id="授权">授权</h3>
<h4 id="流程-2">流程</h4>
<p>通过<strong>快速上手</strong>我们知道，Spring Security可以通过 http.authorizeRequests() 对web请求进行授权保护。Spring Security使用标准Filter建立了对web请求的拦截，最终实现对资源的授权访问。<br>
Spring Security的授权流程如下：<br>
<img src="http://blog.ludangxin.club/post-images/1591111185336.jpg" alt="" loading="lazy"></p>
<ol>
<li><strong>拦截请求</strong>，已认证用户访问受保护的web资源将被SecurityFilterChain中的 FilterSecurityInterceptor 的子类拦截。</li>
<li><strong>获取资源访问策略</strong>，FilterSecurityInterceptor会从 SecurityMetadataSource 的子类 DefaultFilterInvocationSecurityMetadataSource 获取要访问当前资源所需要的权限Collection<ConfigAttribute> 。 SecurityMetadataSource其实就是读取访问策略的抽象，而读取的内容，其实就是我们配置的访问规则， 读 取访问策略如：</li>
</ol>
<pre><code class="language-java">http.authorizeRequests() 
    .antMatchers(&quot;/r/r1&quot;).hasAuthority(&quot;p1&quot;) 
    .antMatchers(&quot;/r/r2&quot;).hasAuthority(&quot;p2&quot;) ...
</code></pre>
<ol start="3">
<li>最后，FilterSecurityInterceptor会调用 AccessDecisionManager 进行授权决策，若决策通过，则允许访问资源，否则将禁止访问。<br>
AccessDecisionManager（访问决策管理器）的核心接口如下:</li>
</ol>
<pre><code class="language-java">public interface AccessDecisionManager { 
    /** * 通过传递的参数来决定用户是否有访问对应受保护资源的权限 */
    void decide(Authentication authentication , Object object, Collection&lt;ConfigAttribute&gt; configAttributes ) throws AccessDeniedException, InsufficientAuthenticationException;
    //略.. 
}
</code></pre>
<p>这里着重说明一下decide的参数：<br>
authentication：要访问资源的访问者的身份<br>
object：要访问的受保护资源，web请求对应FilterInvocation<br>
confifigAttributes：是受保护资源的访问策略，通过SecurityMetadataSource获取。<br>
<strong>decide接口就是用来鉴定当前用户是否有访问对应受保护资源的权限。</strong></p>
<h4 id="授权决策">授权决策</h4>
<p>AccessDecisionManager采用<strong>投票</strong>的方式来确定是否能够访问受保护资源。<br>
AccessDecisionManager中包含的一系列AccessDecisionVoter将会被用来对Authentication是否有权访问受保护对象进行投票，AccessDecisionManager根据投票结果，做出最终决策。<br>
AccessDecisionVoter是一个接口，其中定义有三个方法，具体结构如下所示。</p>
<pre><code class="language-java">public interface AccessDecisionVoter&lt;S&gt; { 
    int ACCESS_GRANTED = 1; 
    int ACCESS_ABSTAIN = 0; 
    int ACCESS_DENIED = ‐1; 
    boolean supports(ConfigAttribute var1); 
    boolean supports(Class&lt;?&gt; var1); 
    int vote(Authentication var1, S var2, Collection&lt;ConfigAttribute&gt; var3); 
}
</code></pre>
<p>vote()方法的返回结果会是AccessDecisionVoter中定义的三个常量之一。ACCESS_GRANTED表示同意，ACCESS_DENIED表示拒绝，ACCESS_ABSTAIN表示弃权。如果一个AccessDecisionVoter不能判定当前Authentication是否拥有访问对应受保护对象的权限，则其vote()方法的返回值应当为弃权ACCESS_ABSTAIN。<br>
Spring Security内置了三个基于投票的AccessDecisionManager实现类如下，它们分别是<br>
<strong>AffirmativeBased</strong>、<strong>ConsensusBased</strong>和<strong>UnanimousBased</strong>，<strong>Spring security默认使用的是AffirmativeBased。</strong></p>
<p><strong>AffirmativeBased</strong>：</p>
<ol>
<li>只要有AccessDecisionVoter的投票为ACCESS_GRANTED则同意用户进行访问；</li>
<li>如果全部弃权也表示通过；</li>
<li>如果没有一个人投赞成票，但是有人投反对票，则将抛出AccessDeniedException。</li>
</ol>
<p><strong>ConsensusBased</strong>：</p>
<ol>
<li>如果赞成票多于反对票则表示通过。</li>
<li>反过来，如果反对票多于赞成票则将抛出AccessDeniedException。</li>
<li>如果赞成票与反对票相同且不等于0，并且属性allowIfEqualGrantedDeniedDecisions的值为true，则表示通过，否则将抛出异常AccessDeniedException。参数allowIfEqualGrantedDeniedDecisions的值默认为true。</li>
<li>如果所有的AccessDecisionVoter都弃权了，则将视参数allowIfAllAbstainDecisions的值而定，如果该值为true则表示通过，否则将抛出异常AccessDeniedException。参数allowIfAllAbstainDecisions的值默认为false。</li>
</ol>
<p><strong>UnanimousBased</strong>:<br>
UnanimousBased与另外两种实现有点不一样，另外两种会一次性把受保护对象的配置属性全部传递给AccessDecisionVoter进行投票，而UnanimousBased会一次只传递一个ConfifigAttribute给AccessDecisionVoter进行投票。这也就意味着如果我们的AccessDecisionVoter的逻辑是只要传递进来的 ConfifigAttribute中有一个能够匹配则投赞成票，但是放到UnanimousBased中其投票结果就不一定是赞成了。</p>
<ol>
<li>如果受保护对象配置的某一个ConfifigAttribute被任意的AccessDecisionVoter反对了，则将抛出AccessDeniedException。</li>
<li>如果没有反对票，但是有赞成票，则表示通过。</li>
<li>如果全部弃权了，则将视参数allowIfAllAbstainDecisions的值而定，true则通过，false则抛出 AccessDeniedException。<br>
Spring Security也内置一些投票者实现类如<strong>RoleVoter</strong>、<strong>AuthenticatedVoter</strong>和<strong>WebExpressionVoter</strong>等。</li>
</ol>
<h2 id="自定义认证">自定义认证</h2>
<h3 id="创建数据库表">创建数据库表</h3>
<pre><code class="language-sql">CREATE DATABASE `test` CHARACTER SET 'utf8' COLLATE 'utf8_general_ci';
CREATE TABLE `t_user` ( 
    `id` bigint(20) NOT NULL COMMENT '用户id', 
    `username` varchar(64) NOT NULL, 
    `password` varchar(64) NOT NULL, 
    `fullname` varchar(255) NOT NULL COMMENT '用户姓名', 
    `mobile` varchar(11) DEFAULT NULL COMMENT '手机号', 
    PRIMARY KEY (`id`) USING BTREE 
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC
</code></pre>
<h3 id="添加所需依赖">添加所需依赖</h3>
<pre><code class="language-xml">        &lt;!-- spring security 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- web支持 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- mysql依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- mybatis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- lombok 工具--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;!-- 单元测试 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="配置applicationyml">配置application.yml</h3>
<pre><code class="language-yaml">spring:
  datasource:
    type: com.zaxxer.hikari.HikariDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=true&amp;characterEncoding=utf-8
    username: root
    password: root
    hikari:
      minimum-idle: 5
      idle-timeout: 600000
      maximum-pool-size: 10
      auto-commit: true
      pool-name: MyHikariCP
      max-lifetime: 1800000
      connection-timeout: 30000
      connection-test-query: SELECT 1
</code></pre>
<h3 id="修改springboot-启动类">修改springboot 启动类</h3>
<pre><code class="language-java">import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.ldx.springboot.dao&quot;)
public class SpringbootSpringSecurityApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootSpringSecurityApplication.class, args);
    }
}
</code></pre>
<h3 id="创建securityconfig">创建securityConfig</h3>
<pre><code class="language-java">/**
 * springsecurity 配置类
 * @author ludangxin
 * @Date 2020-06-01
 **/
@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    /**
     * 密码编码器
     */
    @Bean public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * 安全拦截机制（最重要）
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.
                //屏蔽CSRF控制，即spring security不再限制CSRF
                csrf().disable().
                authorizeRequests()
                .antMatchers(&quot;/r/r1&quot;).hasAuthority(&quot;p1&quot;)
                .antMatchers(&quot;/r/r2&quot;).hasAuthority(&quot;p2&quot;)
                //所有的请求必须通过认证
                .anyRequest().authenticated()
                .and()
                //允许表单登录
                .formLogin()
                //自定义登录成功的页面地址
                .successForwardUrl(&quot;/login-success&quot;);
    }
}
</code></pre>
<h3 id="创建model">创建model</h3>
<pre><code class="language-java">import lombok.Data;

@Data
public class UserDto {

    private String id;

    private String username;

    private String password;

    private String fullname;

    private String mobile;
}
</code></pre>
<h3 id="创建controller">创建controller</h3>
<pre><code class="language-java">import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LoginController {

    /**
     *  用户登录成功
    */
    @RequestMapping(value = &quot;/login-success&quot;)
    public String loginSuccess() {
        String username = getUsername();
        return username + &quot; 登录成功&quot;;
    }

    /**
     *  获取当前登录用户名
     */
    private String getUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (!authentication.isAuthenticated()) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        String username = null;
        if (principal instanceof org.springframework.security.core.userdetails.UserDetails) {
            username = ((org.springframework.security.core.userdetails.UserDetails) principal).getUsername();
        } else {
            username = principal.toString();
        }
        return username;
    }

    /**
     * 测试资源1
     */
    @GetMapping(value = &quot;/r/r1&quot;)
    public String r1() {
        String username = getUsername();
        return username + &quot; 访问资源1&quot;;
    }

    /**
     * 测试资源2
     */
    @GetMapping(value = &quot;/r/r2&quot;)
    public String r2() {
        String username = getUsername();
        return username + &quot; 访问资源2&quot;;
    }
}
</code></pre>
<h3 id="创建userdetailsservice">创建userdetailsService</h3>
<pre><code class="language-java">import com.ldx.springboot.dao.UserMapper;
import com.ldx.springboot.model.UserDto;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class SpringDataUserDetailsService implements UserDetailsService {

    @Autowired
    UserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //登录账号
        System.out.println(&quot;username=&quot; + username);
        //根据账号去数据库查询...
        UserDto user = userMapper.getUserByUsername(username);
        if (user == null) {
            return null;
        }
        //这里暂时使用静态数据
        UserDetails userDetails = User.withUsername(user.getFullname()).password(user.getPassword()).authorities(&quot;p1&quot;).build();
        return userDetails;
    }
}
</code></pre>
<h3 id="创建mapper">创建mapper</h3>
<pre><code class="language-java">import com.ldx.springboot.model.UserDto;
import org.apache.ibatis.annotations.Select;

public interface UserMapper {

    @Select(&quot;select id,username,password,fullname from t_user where username = #{username}&quot;)
    UserDto getUserByUsername(String username);
}
</code></pre>
<h3 id="创建bcrypt密码测试类">创建BCrypt密码测试类</h3>
<pre><code class="language-java">import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
public class TestBCrypt {

    @Test
    public void test1(){ 
        //对原始密码加密 
        String hashpw = BCrypt.hashpw(&quot;123&quot;,BCrypt.gensalt());
        System.out.println(hashpw);
        //校验原始密码和BCrypt密码是否一致 
        boolean checkpw = BCrypt.checkpw(&quot;123&quot;, &quot;$2a$10$NlBC84MVb7F95EXYTXwLneXgCca6/GipyWR5NHm8K0203bSQMLpvm&quot;); 
        System.out.println(checkpw); 
    } 
}
</code></pre>
<h3 id="测试结果">测试结果</h3>
<ol>
<li>使用BCrypt密码测试类生成指定密码且将用户信息写入数据库用户表</li>
<li>启动项目访问<code>localhost:8080</code></li>
<li>输入用户名密码进行测试</li>
<li>暂时使用静态权限数据,测试<code>r/r1</code>: 正常,<code>r/r2</code>:无权限</li>
</ol>
<h2 id="会话">会话</h2>
<p>用户认证通过后，为了避免用户的每次操作都进行认证可将用户的信息保存在会话中。spring security提供会话管理，认证通过后将身份信息放入SecurityContextHolder上下文，SecurityContext与当前线程进行绑定，方便获取用户身份。</p>
<h3 id="获取当前用户名">获取当前用户名</h3>
<pre><code class="language-java">/**
     *  获取当前登录用户名
     */
    private String getUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (!authentication.isAuthenticated()) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        String username = null;
        if (principal instanceof org.springframework.security.core.userdetails.UserDetails) {
            username = ((org.springframework.security.core.userdetails.UserDetails) principal).getUsername();
        } else {
            username = principal.toString();
        }
        return username;
    }
</code></pre>
<h3 id="会话控制">会话控制</h3>
<p>我们可以通过以下选项准确控制会话何时创建以及Spring Security如何与之交互：</p>
<table>
<thead>
<tr>
<th>机制</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>如果没有session存在就创建一个</td>
</tr>
<tr>
<td>ifRequired</td>
<td>如果需要就创建一个Session（默认）登录时</td>
</tr>
<tr>
<td>never</td>
<td>SpringSecurity 将不会创建Session，但是如果应用中其他地方创建了Session，那么SpringSecurity将会使用它。</td>
</tr>
<tr>
<td>stateles</td>
<td>SpringSecurity将绝对不会创建Session，也不使用Session</td>
</tr>
</tbody>
</table>
<p>通过以下配置方式对该选项进行配置：</p>
<pre><code class="language-java">@Override 
protected void configure(HttpSecurity http) throws Exception { 
    http.sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED) 
}
</code></pre>
<p>默认情况下，Spring Security会为每个登录成功的用户会新建一个Session，就是<strong>ifRequired</strong> 。<br>
若选用<strong>never</strong>，则指示Spring Security对登录成功的用户不创建Session了，但若你的应用程序在某地方新建了session，那么Spring Security会用它的。<br>
若使用<strong>stateless</strong>，则说明Spring Security对登录成功的用户不会创建Session了，你的应用程序也不会允许新建session。并且它会暗示不使用cookie，所以每个请求都需要重新进行身份验证。这种无状态架构适用于REST API及其无状态认证机制。</p>
<h3 id="会话超时">会话超时</h3>
<p>可以再sevlet容器中设置Session的超时时间，如下设置Session有效期为3600s；<br>
springboot配置:</p>
<pre><code class="language-properties">server.servlet.session.timeout=3600s
</code></pre>
<p>session超时之后，可以通过Spring Security 设置跳转的路径。</p>
<pre><code class="language-java">http.sessionManagement() 
    .expiredUrl(&quot;/login‐view?error=EXPIRED_SESSION&quot;) 
    .invalidSessionUrl(&quot;/login‐view?error=INVALID_SESSION&quot;);
</code></pre>
<p>expired指session过期，invalidSession指传入的sessionid无效。</p>
<h3 id="安全会话cookie">安全会话cookie</h3>
<p>我们可以使用httpOnly和secure标签来保护我们的会话cookie：<br>
<strong>httpOnly</strong>：如果为true，那么浏览器脚本将无法访问cookie<br>
<strong>secure</strong>：如果为true，则cookie将仅通过HTTPS连接发送<br>
spring boot 配置文件：</p>
<pre><code class="language-properties">server.servlet.session.cookie.http‐only=true 
server.servlet.session.cookie.secure=true
</code></pre>
<h2 id="退出">退出</h2>
<p>Spring security默认实现了logout退出，访问<code>/logout</code>实现退出操作。<br>
这里也可以自定义退出成功的页面：<br>
在WebSecurityConfifig的protected void confifigure(HttpSecurity http)中配置：</p>
<pre><code class="language-java">.and() 
    .logout() 
    .logoutUrl(&quot;/logout&quot;) 
    .logoutSuccessUrl(&quot;/login‐view?logout&quot;);
</code></pre>
<p>当退出操作出发时，将发生：</p>
<ul>
<li>使HTTP Session 无效</li>
<li>清除 SecurityContextHolder</li>
<li>跳转到 /login-view?logout<br>
但是，类似于配置登录功能，咱们可以进一步自定义退出功能：</li>
</ul>
<pre><code class="language-java">@Override protected void configure(HttpSecurity http) throws Exception { 
    http 
        .authorizeRequests() //... 
        .and() 
        .logout() (1) 
        .logoutUrl(&quot;/logout&quot;) (2) 
        .logoutSuccessUrl(&quot;/login‐view?logout&quot;) (3) 
        .logoutSuccessHandler(logoutSuccessHandler) (4) 
        .addLogoutHandler(logoutHandler) (5) 
        .invalidateHttpSession(true); (6) }
</code></pre>
<p>（1）提供系统退出支持，使用 WebSecurityConfigurerAdapter 会自动被应用<br>
（2）设置触发退出操作的URL (默认是 /logout ).<br>
（3）退出之后跳转的URL。默认是 /login?logout 。<br>
（4）定制的 LogoutSuccessHandler ，用于实现用户退出成功时的处理。如果指定了这个选项那么logoutSuccessUrl() 的设置会被忽略。<br>
（5）添加一个 LogoutHandler ，用于实现用户退出时的清理工作.默认 SecurityContextLogoutHandler 会被添加为最后一个 LogoutHandler 。<br>
（6）指定是否在退出时让 HttpSession 无效。 默认设置为 <strong>true</strong>。<br>
<strong>注意：如果让logout在GET请求下生效，必须关闭防止CSRF攻击csrf().disable()。如果开启了CSRF，必须使用post方式请求/logout</strong><br>
<strong>logoutHandler：</strong><br>
一般来说， LogoutHandler 的实现类被用来执行必要的清理，因而他们不应该抛出异常。<br>
下面是Spring Security提供的一些实现：</p>
<ol>
<li>PersistentTokenBasedRememberMeServices 基于持久化token的<strong>RememberMe</strong>功能的相关清理</li>
<li>TokenBasedRememberMeService 基于token的<strong>RememberMe</strong>功能的相关清理</li>
<li>CookieClearingLogoutHandler 退出时Cookie的相关清理</li>
<li>CsrfLogoutHandler 负责在退出时移除csrfToken</li>
<li>SecurityContextLogoutHandler 退出时SecurityContext的相关清理<br>
链式API提供了调用相应的 LogoutHandler 实现的快捷方式，比如deleteCookies()。</li>
</ol>
<h2 id="自定义授权">自定义授权</h2>
<p>授权的方式包括 web授权和方法授权，web授权是通过 url拦截进行授权，方法授权是通过 方法拦截进行授权。他们都会调用accessDecisionManager进行授权决策，若为web授权则拦截器为FilterSecurityInterceptor；若为方法授权则拦截器为MethodSecurityInterceptor。如果同时通过web授权和方法授权则先执行web授权，再执行方法授权，最后决策通过，则允许访问资源，否则将禁止访问。</p>
<h3 id="创建数据库表-2">创建数据库表</h3>
<pre><code class="language-sql"># 角色表
CREATE TABLE `t_role` ( 
    `id` varchar(32) NOT NULL, 
    `role_name` varchar(255) DEFAULT NULL,
    `description` varchar(255) DEFAULT NULL, 
    `create_time` datetime DEFAULT NULL,
    `update_time` datetime DEFAULT NULL, 
    `status` char(1) NOT NULL, PRIMARY KEY (`id`), 
    UNIQUE KEY `unique_role_name` (`role_name`) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    insert into 
    `t_role`
    (`id`,`role_name`,`description`,`create_time`,`update_time`,`status`)
    values 
    ('1','管理员',NULL,NULL,NULL,'');
# 用户角色关系表
CREATE TABLE `t_user_role` (
    `user_id` varchar(32) NOT NULL,
    `role_id` varchar(32) NOT NULL, 
    `create_time` datetime DEFAULT NULL,
    `creator` varchar(255) DEFAULT NULL, 
    PRIMARY KEY (`user_id`,`role_id`) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    insert into 
    `t_user_role`
    (`user_id`,`role_id`,`create_time`,`creator`)
    values 
    ('1','1',NULL,NULL);
# 权限表
CREATE TABLE `t_permission`( 
    `id` varchar(32) NOT NULL, 
    `code` varchar(32) NOT NULL COMMENT '权限标识符', 
    `description` varchar(64) DEFAULT NULL COMMENT '描述', 
    `url` varchar(128) DEFAULT NULL COMMENT '请求地址', PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    insert into 
    `t_permission`
    (`id`,`code`,`description`,`url`)
    values 
    ('1','p1','测试资源 1','/r/r1'),('2','p3','测试资源2','/r/r2');
# 角色权限关系表
CREATE TABLE `t_role_permission` ( 
    `role_id` varchar(32) NOT NULL,
    `permission_id` varchar(32) NOT NULL, 
    PRIMARY KEY (`role_id`,`permission_id`) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    insert into 
    `t_role_permission`
    (`role_id`,`permission_id`)
    values 
    ('1','1'),('1','2');
</code></pre>
<h3 id="创建model-2">创建model</h3>
<pre><code class="language-java">import lombok.Data;

@Data
public class PermissionDto {

    private String id;

    private String code;

    private String description;

    private String url;
}
</code></pre>
<h3 id="修改userdatailsservice">修改userdatailsService</h3>
<pre><code class="language-java">import com.ldx.springboot.dao.PermissionMapper;
import com.ldx.springboot.dao.UserMapper;
import com.ldx.springboot.model.PermissionDto;
import com.ldx.springboot.model.UserDto;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class SpringDataUserDetailsService implements UserDetailsService {

    @Autowired
    UserMapper userMapper;

    @Autowired
    PermissionMapper permissionMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //登录账号
        System.out.println(&quot;username=&quot; + username);
        //根据账号去数据库查询...
        UserDto user = userMapper.getUserByUsername(username);
        if (user == null) {
            return null;
        }
        //查询用户权限
        List&lt;PermissionDto&gt; permissions = permissionMapper.findPermissionsByUserId(user.getId());
        List&lt;String&gt; permissionCodes = permissions.stream().map(PermissionDto::getCode).collect(Collectors.toList());
        String[] permissionCodeArr = permissionCodes.toArray(new String[permissionCodes.size()]);
        //创建userDetails
        UserDetails userDetails = User.withUsername(user.getFullname()).password(user.getPassword()).authorities(permissionCodeArr).build();
        return userDetails;
    }
}
</code></pre>
<h3 id="创建mapper-2">创建mapper</h3>
<pre><code class="language-java">import com.ldx.springboot.model.PermissionDto;
import org.apache.ibatis.annotations.Select;

import java.util.List;

public interface PermissionMapper {

    @Select(&quot;SELECT * FROM t_permission WHERE id &quot; +
            &quot;IN(SELECT permission_id FROM t_role_permission WHERE role_id &quot; +
            &quot;IN(SELECT role_id FROM t_user_role WHERE user_id = #{id}))&quot;)
    List&lt;PermissionDto&gt; findPermissionsByUserId(String id);
}
</code></pre>
<h3 id="测试-2">测试</h3>
<ol>
<li>启动项目访问<code>localhost:8080</code></li>
<li>登陆用户</li>
<li>测试访问<code>r/r1</code>,<code>r/r2</code> 资源</li>
</ol>
<h2 id="web授权">web授权</h2>
<p>在上面例子中我们完成了认证拦截，并对/r/**下的某些资源进行简单的授权保护，但是我们想进行灵活的授权控制该怎么做呢？通过给 http.authorizeRequests() 添加多个子节点来定制需求到我们的URL，如下代码：</p>
<pre><code class="language-java">@Override protected void configure(HttpSecurity http) throws Exception { 
    http 
        .authorizeRequests() (1) 
        .antMatchers(&quot;/r/r1&quot;)
        .hasAuthority(&quot;p1&quot;) (2) 
        .antMatchers(&quot;/r/r2&quot;)
        .hasAuthority(&quot;p2&quot;) (3) 
        .antMatchers(&quot;/r/r3&quot;)
        .access(&quot;hasAuthority('p1') and hasAuthority('p2')&quot;) (4) 
        .antMatchers(&quot;/r/**&quot;)
        .authenticated() (5) 
        .anyRequest().permitAll() (6) 
        .and() .formLogin() 
        // ... 
}
</code></pre>
<p>（1） http.authorizeRequests() 方法有多个子节点，每个macher按照他们的声明顺序执行。</p>
<p>（2）指定&quot;/r/r1&quot;URL，拥有p1权限能够访问</p>
<p>（3）指定&quot;/r/r2&quot;URL，拥有p2权限能够访问</p>
<p>（4）指定了&quot;/r/r3&quot;URL，同时拥有p1和p2权限才能够访问</p>
<p>（5）指定了除了r1、r2、r3之外&quot;/r/**&quot;资源，同时通过身份认证就能够访问，这里使用SpEL（Spring Expression Language）表达式。。</p>
<p>（6）剩余的尚未匹配的资源，不做保护。</p>
<p><strong>注意</strong>：</p>
<p><strong>规则的顺序是重要的,更具体的规则应该先写</strong>.现在以/ admin开始的所有内容都需要具有ADMIN角色的身份验证用</p>
<p>户,即使是/ admin / login路径(因为/ admin / login已经被/ admin / **规则匹配,因此第二个规则被忽略).</p>
<pre><code class="language-java">.antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;) 
.antMatchers(&quot;/admin/login&quot;).permitAll()
</code></pre>
<p>因此,登录页面的规则应该在/ admin / **规则之前.例如.</p>
<pre><code class="language-java">.antMatchers(&quot;/admin/login&quot;).permitAll() 
.antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)
</code></pre>
<p>保护URL常用的方法有：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>authenticated()</strong></td>
<td>保护URL，需要用户登录</td>
</tr>
<tr>
<td><strong>permitAll()</strong></td>
<td>指定URL无需保护，一般应用与静态资源文件</td>
</tr>
<tr>
<td><strong>hasRole(String role)</strong></td>
<td>限制单个角色访问，角色将被增加 “ROLE_” .所以”ADMIN” 将和 “ROLE_ADMIN”进行比较.</td>
</tr>
<tr>
<td><strong>hasAuthority(String authority)</strong></td>
<td>限制单个权限访问</td>
</tr>
<tr>
<td><strong>hasAnyRole(String… roles)</strong></td>
<td>允许多个角色访问.</td>
</tr>
<tr>
<td><strong>hasAnyAuthority(String… authorities)</strong></td>
<td>允许多个权限访问.</td>
</tr>
<tr>
<td><strong>access(String attribute)</strong></td>
<td>该方法使用 SpEL表达式, 所以可以创建复杂的限制.</td>
</tr>
<tr>
<td><strong>hasIpAddress(String ipaddressExpression)</strong></td>
<td>限制IP地址或子网</td>
</tr>
</tbody>
</table>
<h2 id="方法授权">方法授权</h2>
<p>现在我们已经掌握了使用如何使用 http.authorizeRequests() 对web资源进行授权保护，从Spring Security2.0版 本开始，它支持服务层方法的安全性的支持。本节学习@PreAuthorize,@PostAuthorize, @Secured三类注解。我们可以在任何 @Configuration 实例上使用 @EnableGlobalMethodSecurity 注释来启用基于注解的安全性。以下内容将启用Spring Security的 @Secured 注释。</p>
<pre><code class="language-java">@EnableGlobalMethodSecurity(securedEnabled = true) 
public class MethodSecurityConfig {
    // ...
}
</code></pre>
<p>然后向方法（在类或接口上）添加注解就会限制对该方法的访问。 Spring Security的原生注释支持为该方法定义了一组属性。 这些将被传递给AccessDecisionManager以供它作出实际的决定：</p>
<pre><code class="language-java">public interface BankService { 
    @Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;) 
    public Account readAccount(Long id); 
    @Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;) 
    public Account[] findAccounts();
    @Secured(&quot;ROLE_TELLER&quot;) 
    public Account post(Account account, double amount); 
}
</code></pre>
<p>以上配置标明readAccount、findAccounts方法可匿名访问，底层使用WebExpressionVoter投票器，可从 AffirmativeBased第23行代码跟踪。。</p>
<p>post方法需要有TELLER角色才能访问，底层使用RoleVoter投票器。</p>
<p>使用如下代码可启用prePost注解的支持</p>
<pre><code class="language-java">@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig { 
    // ... 
}
</code></pre>
<p>相应Java代码如下：</p>
<pre><code class="language-java">public interface BankService { 
    @PreAuthorize(&quot;isAnonymous()&quot;) 
    public Account readAccount(Long id);
    @PreAuthorize(&quot;isAnonymous()&quot;)
    public Account[] findAccounts(); 
    @PreAuthorize(&quot;hasAuthority('p_transfer') and hasAuthority('p_read_account')&quot;) 
    public Account post(Account account, double amount); 
}
</code></pre>
<p>以上配置标明readAccount、findAccounts方法可匿名访问，post方法需要同时拥有p_transfer和p_read_account 权限才能访问，底层使用WebExpressionVoter投票器，可从AffirmativeBased第23行代码跟踪。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识 Dubbo]]></title>
        <id>http://blog.ludangxin.club/post/chu-shi-dubbo/</id>
        <link href="http://blog.ludangxin.club/post/chu-shi-dubbo/">
        </link>
        <updated>2020-05-25T12:43:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="dubbo是什么">dubbo是什么</h1>
<h2 id="简介">简介</h2>
<p>Apache Dubbo是一款高性能的java <strong>RPC</strong>框架. 其前身是阿里巴巴公司开源的一个高性能,轻量级的开源java RPC 框架,可以和Spring框架无缝集成.<br>
Dubbo提供了三大核心能力: 面向接口的远程方法调用, 智能容错和负载均衡,以及服务注册和发现.<br>
官方:http://dubbo.apache.org/zh-cn/</p>
<h2 id="架构">架构</h2>
<figure data-type="image" tabindex="1"><img src="http://blog.ludangxin.club/post-images/1590410698368.jpg" alt="" loading="lazy"></figure>
<h3 id="节点角色说明">节点角色说明</h3>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Provider</code></td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td><code>Consumer</code></td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td><code>Registry</code></td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td><code>Monitor</code></td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td><code>Container</code></td>
<td>服务运行容器</td>
</tr>
</tbody>
</table>
<h3 id="调用关系说明">调用关系说明</h3>
<ol>
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h1 id="rpc">RPC</h1>
<p>RPC全称为remote procedure call. 即<strong>远程调用过程</strong> ,过程其实就是方法, 所以可以把RPC理解为“远程方法调用”。<br>
比如两台服务器A和B, A服务器上部署一个应用, B服务器上部署一个应用, A服务器上的应用想调用B服务器上的应用提供的方法,由于两个应用不在一个内存空间, 不能直接调用, 所以需要通过网络来表达调用的语义和传达调用的数据.<br>
需要注意的是RPC并不是一个具体的技术, 而是指整个网络远程调用过程.<br>
而不需要了解底层网络技术的协议,在面向对象的编程语言中, 远程过程调用即是 远程方法调用<br>
<img src="http://blog.ludangxin.club/post-images/1590410726668.jpg" alt="" loading="lazy"></p>
<h1 id="智能容错">智能容错</h1>
<p>为了避免单点故障，现在的应用通常至少会部署在两台服务器上。对于一些负载比较高的服务，会部署更多的服务器。这样，在同一环境下的服务提供者数量会大于1。对于服务消费者来说，同一环境下出现了多个服务提供者。这时会出现一个问题，服务消费者需要决定选择哪个服务提供者进行调用。另外服务调用失败时的处理措施也是需要考虑的，是重试呢，还是抛出异常，亦或是只打印异常等。为了处理这些问题，Dubbo 定义了集群接口 Cluster 以及 Cluster Invoker。集群 Cluster 用途是将多个服务提供者合并为一个 Cluster Invoker，并将这个 Invoker 暴露给服务消费者。这样一来，服务消费者只需通过这个 Invoker 进行远程调用即可，至于具体调用哪个服务提供者，以及调用失败后如何处理等问题，现在都交给集群模块去处理。集群模块是服务提供者和服务消费者的中间层，为服务消费者屏蔽了服务提供者的情况，这样服务消费者就可以专心处理远程调用相关事宜。比如发请求，接受服务提供者返回的数据等。这就是集群的作用。<br>
Dubbo 提供了多种集群实现，包含但不限于 Failover Cluster、Failfast Cluster 和 Failsafe Cluster 等。每种集群实现类的用途不同，接下来会一一进行分析。<br>
在对集群相关代码进行分析之前，这里有必要先来介绍一下集群容错的所有组件。包含 Cluster、Cluster Invoker、Directory、Router 和 LoadBalance 等。<br>
<img src="http://blog.ludangxin.club/post-images/1590410921569.jpg" alt="" loading="lazy"><br>
集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，集群 Cluster 实现类为服务消费者创建 Cluster Invoker 实例，即上图中的 merge 操作。第二个阶段是在服务消费者进行远程调用时。以 FailoverClusterInvoker 为例，该类型 Cluster Invoker 首先会调用 Directory 的 list 方法列举 Invoker 列表（可将 Invoker 简单理解为服务提供者）。Directory 的用途是保存 Invoker，可简单类比为 List<Invoker>。其实现类 RegistryDirectory 是一个动态服务目录，可感知注册中心配置的变化，它所持有的 Invoker 列表会随着注册中心内容的变化而变化。每次变化后，RegistryDirectory 会动态增删 Invoker，并调用 Router 的 route 方法进行路由，过滤掉不符合路由规则的 Invoker。当 FailoverClusterInvoker 拿到 Directory 返回的 Invoker 列表后，它会通过 LoadBalance 从 Invoker 列表中选择一个 Invoker。最后 FailoverClusterInvoker 会将参数传给 LoadBalance 选择出的 Invoker 实例的 invoke 方法，进行真正的远程调用。<br>
以上就是集群工作的整个流程，这里并没介绍集群是如何容错的。Dubbo 主要提供了这样几种容错方式：</p>
<ul>
<li>Failover Cluster - 失败自动切换</li>
<li>Failfast Cluster - 快速失败</li>
<li>Failsafe Cluster - 失败安全</li>
<li>Failback Cluster - 失败自动恢复</li>
<li>Forking Cluster - 并行调用多个服务提供者</li>
</ul>
<h2 id="failover-cluster">Failover Cluster</h2>
<p>FailoverClusterInvoker 在调用失败时，会自动切换 Invoker 进行重试。默认配置下，Dubbo 会使用这个类作为缺省 Cluster Invoker<br>
可通过 <code>retries=&quot;2&quot;</code> 来设置重试次数(不含第一次)。<br>
重试次数配置如下：</p>
<pre><code class="language-xml">&lt;dubbo:service retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code class="language-xml">&lt;dubbo:reference retries=&quot;2&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code class="language-xml">&lt;dubbo:reference&gt;
    &lt;dubbo:method name=&quot;findFoo&quot; retries=&quot;2&quot; /&gt;
&lt;/dubbo:reference&gt;
</code></pre>
<h2 id="failfast-cluster">Failfast Cluster</h2>
<p>FailfastClusterInvoker 只会进行一次调用，失败后立即抛出异常。适用于非幂等操作，比如新增记录。</p>
<h2 id="failsafe-cluster">Failsafe Cluster</h2>
<p>FailsafeClusterInvoker 是一种失败安全的 Cluster Invoker。所谓的失败安全是指，当调用过程中出现异常时，FailsafeClusterInvoker 仅会打印异常，而不会抛出异常。适用于写入审计日志等操作。</p>
<h2 id="failback-cluster">Failback Cluster</h2>
<p>FailbackClusterInvoker 会在调用失败后，返回一个空结果给服务消费者。并通过定时任务对失败的调用进行重传，适合执行消息通知等操作。</p>
<h2 id="forking-cluster">Forking Cluster</h2>
<p>ForkingClusterInvoker 会在运行时通过线程池创建多个线程，并发调用多个服务提供者。只要有一个服务提供者成功返回了结果，doInvoke 方法就会立即结束运行。ForkingClusterInvoker 的应用场景是在一些对实时性要求比较高<strong>读操作</strong>（注意是读操作，并行写操作可能不安全）下使用，但这将会耗费更多的资源。</p>
<h1 id="服务治理和配置管理">服务治理和配置管理</h1>
<h2 id="服务治理">服务治理</h2>
<p>服务治理主要作用是改变运行时服务的行为和选址逻辑，达到限流，权重配置等目的，主要有以下几个功能：</p>
<h3 id="应用级别的服务治理">应用级别的服务治理</h3>
<p>在Dubbo2.6及更早版本中，所有的服务治理规则都只针对服务粒度，如果要把某条规则作用到应用粒度上，需要为应用下的所有服务配合相同的规则，变更，删除的时候也需要对应的操作，这样的操作很不友好，因此Dubbo2.7版本中增加了应用粒度的服务治理操作，对于条件路由(包括黑白名单)，动态配置(包括权重，负载均衡)都可以做应用级别的配置：<br>
<img src="http://dubbo.apache.org/img/blog/admin/conditionRoute.jpg" alt="condition" loading="lazy"><br>
上图是条件路由的配置，可以按照应用名，服务名两个维度来填写，也可以按照这两个维度来查询。</p>
<h3 id="标签路由">标签路由</h3>
<p>标签路由是Dubbo2.7引入的新功能，配置以应用作为维度，给不同的服务器打上不同名字的标签，配置如下图所示： <img src="http://dubbo.apache.org/img/blog/admin/route.jpg" alt="tag" loading="lazy"> 调用的时候，客户端可以通过<code>setAttachment</code>的方式，来设置不同的标签名称，比如本例中，<code>setAttachment(tag1)</code>，客户端的选址范围就在如图所示的三台机器中，可以通过这种方式来实现流量隔离，灰度发布等功能。</p>
<h3 id="条件路由">条件路由</h3>
<p>条件路由是Dubbo一直以来就有的功能，目前可以配置服务和应用两个维度，条件路由为<code>yaml</code>格式，具体的规则体以及各种适用场景，请参考<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/routing-rule.html">这里</a></p>
<h3 id="黑白名单">黑白名单</h3>
<p>黑白名单是条件路由的一部分，规则存储和条件路由放在一起，为了方便配置所以单独拿出来，同样可以通过服务和应用两个维度，指定黑名单和白名单:<br>
<img src="http://dubbo.apache.org/docs/zh-cn/admin/sources/images/blackList.jpg" alt="blackList" loading="lazy"></p>
<h3 id="动态配置">动态配置</h3>
<p>动态配置是和路由规则平行的另一类服务治理治理功能，主要作用是在不重启服务的情况下，动态改变调用行为，从Dubbo2.7版本开始，支持服务和应用两个维度的配置，采用<code>yaml</code>格式，界面如下：<br>
<img src="http://dubbo.apache.org/docs/zh-cn/admin/sources/images/config.jpg" alt="config" loading="lazy"> 具体的规则体说明请参考<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/config-rule.html">这里</a></p>
<h3 id="权重调节">权重调节</h3>
<p>权重调节是动态配置的子功能，主要作用是改变服务端的权重，更大的权重会有更大的几率被客户端选中作为服务提供者，从而达到流量分配的目的：<br>
<img src="http://dubbo.apache.org/docs/zh-cn/admin/sources/images/weight.jpg" alt="weight" loading="lazy"></p>
<h3 id="负载均衡">负载均衡</h3>
<p>负载均衡也是动态配置的子功能，主要作用是调整客户端的选址逻辑，目前可选的负载均衡策略有随机，轮训和最小活跃，关于各个策略的解释请参考<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/loadbalance.html">这里</a></p>
<h2 id="配置管理">配置管理</h2>
<p>配置管理也是配合Dubbo2.7新增的功能，在Dubbo2.7中，增加了全局和应用维度的配置，分别在全局和应用范围内生效，其中应用配置也可以指定该应用中的服务级别的配置，可以在控制台中查看，修改配置规则，默认展示全局维度的配置。</p>
<ul>
<li>全局配置： <img src="http://dubbo.apache.org/img/blog/admin/config.jpg" alt="config" loading="lazy"><br>
全局配置里可以指定注册中心，元数据中心的地址，服务端和客户端的超时时间等，这些配置在全局内生效。除了配置写入，也可以用来查看。如果使用zookeeper作为注册中心和元数据中心，还可以看到配置文件所在位置的目录结构。</li>
<li>应用， 服务配置<br>
<img src="http://dubbo.apache.org/img/blog/admin/appConfig.jpg" alt="appConfig" loading="lazy"><br>
应用级别的配置可以为应用或者应用内的服务指定配置，在服务维度上，需要区分提供者和消费者。<code>dubbo.reference.{serviceName}</code>表示作为该服务消费者的配置，<code>dubbo.provider.{servcieName}</code>表示作为该服务提供者的配置。其中注册中心和元数据中心的地址，只能在全局配置中指定，这也是Dubbo2.7中推荐的使用方式。</li>
<li>优先级： 服务配置 &gt; 应用配置 &gt; 全局配置</li>
</ul>
<h1 id="既然有-http-请求为什么还要用-rpc-调用">既然有 HTTP 请求，为什么还要用 RPC 调用？</h1>
<p>HTTP协议，以其中的Restful规范为代表，其优势很大。它<strong>可读性好</strong>，且<strong>可以得到防火墙的支持、跨语言的支持</strong>。而且，在去年的报告中，Restful<strong>大有超过RPC的趋势</strong>。<br>
但是HTTP也有其缺点，这是与其优点相对应的。首先是<strong>有用信息占比少</strong>，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。其次是<strong>效率低</strong>，还是因为第七层的缘故。还有，其<strong>可读性似乎没有必要</strong>，因为我们可以引入网关增加可读性。此外，使用HTTP协议<strong>调用远程方法比较复杂</strong>，要封装各种参数名和参数值。<br>
但需要再说一句，不是说RPC好，也不是说HTTP好，<strong>两者各有千秋，还在比拼中</strong>。</p>
<ol>
<li><strong>HTTP和RPC同一级别，还是被RPC包含？</strong></li>
<li><strong>Restful也属于RPC么？</strong><br>
<img src="http://blog.ludangxin.club/post-images/1590410838192.jpg" alt="" loading="lazy"><br>
上图是一个比较完整的关系图，这时我们发现HTTP（图中蓝色框）出现了两次。其中一个是和RPC并列的，都是跨应用调用方法的解决方案；另一个则是被RPC包含的，是RPC通信过程的可选协议之一。<br>
因此，**第一个问题的答案是都对。看指的是哪一个蓝色框。**从题主的提问看，既然题主在纠结这两者，应该是指与RPC并列的蓝色框。<br>
第二个问题是在问远程过程调用（红色框）是不是包含了Restful（黄色框），这种理解的关键在于对RPC的理解。<br>
RPC字面理解是远程过程调用，即在一个应用中调用另一个应用的方法。那Restful是满足的，通过它可以实现在一个应用中调用另一个应用的方法。<br>
但是，上述理解使得RPC的定义过于宽泛。RPC通常特指在一个应用中调用另一个应用的接口而实现的远程调用，即红色框所指的范围。这样，RPC是不包含Restful的。<br>
因此，<strong>第二个问题的答案是Restful不属于RPC，除非对RPC有着非常规的宽泛理解。</strong><br>
RPC的英文全称是Remote Procedure Call，翻译为中文叫“远程过程调用”。其中稍显晦涩的其实就是“过程”，过程其实就是方法。所以，可以把RPC理解为“远程方法调用”。<br>
要了解远程过程调用，那先理解过程调用。非常简单，如下图，就是调用一个方法。这太常见了，不多解释。<br>
<img src="http://blog.ludangxin.club/post-images/1590410853225.jpg" alt="" loading="lazy"><br>
而在分布式系统中，因为每个服务的边界都很小，很有可能调用别的服务提供的方法。这就出现了服务A调用服务B中方法的需求，即远程过程调用。<br>
要想让服务A调用服务B中的方法，最先想到的就是通过HTTP请求实现。是的，这是很常见的，例如服务B暴露Restful接口，然后让服务A调用它的接口。基于Restful的调用方式因为可读性好（服务B暴露出的是Restful接口，可读性当然好）而且HTTP请求可以通过各种防火墙，因此非常不错。<br>
然而，如前面所述，基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。<br>
服务A调用服务B的过程是应用间的内部过程，<strong>牺牲可读性提升效率、易用性是可取的</strong>。基于这种思路，RPC产生了。<br>
通常，RPC要求在调用方中放置被调用的方法的接口。<strong>调用方只要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用</strong>。于是，调用方可以像调用内部接口一样调用远程的方法，而不用封装参数名和参数值等操作。<br>
<img src="http://blog.ludangxin.club/post-images/1590410865791.jpg" alt="" loading="lazy"><br>
那要想实现这个过程该怎么办呢？别急，咱们一步一步来。<br>
首先，调用方调用的是接口，必须得为接口构造一个假的实现。显然，要使用动态代理。这样，调用方的调用就被动态代理接收到了。<br>
第二，动态代理接收到调用后，应该想办法调用远程的实际实现。这包括下面几步：</li>
</ol>
<ul>
<li>识别具体要调用的远程方法的IP、端口</li>
<li>将调用方法的入参进行序列化</li>
<li>通过通信将请求发送到远程的方法中<br>
这样，远程的服务就接收到了调用方的请求。它应该：</li>
<li>反序列化各个调用参数</li>
<li>定位到实际要调用的方法，然后输入参数，执行方法</li>
<li>按照调用的路径返回调用的结果<br>
整个过程如下所示:<br>
<img src="http://blog.ludangxin.club/post-images/1590410877190.jpg" alt="" loading="lazy"><br>
调用方调用内部的一个方法，但是被RPC框架偷梁换柱为远程的一个方法。之间的<strong>通信数据可读性不需要好</strong>，只需要RPC框架能读懂即可，因此<strong>效率可以更高</strong>。通常使用UDP或者TCP作为通讯协议，当然也可以使用HTTP。<br>
所以，不要被RPC吓到，它就是<strong>让一个应用调用另一个应用中方法的一种实现方式</strong>。与调用远程接口区别不大，条条大路通罗马。<br>
再说一次，不是说RPC好，也不是说HTTP好，两者各有千秋。本质上，两者是<strong>可读性和效率之间的抉择</strong>，<strong>通用性和易用性之间的抉择</strong>。最终谁能发展更好，很难说。<br>
要问我站谁？我<strong>根据业务场景，灵活站位……</strong><br>
来源：知乎<br>
链接：https://www.zhihu.com/question/41609070/answer/1030913797</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[初识 Zookeeper]]></title>
        <id>http://blog.ludangxin.club/post/chu-shi-zookeeper/</id>
        <link href="http://blog.ludangxin.club/post/chu-shi-zookeeper/">
        </link>
        <updated>2020-05-24T05:14:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="zookeeper是什么">zookeeper是什么</h1>
<p>zookeeper是一个开源的分布式<strong>协调</strong>服务, 提供分布式<strong>数据一致性</strong>解决方案,分布式应用程序可以实现<strong>数据统一配置管理、统一命名服务、分布式锁、集群管理</strong>等功能.</p>
<p>ZooKeeper主要<strong>服务于分布式系统</strong>，使用分布式系统就无法避免对节点管理的问题(需要实时感知节点的状态、对节点进行统一管理等等)，而由于这些问题处理起来可能相对麻烦和提高了系统的复杂性，ZooKeeper作为一个能够<strong>通用</strong>解决这些问题的中间件就应运而生了。</p>
<h1 id="zookeeper为什么能干这么多">zookeeper为什么能干这么多</h1>
<p>从上面我们可以知道，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。</p>
<ul>
<li>这里我们<strong>先</strong>不管<code>统一配置管理、统一命名服务、分布式锁、集群管理</code>每个具体的含义(后面会讲)</li>
</ul>
<p>那为什么ZooKeeper可以干那么多事？来看看ZooKeeper究竟是何方神物，在Wiki中其实也有提到：</p>
<blockquote>
<p>ZooKeeper nodes store their data in a hierarchical name space, much like a file system or a <a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Tree_(data_structure)">tree</a> data structure</p>
<p>译文: ZooKeeper节点将其数据存储在分层名称空间中，这与文件系统或树数据结构非常相似</p>
</blockquote>
<p><strong>Zookeeper 一个最常用的使用场景就是用于担任服务生产者和服务消费者的注册中心</strong> 。服务生产者将自己提供的服务注册到Zookeeper中心，服务的消费者在进行服务调用的时候先到Zookeeper中查找服务，获取到服务生产者的详细信息之后，再去调用服务生产者的内容与数据。如下图所示，在 Dubbo架构中 Zookeeper 就担任了注册中心这一角色。<br>
<img src="http://blog.ludangxin.club/post-images/1590297452731.jpg" alt="" loading="lazy"></p>
<h2 id="数据结构">数据结构</h2>
<p>ZooKeeper的数据结构，跟Unix文件系统非常类似，可以看做是一颗<strong>树</strong>，每个节点叫做<strong>ZNode</strong>。每一个节点可以通过<strong>路径</strong>来标识，结构图如下：<br>
<img src="http://blog.ludangxin.club/post-images/1590297465572.jpg" alt="" loading="lazy"><br>
那ZooKeeper这颗&quot;树&quot;有什么特点呢？？ZooKeeper的节点我们称之为<strong>Znode</strong>，Znode分为<strong>两种</strong>类型：</p>
<ul>
<li><strong>短暂/临时(Ephemeral)</strong>：当客户端和服务端断开连接后，所创建的Znode(节点)<strong>会自动删除</strong></li>
<li><strong>持久(Persistent)</strong>：当客户端和服务端断开连接后，所创建的Znode(节点)<strong>不会删除</strong></li>
</ul>
<blockquote>
<p>ZooKeeper和Redis一样，也是C/S结构(分成客户端和服务端)<br>
<img src="http://blog.ludangxin.club/post-images/1590297481498.jpg" alt="" loading="lazy"></p>
</blockquote>
<h2 id="监听器">监听器</h2>
<p>在上面我们已经简单知道了ZooKeeper的数据结构了，ZooKeeper还配合了<strong>监听器</strong>才能够做那么多事的。<br>
<strong>常见</strong>的监听场景有以下两项：</p>
<ul>
<li>监听Znode节点的<strong>数据变化</strong></li>
<li>监听子节点的<strong>增减变化</strong><br>
<img src="http://blog.ludangxin.club/post-images/1590297499784.jpg" alt="" loading="lazy"><br>
<img src="http://blog.ludangxin.club/post-images/1590297527050.jpg" alt="" loading="lazy"><br>
没错，通过<strong>监听+Znode节点(持久/短暂[临时])</strong>，ZooKeeper就可以玩出这么多花样了。</li>
</ul>
<h1 id="zookeeper具体能干什么">zookeeper具体能干什么</h1>
<h2 id="统一配置管理">统一配置管理</h2>
<p>比如我们现在有三个系统A、B、C，他们有三份配置，分别是<code>ASystem.yml、BSystem.yml、CSystem.yml</code>，然后，这三份配置又非常类似，很多的配置项几乎都一样。</p>
<ul>
<li>此时，如果我们要改变其中一份配置项的信息，很可能其他两份都要改。并且，改变了配置项的信息<strong>很可能就要重启系统</strong><br>
于是，我们希望把<code>ASystem.yml、BSystem.yml、CSystem.yml</code>相同的配置项抽取出来成一份<strong>公用</strong>的配置<code>common.yml</code>，并且即便<code>common.yml</code>改了，也不需要系统A、B、C重启。<br>
<img src="http://blog.ludangxin.club/post-images/1590297542591.jpg" alt="" loading="lazy"><br>
做法：我们可以将<code>common.yml</code>这份配置放在ZooKeeper的Znode节点中，系统A、B、C监听着这个Znode节点有无变更，如果变更了，<strong>及时</strong>响应。<br>
<img src="http://blog.ludangxin.club/post-images/1590297551378.jpg" alt="" loading="lazy"></li>
</ul>
<h2 id="统一命名服务">统一命名服务</h2>
<p>统一命名服务的理解其实跟<strong>域名</strong>一样，是我们为这某一部分的资源给它<strong>取一个名字</strong>，别人通过这个名字就可以拿到对应的资源。<br>
比如说，现在我有一个域名<code>www.java3y.com</code>，但我这个域名下有多台机器：</p>
<ul>
<li>192.168.1.1</li>
<li>192.168.1.2</li>
<li>192.168.1.3</li>
<li>192.168.1.4<br>
别人访问<code>www.java3y.com</code>即可访问到我的机器，而不是通过IP去访问。<br>
<img src="http://blog.ludangxin.club/post-images/1590297563202.jpg" alt="" loading="lazy"></li>
</ul>
<h2 id="分布式锁">分布式锁</h2>
<p>我们可以使用ZooKeeper来实现分布式锁，那是怎么做的呢？？下面来看看：<br>
系统A、B、C都去访问<code>/locks</code>节点<br>
<img src="http://blog.ludangxin.club/post-images/1590297574406.jpg" alt="" loading="lazy"><br>
访问的时候会创建<strong>带顺序号的临时/短暂</strong>(<code>EPHEMERAL_SEQUENTIAL</code>)节点，比如，系统A创建了<code>id_000000</code>节点，系统B创建了<code>id_000002</code>节点，系统C创建了<code>id_000001</code>节点。<br>
<img src="http://blog.ludangxin.club/post-images/1590297582628.jpg" alt="" loading="lazy"><br>
接着，拿到<code>/locks</code>节点下的所有子节点(id_000000,id_000001,id_000002)，<strong>判断自己创建的是不是最小的那个节点</strong></p>
<ul>
<li>如果是，则拿到锁。</li>
<li>
<ul>
<li>释放锁：执行完操作后，把创建的节点给删掉</li>
</ul>
</li>
<li>如果不是，则监听比自己要小1的节点变化<br>
举个例子：</li>
<li>系统A拿到<code>/locks</code>节点下的所有子节点，经过比较，发现自己(<code>id_000000</code>)，是所有子节点最小的。所以得到锁</li>
<li>系统B拿到<code>/locks</code>节点下的所有子节点，经过比较，发现自己(<code>id_000002</code>)，不是所有子节点最小的。所以监听比自己小1的节点<code>id_000001</code>的状态</li>
<li>系统C拿到<code>/locks</code>节点下的所有子节点，经过比较，发现自己(<code>id_000001</code>)，不是所有子节点最小的。所以监听比自己小1的节点<code>id_000000</code>的状态</li>
<li>…...</li>
<li>等到系统A执行完操作以后，将自己创建的节点删除(<code>id_000000</code>)。通过监听，系统C发现<code>id_000000</code>节点已经删除了，发现自己已经是最小的节点了，于是顺利拿到锁</li>
<li>….系统B如上</li>
</ul>
<h2 id="集群状态">集群状态</h2>
<p>经过上面几个例子，我相信大家也很容易想到ZooKeeper是怎么&quot;<strong>感知</strong>&quot;节点的动态新增或者删除的了。<br>
还是以我们三个系统A、B、C为例，在ZooKeeper中创建<strong>临时节点</strong>即可：<br>
<img src="http://blog.ludangxin.club/post-images/1590297610379.jpg" alt="" loading="lazy"><br>
只要系统A挂了，那<code>/groupMember/A</code>这个节点就会删除，通过<strong>监听</strong><code>groupMember</code>下的子节点，系统B和C就能够感知到系统A已经挂了。(新增也是同理)<br>
除了能够感知节点的上下线变化，ZooKeeper还可以实现<strong>动态选举Master</strong>的功能。(如果集群是主从架构模式下)<br>
原理也很简单，如果想要实现动态选举Master的功能，Znode节点的类型是带<strong>顺序号的临时节点</strong>(<code>EPHEMERAL_SEQUENTIAL</code>)就好了。</p>
<ul>
<li>Zookeeper会每次选举最小编号的作为Master，如果Master挂了，自然对应的Znode节点就会删除。然后让<strong>新的最小编号作为Master</strong>，这样就可以实现动态选举的功能了。<br>
转自: <a href="https://www.zhihu.com/question/65852003/answer/656091418">Java3y-zookeeper</a></li>
</ul>
<h1 id="zab-协议paxos算法">ZAB 协议&amp;Paxos算法</h1>
<p><a href="https://www.zhihu.com/question/19787937/answer/107750652">paxos 算法</a><br>
Paxos 算法应该可以说是 ZooKeeper 的灵魂了。但是，ZooKeeper 并没有完全采用 Paxos算法 ，而是使用 ZAB 协议作为其保证数据一致性的核心算法。另外，在ZooKeeper的官方文档中也指出，ZAB协议并不像 Paxos 算法那样，是一种通用的分布式一致性算法，它是一种特别为Zookeeper设计的崩溃可恢复的原子消息广播算法。</p>
<h2 id="zab-协议介绍">ZAB 协议介绍</h2>
<p><strong>ZAB（ZooKeeper Atomic Broadcast 原子广播） 协议是为分布式协调服务 ZooKeeper 专门设计的一种支持崩溃恢复的原子广播协议。 在 ZooKeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性，基于该协议，ZooKeeper 实现了一种主备模式的系统架构来保持集群中各个副本之间的数据一致性。</strong><br>
<strong>ZAB 协议两种基本的模式：崩溃恢复和消息广播</strong><br>
ZAB协议包括两种基本的模式，分别是 <strong>崩溃恢复和消息广播</strong>。当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的Leader服务器。当选举产生了新的 Leader 服务器，同时集群中已经有过半的机器与该Leader服务器完成了状态同步之后，ZAB协议就会退出恢复模式。其中，<strong>所谓的状态同步是指数据同步，用来保证集群中存在过半的机器能够和Leader服务器的数据状态保持一致</strong>。<br>
<strong>当集群中已经有过半的Follower服务器完成了和Leader服务器的状态同步，那么整个服务框架就可以进人消息广播模式了。</strong> 当一台同样遵守ZAB协议的服务器启动后加人到集群中时，如果此时集群中已经存在一个Leader服务器在负责进行消息广播，那么新加人的服务器就会自觉地进人数据恢复模式：找到Leader所在的服务器，并与其进行数据同步，然后一起参与到消息广播流程中去。正如上文介绍中所说的，ZooKeeper设计成只允许唯一的一个Leader服务器来进行事务请求的处理。Leader服务器在接收到客户端的事务请求后，会生成对应的事务提案并发起一轮广播协议；而如果集群中的其他机器接收到客户端的事务请求，那么这些非Leader服务器会首先将这个事务请求转发给Leader服务器。</p>
<h1 id="zookeeper环境搭建">zookeeper环境搭建</h1>
<h2 id="单机环境">单机环境</h2>
<ol>
<li>上传zookeeper到linux服务器</li>
<li>解压缩压缩包</li>
</ol>
<pre><code class="language-bash">tar -zxvf zookeeper-3.5.8.tar
</code></pre>
<ol start="3">
<li>进入zookeeper-3.5.8目录,创建data文件夹且创建cfg文件</li>
</ol>
<pre><code class="language-bash">mkdir data
cd conf
# zookeeper默认读取zoo.cfg的配置文件信息
cp zoo_sample.cfg zoo.cfg
</code></pre>
<ol start="4">
<li>修改zoo.cfg data目录</li>
</ol>
<pre><code class="language-bash">dataDir=/usr/local/zookeeper-3.5.8/data
# zk服务器默认8080端口,为防止端口占用,增加serverPort配置
admin.serverPort=6666
</code></pre>
<ol start="5">
<li>到bin目录启动zookeeper</li>
</ol>
<pre><code class="language-bash">./zkServer.sh start
</code></pre>
<ol start="6">
<li>查看zookeeper状态</li>
</ol>
<pre><code class="language-bash">./zkServer.sh status
</code></pre>
<h2 id="集群环境">集群环境</h2>
<ol>
<li>将zookeeper分别安装到三台服务器上并配置好基本信息(重复单机环境搭建过程)</li>
<li>在每个zookeeper的data目录下创建一个myid文件,内容分别是1,2,3 这个文件就是记录每个服务器的id</li>
</ol>
<pre><code class="language-bash"># 192.168.1.110 服务器
echo 1 &gt; myid 
# 192.168.1.111 服务器
echo 2 &gt; myid 
# 192.168.1.112 服务器
echo 3 &gt; myid 
</code></pre>
<ol start="3">
<li>在每一个zookeeper的zoo.cfg配置客户端访问端口和集群服务器ip列表</li>
</ol>
<pre><code class="language-bash"># server.服务器id=服务器ip地址:服务器之间通信端口:服务器之间投票选举端口
server.1=192.168.1.110:2181:3881
server.2=192.168.1.111:2181:3881
server.3=192.168.1.112:2181:3881
</code></pre>
<ol start="4">
<li>启动集群<br>
依次启动三个zk实例,其中有一个leader和两个follower</li>
<li>通过<code>./zkServer.sh status</code>命令可以查看当前zk是 leader 还是 follower</li>
<li>可以通过<code>./zkServer.sh stop</code>命令停止zk服务来测试zk的选举模式</li>
</ol>
<h1 id="zookeeper基本使用">zookeeper基本使用</h1>
<h2 id="数据结构-2">数据结构</h2>
<p>zookeeper数据模型的结构与Unix文件系统很类似,整体上可以看作是一棵树,每个节点称作一个ZNode,每个ZNode都可以通过其路径唯一标识. 如图示<br>
<img src="http://blog.ludangxin.club/post-images/1590297680104.jpg" alt="" loading="lazy"><br>
ZNode节点类型</p>
<ul>
<li>持久化目录节点(PERSISTENT)<br>
客户端与zookeeper断开连接后,该节点依旧存在</li>
<li>持久化顺序编号目录节点(PERSISTENT_SEQUENTIAL)<br>
客户端与zookeeper断开连接后,该节点依旧存在,zookeeper会给该节点按照顺序编号</li>
<li>临时目录节点(EPHEMERAL)<br>
客户端与zookeeper断开连接后,该节点被删除</li>
<li>临时顺序编号目录节点(EPHEMERAL_SEQUENTIAL)<br>
客户端与zookeeper断开连接后,该节点被删除,zookeeper会给该节点按照顺序编号</li>
</ul>
<h2 id="命令行使用">命令行使用</h2>
<ol>
<li>在zookeeper bin目录中输入 <code>./zkCli.sh</code> 进入客户端</li>
<li>输入help查看相关命令操作,结果如下<br>
<img src="http://blog.ludangxin.club/post-images/1590297708595.jpg" alt="" loading="lazy"><br>
常用命令讲解:</li>
</ol>
<h2 id="节点目录操作">节点目录操作</h2>
<ol>
<li>使用ls命令来查看当前znode中锁包含的内容</li>
</ol>
<pre><code class="language-bash"># ls [-s] [-w] [-R] path
[zk: localhost:2181(CONNECTED) 3] ls /
[ludangxin, zookeeper]
</code></pre>
<ol start="2">
<li>使用ls2查看当前节点数据并能看到更新次数等数据</li>
</ol>
<pre><code class="language-bash"># ls2 path [watch] 官方不推荐直接使用ls2查看, 使用 ls -s path 效果一样
[zk: localhost:2181(CONNECTED) 4] ls2 /
'ls2' has been deprecated. Please use 'ls [-s] path' instead.
[ludangxin, zookeeper]
cZxid = 0x0
ctime = Thu Jan 01 00:00:00 UTC 1970
mZxid = 0x0
mtime = Thu Jan 01 00:00:00 UTC 1970
pZxid = 0x2
cversion = 0
dataVersion = 0
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 0
numChildren = 2
</code></pre>
<ol start="3">
<li>使用create创建节点  -s 含有序列  -e 临时</li>
</ol>
<pre><code class="language-bash"># create [-s] [-e] [-c] [-t ttl] path [data] [acl]
# zk客户端不能递归创建目录,只能一级一级创建
[zk: localhost:2181(CONNECTED) 6] create /ludangxin/app1
Created /ludangxin/app1
</code></pre>
<ol start="4">
<li>使用set设置节点值</li>
</ol>
<pre><code class="language-bash"># set [-s] [-v version] path data
[zk: localhost:2181(CONNECTED) 8] set /ludangxin/app1 helloworld
</code></pre>
<ol start="5">
<li>使用get获得节点的值</li>
</ol>
<pre><code class="language-bash"># get [-s] [-w] path 
[zk: localhost:2181(CONNECTED) 9] get /ludangxin/app1
helloworld
</code></pre>
<ol start="6">
<li>使用stat查看节点状态</li>
</ol>
<pre><code class="language-bash"># stat [-w] path
[zk: localhost:2181(CONNECTED) 1] stat /ludangxin/app1
cZxid = 0x3
ctime = Sat May 23 13:03:07 UTC 2020
mZxid = 0x4
mtime = Sat May 23 13:05:56 UTC 2020
pZxid = 0x3
cversion = 0
dataVersion = 1
aclVersion = 0
ephemeralOwner = 0x0
dataLength = 10
numChildren = 0
</code></pre>
<ol start="7">
<li>使用delete删除节点</li>
</ol>
<pre><code class="language-bash"># delete [-v version] path
# delete不能递归删除目录,只能一级一级删除
[zk: localhost:2181(CONNECTED) 3] delete /ludangxin/app1
</code></pre>
<ol start="8">
<li>使用rmr或deleteall递归删除节点</li>
</ol>
<pre><code class="language-bash"># rmr path 官方不推荐使用rmr 推荐使用deleteall
[zk: localhost:2181(CONNECTED) 4] create /ludangxin/app1
Created /ludangxin/app1
[zk: localhost:2181(CONNECTED) 5] create /ludangxin/app1/test1
Created /ludangxin/app1/test1
[zk: localhost:2181(CONNECTED) 7] rmr /ludangxin
The command 'rmr' has been deprecated. Please use 'deleteall' instead.
[zk: localhost:2181(CONNECTED) 8] ls /ludangxin
Node does not exist: /ludangxin
[zk: localhost:2181(CONNECTED) 9] ls /
[zookeeper]
</code></pre>
<h2 id="监听操作">监听操作</h2>
<p><strong>监听只能监听一次,触发后就销毁了</strong></p>
<ol>
<li>使用ls创建监听</li>
</ol>
<pre><code class="language-bash"># ls -w path 当监听的节点包括他的子节点发目录发生变化的时候才触发监听
# 例:当前监听 /a/b 如果删除b节点,或者创建 /a/b/c 的时候会触发监听且只能触发一次
[zk: localhost:2181(CONNECTED) 15] ls -w  /ludangxin/app1
[]
[zk: localhost:2181(CONNECTED) 16] set /ludangxin/app1 helloworld
[zk: localhost:2181(CONNECTED) 17] create /ludangxin/app1/testwatch
Created /ludangxin/app1/testwatch
WATCHER::
WatchedEvent state:SyncConnected type:NodeChildrenChanged path:/ludangxin/app1
</code></pre>
<ol start="2">
<li>使用get创建监听(只能当前节点监听节点值的变化)</li>
</ol>
<pre><code class="language-bash"># get -w path
get -w /ludangxin/app1
</code></pre>
<ol start="3">
<li>使用stat创建监听(当 当前节点的状态发生改变的时候触发)</li>
</ol>
<pre><code class="language-bash"># stat -w path
stat -w /ludangxin/app1
</code></pre>
<h1 id="zookeeper-api使用">zookeeper api使用</h1>
<h2 id="引入依赖">引入依赖</h2>
<p><strong>注</strong>: 引入依赖的版本最好和安装的zk服务的版本一致</p>
<pre><code class="language-xml">&lt;!-- zookeeper --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
    &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
    &lt;version&gt;3.5.8&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- lombok --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
    &lt;artifactId&gt;lombok&lt;/artifactId&gt;
    &lt;optional&gt;true&lt;/optional&gt;
&lt;/dependency&gt;
</code></pre>
<h2 id="创建测试类">创建测试类</h2>
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.apache.zookeeper.*;
import org.apache.zookeeper.data.Stat;
import org.junit.jupiter.api.Test;
import java.io.IOException;
import java.util.List;

@Slf4j
public class ZkApiTest {

    public static final String URL = &quot;192.168.128.130:2181&quot;;

    public static final int SESSION_TIME_OUT = 20000;

    @Test
    public void test() throws IOException, KeeperException, InterruptedException {
        //1. 创建zookeeper连接
        ZooKeeper zooKeeper = new ZooKeeper(URL,SESSION_TIME_OUT, watch -&gt;
                log.info(&quot;触发了&quot;+ watch.getType() +&quot;事件&quot;)
        );
        //2. 创建父节点
        //Ids.OPEN_ACL_UNSAFE 无权限 CreateMode.PERSISTENT 持久化节点
        String testParentPath = zooKeeper.create(&quot;/testPath1&quot;, &quot;testParentValue&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        log.info(&quot;testParentPath===&quot;+testParentPath);
        //3. 创建子节点
        String testChildPath = zooKeeper.create(testParentPath+&quot;/child1&quot;, &quot;testChildValue&quot;.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        log.info(&quot;testChildPath===&quot;+testChildPath);
        //4. 获取节点中的值(父节点和子节点)
        byte[] parentData = zooKeeper.getData(testParentPath, false, null);
        byte[] childData = zooKeeper.getData(testChildPath, false, null);
        List&lt;String&gt; childrenNodes = zooKeeper.getChildren(testParentPath, false);
        log.info(&quot;parentData===&quot;+new String(parentData));
        log.info(&quot;childData===&quot;+new String(childData));
        for (String childrenNode : childrenNodes) {
            log.info(&quot;childrenNode===&quot;+childrenNode);
        }
        //5. 修改节点的值
        //version 节点版本 -1 匹配任何版本
        zooKeeper.setData(testParentPath, &quot;testValueUpdate&quot;.getBytes(), -1);
        byte[] parentNewData = zooKeeper.getData(testParentPath, false, null);
        log.info(&quot;parentNewData===&quot;+new String(parentNewData));
        //6. 判断某个节点是否存在
        Stat exists = zooKeeper.exists(testChildPath, false);
        log.info(exists.toString());
        //7. 删除节点
        zooKeeper.delete(testChildPath,-1);
    }
}
</code></pre>
<h2 id="输出结果">输出结果</h2>
<pre><code class="language-java">23:37:36.574 [main-EventThread] INFO com.ldx.springboot.ZkApiTest - 触发了None事件
23:37:36.581 [main] INFO com.ldx.springboot.ZkApiTest - testParentPath===/testPath1
23:37:36.585 [main] INFO com.ldx.springboot.ZkApiTest - testChildPath===/testPath1/child1
23:37:36.595 [main] INFO com.ldx.springboot.ZkApiTest - parentData===testParentValue
23:37:36.595 [main] INFO com.ldx.springboot.ZkApiTest - childData===testChildValue
23:37:36.595 [main] INFO com.ldx.springboot.ZkApiTest - childrenNode===child1
23:37:36.603 [main] INFO com.ldx.springboot.ZkApiTest - parentNewData===testValueUpdate
23:37:36.606 [main] INFO com.ldx.springboot.ZkApiTest - 111,111,1590248257090,1590248257090,0,0,0,0,14,0,111
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈 分布式 集群 微服务]]></title>
        <id>http://blog.ludangxin.club/post/fen-bu-shi-ji-qun-wei-fu-wu/</id>
        <link href="http://blog.ludangxin.club/post/fen-bu-shi-ji-qun-wei-fu-wu/">
        </link>
        <updated>2020-05-23T05:46:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="概念">概念</h1>
<p><strong>集群是个物理形态，分布式是系统部署方式，微服务是架构设计方式。</strong></p>
<h2 id="集群是啥">集群是啥?</h2>
<p>单机处理到达瓶颈的时候，你就把单机复制几份，这样就构成了一个“集群”。集群中每台服务器就叫做这个集群的一个“节点”，所有节点构成了一个集群。每个节点都提供相同的服务，那么这样系统的处理能力就相当于提升了好几倍（有几个节点就相当于提升了这么多倍）。从单机结构到集群结构，你的代码基本无需要作任何修改。你要做的仅仅是多部署几台服务器，每台服务器上运行相同的代码就行了。</p>
<h2 id="分布式是啥">分布式是啥？</h2>
<p>分布式服务顾名思义服务是分散部署在不同的机器上的，一个服务可能负责几个功能，是一种面向SOA架构的，服务之间也是通过rpc来交互或者是webservice来交互的。逻辑架构设计完后就该做物理架构设计，系统应用部署在超过一台服务器或虚拟机上，且各分开部署的部分彼此通过各种通讯协议交互信息，就可算作分布式部署，生产环境下的微服务肯定是分布式部署的，分布式部署的应用不一定是微服务架构的，比如集群部署，它是把相同应用复制到不同服务器上，但是逻辑功能上还是单体应用。</p>
<h2 id="微服务又是啥">微服务又是啥?</h2>
<p>简单来说微服务就是很小的服务，小到一个服务只对应一个单一的功能，只做一件事。<br>
这个服务可以单独部署运行，服务之间可以通过RPC来相互交互，每个微服务都是由独立的小团队开发，测试，部署，上线，负责它的整个生命周期。</p>
<h2 id="微服务架构又又是啥">微服务架构又又是啥？</h2>
<p>在做架构设计的时候，先做逻辑架构，再做物理架构，当你拿到需求后，估算过最大用户量和并发量后，计算单个应用服务器能否满足需求。<br>
如果用户量只有几百人的小应用，单体应用就能搞定，即所有应用部署在一个应用服务器里，如果是很大用户量，且某些功能会被频繁访问，或者某些功能计算量很大，建议将应用拆解为多个子系统，各自负责各自功能，这就是微服务架构。</p>
<h2 id="区别">区别</h2>
<ol>
<li>
<p>分布式是指将不同的业务分布在不同的地方。</p>
</li>
<li>
<p>集群指的是将几台服务器集中在一起，实现同一业务。<br>
简单说，分布式是以缩短单个任务的执行时间来提升效率的，而集群则是通过提高单位时间内执行的任务数来提升效率。</p>
</li>
<li>
<p>微服务与分布式的细微差别是，微服务的应用不一定是分散在多个服务器上，他也可以是同一个服务器。微服务相比分布式服务来说，它的粒度更小，服务之间耦合度更低，由于每个微服务都由独立的小团队负责，因此它敏捷性更高，分布式服务最后都会向微服务架构演化，这是一种趋势， 不过服务微服务化后带来的挑战也是显而易见的，例如服务粒度小，数量大，后期运维将会很难</p>
</li>
</ol>
<p>图示:</p>
<figure data-type="image" tabindex="1"><img src="http://blog.ludangxin.club/post-images/1590216688867.jpg" alt="" loading="lazy"></figure>
<h1 id="架构的演变过程">架构的演变过程</h1>
<p>下面我们来简单模拟一个架构演变过程。 我们以 javaweb 为例，来搭建一个简单的电商系统，从这个系统中来看系统的演变过程。要注意的是接下来的演示模型， 关注的是数据量、访问量提升，网站结构的变化， 而不关注具体业务的功能点。其次，这个过程是为了让大家能更好的了解网站演进过程中的一些问题和应对策略。</p>
<p>假如我们系统具备以下功能:</p>
<ul>
<li>用户模块:用户注册和管理。</li>
<li>商品模块:商品展示和管理。</li>
<li>交易模块:创建交易及支付结算。</li>
</ul>
<h2 id="阶段一单应用架构">阶段一：单应用架构</h2>
<p><img src="http://blog.ludangxin.club/post-images/1590216730582.jpg" alt="" loading="lazy"><br>
　　这个阶段是网站的初期，也可以认为是互联网发展的早期，系统架构如上图所示。我们经常会在单台服务器上运行我们所有的程序和软件。 把所有软件和应用都部署在一台机器上，这样就完成一个简单系统的搭建，这个阶段的讲究的是效率。效率决定生死。</p>
<h2 id="阶段二应用服务器和数据库服务器分离">阶段二：应用服务器和数据库服务器分离</h2>
<p>随着网站的上线，访问量逐步上升，服务器的负载慢慢提高，我们应该在服务器还没有超载的时候就做好规划、提升网站的负载能力。假若此时已经没办法在代码层面继续优化提高，那么在单台机器的性能遇到瓶颈的时候，增加机器是一个比较简单好用的方式，投入产出比相当高。这个阶段增加机器的主要目的是将 web 服务器和 数据库服务器拆分开来，这样做的话不仅提高了单机的负载能力，也提高了整个系统的容灾能力。<br>
<img src="http://blog.ludangxin.club/post-images/1590216749619.jpg" alt="" loading="lazy"><br>
　　这个阶段的系统架构如上图所示，应用服务器和数据库服务器完全隔离开来，相互互不影响，大大减少了网站宕机的风险，此阶段我们已经开始关注到应用服务器的管理了。</p>
<h2 id="阶段三应用服务器集群">阶段三：应用服务器集群</h2>
<p>这个阶段，随着访问量的继续不断增加，单台应用服务器已经无法满足我们的需求。 假设我的数据库服务器还没有遇到性能问题，那我们可以通过增加应用服务器的方式来将应用服务器集群化，这样就可以将用户请求分流到各个服务器中，从而达到继续提升系统负载能力的目的。此时各个应用服务器之间没有直接的交互，他们都是依赖数据库各自对外提供服务。<br>
<img src="http://blog.ludangxin.club/post-images/1590216760176.jpg" alt="" loading="lazy"><br>
系统架构发展到这个阶段，各种问题也会接踵而至：</p>
<ul>
<li>用户请求交由谁来转发到具体的应用服务器上(谁来负责负载均衡)</li>
<li>用户如果每次访问到的服务器不一样，那么如何维护session，达到session共享的目的。<br>
那么此时，系统架构又会变成如下方式：<br>
<img src="http://blog.ludangxin.club/post-images/1590216771958.jpg" alt="" loading="lazy"><br>
　　负载均衡又可以分为软负载和硬负载。软负载我们可以选择Nginx、Apache等，硬负载我们可以选择F5等。而session共享问题我们可以通过配置tomcat的session共享解决。</li>
</ul>
<h2 id="阶段四数据库压力变大数据库读写分离">阶段四：数据库压力变大，数据库读写分离</h2>
<p>架构演变到上面的阶段，并不是终点。通过上面的设计，应用层的性能被我们拉上来了， 但数据库的负载也在逐渐增大，那如何去提高数据库层面的性能呢？有了前面的设计思路以后，我们自然也会想到通过增加服务器来提高性能。但假如我们单纯的把数据库一分为二，然后对于数据库的请求，分别负载到两台数据库服务器上，那必定会造成数据库数据不统一的问题。 所以我们一般先考虑将数据库读写分离。<br>
<img src="http://blog.ludangxin.club/post-images/1590216784417.jpg" alt="" loading="lazy"><br>
这个架构设计的变化会带来如下几个问题：</p>
<ul>
<li>主从数据库之间的数据需要同步(可以使用 mysql 自带的 master-slave 方式实现主从复制 )</li>
<li>应用中需要根据业务进行对应数据源的选择( 采用第三方数据库中间件，例如 mycat )</li>
</ul>
<h2 id="阶段五使用搜索引擎缓解读库的压力">阶段五：使用搜索引擎缓解读库的压力</h2>
<p>我们都知道数据库常常对模糊查找效率不是很高，像电商类的网站，搜索是非常核心的功能，即使是做了读写分离，这个问题也不能得到有效解决。那么这个时候我们就需要引入搜索引擎了，使用搜索引擎能够大大提升我们系统的查询速度，但同时也会带来一 些附加的问题，比如维护索引的构建、数据同步到搜索引擎等。<br>
<img src="http://blog.ludangxin.club/post-images/1590216793033.jpg" alt="" loading="lazy"></p>
<h2 id="阶段六引入缓存机制缓解数据库的压力">阶段六：引入缓存机制缓解数据库的压力</h2>
<p>然后，随着访问量的持续不断增加，逐渐会出现许多用户访问同一内容的情况，那么对于这些热点数据，没必要每次都从数据库重读取，这时我们可以使用到缓存技术，比如 redis、memcache 来作为我们应用层的缓存。另外在某些场景下，如我们对用户的某些 IP 的访问频率做限制， 那这个放内存中就又不合适，放数据库又太麻烦了，那这个时候可以使用 Nosql 的方式比如 mongDB 来代替传统的关系型数据库。<br>
<img src="http://blog.ludangxin.club/post-images/1590216802188.jpg" alt="" loading="lazy"></p>
<h2 id="阶段七数据库的水平垂直拆分">阶段七：数据库的水平/垂直拆分</h2>
<p>我们的网站演进的变化过程，交易、商品、用户的数据都还在同一 个数据库中，尽管采取了增加缓存，读写分离的方式，但是随着数 据库的压力持续增加，数据库的瓶颈仍然是个最大的问题。因此我 们可以考虑对数据的垂直拆分和水平拆分。<br>
<img src="http://blog.ludangxin.club/post-images/1590216810460.jpg" alt="" loading="lazy"><br>
垂直拆分:把数据库中不同业务数据拆分到不同的数据库。<br>
水平拆分:把同一个表中的数据拆分到两个甚至更多的数据库中，水平拆分的原因是某些业务数据量已经达到了单个数据库的瓶颈，这时可以采取将表拆分到多个数据库中。<br>
<img src="http://blog.ludangxin.club/post-images/1590216821835.jpg" alt="" loading="lazy"></p>
<h2 id="阶段八应用的拆分">阶段八：应用的拆分</h2>
<p>随着业务的发展，业务量越来越大，应用的压力越来越大。工程规模也越来越庞大。这个时候就可以考虑将应用拆分，按照领域模型将我们的用户、商品、交易拆分成多个子系统。<br>
<img src="http://blog.ludangxin.club/post-images/1590216830257.jpg" alt="" loading="lazy"><br>
　　这样拆分以后，可能会有一些相同的代码，比如用户操作，在商品和交易都需要查询，所以会导致每个系统都会有用户查询访问相关操作。这些相同的操作一定是要抽象出来，否则就是一个坑。所以通过走服务化路线的方式来解决。<br>
<img src="http://blog.ludangxin.club/post-images/1590216837471.jpg" alt="" loading="lazy"><br>
　　那么服务拆分以后，各个服务之间如何进行远程通信呢? 通过 RPC 技术，比较典型的有:dubbo、webservice、hessian、http、RMI 等等。前期通过这些技术能够很好的解决各个服务之间通信问题，但是， 互联网的发展是持续的，所以架构的演变和优化也还在持续。</p>
<p>转自:<a href="https://www.cnblogs.com/zhy-1992/">领悟.海洋-分布式架构的总结</a></p>
<h1 id="cap理论概述">CAP理论概述</h1>
<p><strong>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项</strong>。<br>
<img src="http://blog.ludangxin.club/post-images/1590304044178.jpg" alt="" loading="lazy"></p>
<h2 id="cap的定义">CAP的定义</h2>
<h3 id="consistency-一致性">Consistency 一致性</h3>
<p>一致性指“<code>all nodes see the same data at the same time</code>”，即所有节点在同一时间的数据完全一致。<br>
一致性是因为多个数据拷贝下并发读写才有的问题，因此理解时一定要注意结合考虑多个数据拷贝下并发读写的场景。<br>
对于一致性，可以分为从客户端和服务端两个不同的视角。</p>
<ul>
<li>客户端<br>
从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。</li>
<li>服务端<br>
从服务端来看，则是更新如何分布到整个系统，以保证数据最终一致。<br>
对于一致性，可以分为强/弱/最终一致性三类<br>
从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。</li>
<li>强一致性<br>
对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是强一致性。</li>
<li>弱一致性<br>
如果能容忍后续的部分或者全部访问不到，则是弱一致性。</li>
<li>最终一致性<br>
如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</li>
</ul>
<h3 id="availability-可用性">Availability 可用性</h3>
<p>可用性指“<code>Reads and writes always succeed</code>”，即服务在正常响应时间内一直可用。<br>
好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。</p>
<h3 id="partition-tolerance分区容错性">Partition Tolerance分区容错性</h3>
<p>分区容错性指“<code>the system continues to operate despite arbitrary message loss or failure of part of the system</code>”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性或可用性的服务。</p>
<h2 id="cap的证明">CAP的证明</h2>
<p><img src="http://blog.ludangxin.club/post-images/1590304055359.jpg" alt="" loading="lazy"><br>
上图是我们证明CAP的基本场景，网络中有两个节点N1和N2，可以简单的理解N1和N2分别是两台计算机，他们之间网络可以连通，N1中有一个应用程序A，和一个数据库V，N2也有一个应用程序B2和一个数据库V。现在，A和B是分布式系统的两个部分，V是分布式系统的数据存储的两个子数据库。</p>
<p>在满足一致性的时候，N1和N2中的数据是一样的，V0=V0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。<br>
<img src="http://blog.ludangxin.club/post-images/1590304064859.jpg" alt="" loading="lazy"><br>
上图是分布式系统正常运转的流程，用户向N1机器请求数据更新，程序A更新数据库Vo为V1，分布式系统将数据进行同步操作M，将V1同步的N2中V0，使得N2中的数据V0也更新为V1，N2中的数据再响应N2的请求。</p>
<p>这里，可以定义N1和N2的数据库V之间的数据是否一样为一致性；外部对N1和N2的请求响应为可用性；N1和N2之间的网络环境为分区容错性。</p>
<p>这是正常运作的场景，也是理想的场景，然而现实是残酷的，当错误发生的时候，一致性和可用性还有分区容错性，是否能同时满足，还是说要进行取舍呢？</p>
<p>作为一个分布式系统，它和单机系统的最大区别，就在于网络，现在假设一种极端情况，N1和N2之间的网络断开了，我们要支持这种网络异常，相当于要满足分区容错性，能不能同时满足一致性和响应性呢？还是说要对他们进行取舍。<br>
<img src="http://blog.ludangxin.club/post-images/1590304075502.jpg" alt="" loading="lazy"><br>
假设在N1和N2之间网络断开的时候，有用户向N1发送数据更新请求，那N1中的数据V0将被更新为V1，由于网络是断开的，所以分布式系统同步操作M，所以N2中的数据依旧是V0；这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据V1，怎么办呢？</p>
<p>有二种选择，第一，牺牲数据一致性，响应旧的数据V0给用户；第二，牺牲可用性，阻塞等待，直到网络连接恢复，数据更新操作M完成之后，再给用户响应最新的数据V1。</p>
<p>这个过程，证明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。</p>
<h2 id="cap权衡">CAP权衡</h2>
<p>通过CAP理论，我们知道无法同时满足一致性、可用性和分区容错性这三个特性，那要舍弃哪个呢？</p>
<blockquote>
<p>CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但其实分区不是你想不想的问题，而是始终会存在，因此CA的系统更多的是允许分区后各子系统依然保持CA。<br>
CP without A：如果不要求A（可用），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的。很多传统的数据库分布式事务都属于这种模式。<br>
AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。现在众多的NoSQL都属于此类。</p>
</blockquote>
<p>对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，所以节点故障、网络故障是常态，而且要保证服务可用性达到N个9，即保证P和A，舍弃C（退而求其次保证最终一致性）。虽然某些地方会影响客户体验，但没达到造成用户流程的严重程度。</p>
<p>对于涉及到钱财这样不能有一丝让步的场景，C必须保证。网络发生故障宁可停止服务，这是保证CA，舍弃P。貌似这几年国内银行业发生了不下10起事故，但影响面不大，报道也不多，广大群众知道的少。还有一种是保证CP，舍弃A。例如网络故障事只读不写。</p>
<p>孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringBoot 集成 表单验证 和 异常统一处理]]></title>
        <id>http://blog.ludangxin.club/post/springboot-ji-cheng-biao-dan-yan-zheng-he-yi-chang-tong-yi-chu-li/</id>
        <link href="http://blog.ludangxin.club/post/springboot-ji-cheng-biao-dan-yan-zheng-he-yi-chang-tong-yi-chu-li/">
        </link>
        <updated>2020-05-20T13:18:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="表单验证注解清单">表单验证注解清单</h1>
<table>
<thead>
<tr>
<th style="text-align:center">注解</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">@Null</td>
<td style="text-align:center">限制只能为null</td>
</tr>
<tr>
<td style="text-align:center">@NotNull</td>
<td style="text-align:center">限制必须不为null</td>
</tr>
<tr>
<td style="text-align:center">@AssertFalse</td>
<td style="text-align:center">限制必须为false</td>
</tr>
<tr>
<td style="text-align:center">@AssertTrue</td>
<td style="text-align:center">限制必须为true</td>
</tr>
<tr>
<td style="text-align:center">@DecimalMax(value)</td>
<td style="text-align:center">限制必须为一个不大于指定值的数字</td>
</tr>
<tr>
<td style="text-align:center">@DecimalMin(value)</td>
<td style="text-align:center">限制必须为一个不小于指定值的数字</td>
</tr>
<tr>
<td style="text-align:center">@Digits(integer,fraction)</td>
<td style="text-align:center">限制必须为一个小数，且整数部分的位数不能超过integer，小数部分的位数不能超过fraction</td>
</tr>
<tr>
<td style="text-align:center">@Future</td>
<td style="text-align:center">限制必须是一个将来的日期</td>
</tr>
<tr>
<td style="text-align:center">@Max(value)</td>
<td style="text-align:center">限制必须为一个不大于指定值的数字</td>
</tr>
<tr>
<td style="text-align:center">@Min(value)</td>
<td style="text-align:center">限制必须为一个不小于指定值的数字</td>
</tr>
<tr>
<td style="text-align:center">@Past</td>
<td style="text-align:center">限制必须是一个过去的日期</td>
</tr>
<tr>
<td style="text-align:center">@Pattern(value)</td>
<td style="text-align:center">限制必须符合指定的正则表达式</td>
</tr>
<tr>
<td style="text-align:center">@Size(max,min)</td>
<td style="text-align:center">限制字符长度必须在min到max之间</td>
</tr>
<tr>
<td style="text-align:center">@Past</td>
<td style="text-align:center">验证注解的元素值（日期类型）比当前时间早</td>
</tr>
<tr>
<td style="text-align:center">@NotEmpty</td>
<td style="text-align:center">验证注解的元素值不为null且不为空（字符串长度不为0、集合大小不为0）</td>
</tr>
<tr>
<td style="text-align:center">@NotBlank</td>
<td style="text-align:center">验证注解的元素值不为空（不为null、去除首位空格后长度为0），不同于@NotEmpty，@NotBlank</td>
</tr>
<tr>
<td style="text-align:center">@Email</td>
<td style="text-align:center">验证注解的元素值是Email，也可以通过正则表达式和flag指定自定义的email格式</td>
</tr>
</tbody>
</table>
<h1 id="项目结构图示">项目结构图示</h1>
<figure data-type="image" tabindex="1"><img src="http://blog.ludangxin.club/post-images/1589985070594.jpg" alt="" loading="lazy"></figure>
<h1 id="引入所需依赖">引入所需依赖</h1>
<pre><code class="language-xml">        &lt;!-- SpringBoot Web容器 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 表单验证 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- lombok --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
</code></pre>
<h1 id="创建validator配置类">创建Validator配置类</h1>
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.hibernate.validator.HibernateValidator;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.validation.beanvalidation.MethodValidationPostProcessor;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;

/**
 * 配置 Hibernate 参数校验
 * @author ludangxin
 */
@Slf4j
@Configuration
@EnableAutoConfiguration
public class ValidatorConfig {
    @Bean
    public MethodValidationPostProcessor methodValidationPostProcessor() {
        MethodValidationPostProcessor postProcessor = new MethodValidationPostProcessor();
        //快速校验，只要有错马上返回
        postProcessor.setValidator(validator());
        return postProcessor;
    }

    @Bean
    public Validator validator(){
        ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
                .configure()
                .addProperty( &quot;hibernate.validator.fail_fast&quot;, &quot;true&quot; )
                .buildValidatorFactory();
        Validator validator = validatorFactory.getValidator();
        return validator;
    }
}
</code></pre>
<h1 id="创建实体类">创建实体类</h1>
<p>这里着重讲一下注解中groups是用来干什么的?</p>
<pre><code class="language-wiki">  因为一个实体不可能只干一种操作,一个实体必然存在增删改查操作,那么问题就来了
  如果我要根据id进行更新操作,那么id肯定不能为空
  这时候我还要进行新增操作,因为id是新增数据库操作才产生的,接受数据的时候我肯定是没有id的
  所以就产生矛盾了
  那么groups这个参数就起作用了,它可以表示我这个注解属于哪个组,这样就解决这个尴尬的问题了.
</code></pre>
<p><strong>注</strong>: 当在controller中校验表单数据时,如果使用了groups,那么没有在这个分组下的属性是不会校验的</p>
<pre><code class="language-java">import lombok.*;
import javax.validation.constraints.*;
import java.io.Serializable;

/**
 * 用户信息管理
 * @Author: ludangxin
 * @Date: 2020/5/20 16:09
 */
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class SysUser  implements Serializable {

    private static final long serialVersionUID = 1L;
    /**
     * 主键
     */
    @NotNull(message = &quot;id不能为空&quot;,groups = {ValidationInterface.update.class})
    private Long id;

    /**
     * 用户名
     */
    @NotEmpty(message = &quot;用户名称不能为空&quot;
            , groups = {ValidationInterface.update.class,ValidationInterface.add.class})
    private String username;

    /**
     * 密码
     */
    @Size(min = 6, max = 16, message = &quot;密码长度必须在6-16之间&quot;
            , groups = {ValidationInterface.update.class,ValidationInterface.add.class})
    private String password;

    /**
     * 邮箱地址
     */
    @Email(message = &quot;邮箱地址不合法&quot;
            , groups = {ValidationInterface.update.class,ValidationInterface.add.class
                      , ValidationInterface.select.class})
    @NotEmpty(message = &quot;邮箱不能为空&quot;,groups = ValidationInterface.add.class)
    private String email;

    /**
     * 电话
     */
    @Size(min = 11, max = 11, message = &quot;手机号不合法&quot;
                , groups = {ValidationInterface.update.class, ValidationInterface.add.class
                          , ValidationInterface.select.class})
    @NotEmpty(message = &quot;手机号不能为空&quot;,groups = {ValidationInterface.add.class})
    private String phone;
}
</code></pre>
<h1 id="创建表单验证的通用分组接口">创建表单验证的通用分组接口</h1>
<pre><code class="language-wiki"> 如果还有其它特殊的分组要求 直接在BO中创建interface即可
 例:如果还有个需要验证username 和 password(只有这两个参数) 的 select操作
 直接在SysUser中创建UsernamePasswordValidView 的接口即可
</code></pre>
<pre><code class="language-java">/**
 * 用于表单验证的通用分组接口
 * @Author: ludangxin
 * @Date: 2020/5/20 17:07
 */
public interface ValidationInterface {

    /**
     * 新增分组
     */
    interface add{}

    /**
     * 删除分组
     */
    interface delete{}

    /**
     * 查询分组
     */
    interface select{}

    /**
     * 更新分组
     */
    interface update{}
}
</code></pre>
<h1 id="创建业务异常类">创建业务异常类</h1>
<pre><code class="language-java">/**
 * 业务异常
 * @author ludangxin
 */
public class BusinessException extends RuntimeException{
    private static final long serialVersionUID = 1L;

    protected final String message;

    public BusinessException(String message)
    {
        this.message = message;
    }

    public BusinessException(String message, Throwable e)
    {
        super(message, e);
        this.message = message;
    }

    @Override
    public String getMessage()
    {
        return message;
    }
}
</code></pre>
<h1 id="创建全局异常处理器">创建全局异常处理器</h1>
<pre><code class="language-java">import com.ldx.springboot.util.AjaxResult;
import lombok.extern.slf4j.Slf4j;
import org.springframework.validation.BindException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import javax.servlet.http.HttpServletRequest;
import javax.validation.ConstraintViolation;
import javax.validation.ConstraintViolationException;
import javax.validation.ValidationException;
import java.util.Set;

/**
 * 全局异常处理器
 * 
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /**
     * 参数绑定异常类 用于表单验证时抛出的异常处理
     */
    @ExceptionHandler(BindException.class)
    public AjaxResult validatedBindException(BindException e){
        log.error(e.getMessage(), e);
        String message = &quot;[&quot; + e.getAllErrors().get(0).getDefaultMessage() + &quot;]&quot;;
        return AjaxResult.error(message);
    }

    /**
     * 参数绑定异常类 用于Json数据绑定验证时抛出的异常处理
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public AjaxResult methodArgumentNotValidException(MethodArgumentNotValidException e){
        log.error(e.getMessage(), e);
        String message = &quot;[&quot; + e.getBindingResult().getAllErrors().get(0).getDefaultMessage() + &quot;]&quot;;
        return AjaxResult.error(message);
    }

    /**
     * 参数绑定异常类  用于方法形参中参数校验时抛出的异常处理
     * @param e
     * @return
     */
    @ExceptionHandler(ConstraintViolationException.class)
    public AjaxResult handle(ValidationException e) {
        log.error(e.getMessage(), e);
        String errorInfo = &quot;&quot;;
        if(e instanceof ConstraintViolationException){
            ConstraintViolationException exs = (ConstraintViolationException) e;
            Set&lt;ConstraintViolation&lt;?&gt;&gt; violations = exs.getConstraintViolations();
            for (ConstraintViolation&lt;?&gt; item : violations) {
                errorInfo = errorInfo + &quot;[&quot; + item.getMessage() + &quot;]&quot;;
            }
        }
        return AjaxResult.error(errorInfo);
    }

    /**
     * 请求方式不支持
     */
    @ExceptionHandler({ HttpRequestMethodNotSupportedException.class })
    public AjaxResult handleException(HttpRequestMethodNotSupportedException e){
        log.error(e.getMessage(), e);
        return AjaxResult.error(&quot;不支持' &quot; + e.getMethod() + &quot;'请求&quot;);
    }

    /**
     * 拦截未知的运行时异常
     */
    @ExceptionHandler(RuntimeException.class)
    public AjaxResult notFount(RuntimeException e) {
        log.error(&quot;运行时异常:&quot;, e);
        return AjaxResult.error(&quot;运行时异常:&quot; + e.getMessage());
    }

    /**
     * 系统异常
     */
    @ExceptionHandler(Exception.class)
    public AjaxResult handleException(Exception e) {
        log.error(e.getMessage(), e);
        return AjaxResult.error(&quot;服务器错误，请联系管理员&quot;);
    }

    /**
     * 业务异常
     */
    @ExceptionHandler(BusinessException.class)
    public AjaxResult businessException(HttpServletRequest request, BusinessException e) {
        log.error(e.getMessage());
        return AjaxResult.error(e.getMessage());
    }
}
</code></pre>
<h1 id="创建controller">创建controller</h1>
<pre><code class="language-wiki">类上的 @Validated 主要是为了使方法形参中的验证生效.
如果只是用实体类上的参数绑定校验,那么就不用在类上标注该注解
</code></pre>
<pre><code class="language-java">import com.ldx.springboot.exception.BusinessException;
import com.ldx.springboot.model.SysUser;
import com.ldx.springboot.model.ValidationInterface;
import com.ldx.springboot.util.AjaxResult;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;
import javax.validation.constraints.Email;
import javax.validation.constraints.NotEmpty;

@RequestMapping(&quot;sysuser&quot;)
@RestController
@Validated
public class SysUserController {

    /**
     * 根据手机号和邮箱查询用户信息
     * @param sysUser 用户信息
     * @return
     */
    @GetMapping(&quot;selectByPhoneOrEmail&quot;)
    public AjaxResult selectByPhoneOrEmail(@Validated(value = ValidationInterface.select.class) SysUser sysUser){
        return AjaxResult.success(&quot;查询成功&quot;);
    }

    /**
     * 根据手机号和邮箱查询用户信息
     * @param phone 手机号
     * @param email 邮箱
     * @return
     */
    @GetMapping(&quot;selectByPhoneOrEmail2&quot;)
    public AjaxResult selectByPhoneOrEmail2(@NotEmpty(message = &quot;手机号不能为空&quot;) String phone
            ,@NotEmpty(message = &quot;邮箱不能为空&quot;)@Email(message = &quot;邮箱信息不合法&quot;) String email){
        return AjaxResult.success(&quot;查询成功&quot;);
    }

    /**
     * 新增用户信息
     * @param sysUser 用户信息
     * @return
     */
    @PostMapping(&quot;add&quot;)
    public AjaxResult add(@Validated(value = ValidationInterface.add.class) SysUser sysUser){
        return AjaxResult.success(&quot;新增成功&quot;);
    }

    /**
     * 新增用户信息
     * @param sysUser 用户信息
     * @return
     */
    @PostMapping(&quot;add1&quot;)
    public AjaxResult add1(@Validated(value = ValidationInterface.add.class) @RequestBody SysUser sysUser){
        return AjaxResult.success(&quot;新增成功&quot;);
    }

    /**
     * 更具Id更新用户信息
     * @param sysUser 用户信息
     * @return
     */
    @PutMapping(&quot;updateById&quot;)
    public AjaxResult updateById(@Validated(value = ValidationInterface.update.class) SysUser sysUser){
        return AjaxResult.success(&quot;更新成功&quot;);
    }

    /**
     * 根据Id删除用户信息
     * @param id
     * @return
     */
    @DeleteMapping(&quot;deleteById/{id}&quot;)
    public AjaxResult deleteById( @PathVariable Long id){
        return AjaxResult.success(&quot;删除成功&quot;);
    }

    /**
     * 测试业务异常
     * @return
     */
    @GetMapping(&quot;testException&quot;)
    public AjaxResult testException(String name){
        if(!&quot;张三&quot;.equals(name)){
            throw new BusinessException(&quot;只有张三才可以访问&quot;);
        }
        return AjaxResult.success();
    }
}
</code></pre>
<h1 id="创建操作消息提醒类">创建操作消息提醒类</h1>
<pre><code class="language-java">import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * 操作消息提醒
 */
@Data
@NoArgsConstructor
public class AjaxResult {

    /**
     * 状态类型
     */
    public enum Type{
        /** 成功 */
        SUCCESS(200),
        /** 警告 */
        WARN(301),
        /** 错误 */
        ERROR(500),
        /*token失效*/
        UNAUTHORIZED(401)
        ;
        private final int value;

        Type(int value){
            this.value = value;
        }

        public int value(){
            return this.value;
        }
    }

    /** 状态码 */
    private int code;

    /** 返回内容 */
    private String msg;

    /** 数据对象 */
    private Object data;

    /**
     * 初始化一个新创建的 AjaxResult 对象
     *
     * @param type 状态类型
     * @param msg 返回内容
     */
    public AjaxResult(Type type, String msg) {
        this.code = type.value;
        this.msg = msg;
    }

    /**
     * 初始化一个新创建的 AjaxResult 对象
     *
     * @param type 状态类型
     * @param msg 返回内容
     * @param data 数据对象
     */
    public AjaxResult(Type type, String msg, Object data) {
        this.code = type.value;
        this.msg = msg;
        if (data != null)
        {
            this.data = data;
        }
    }

    /**
     * 返回成功消息
     *
     * @return 成功消息
     */
    public static AjaxResult success() {
        return AjaxResult.success(&quot;操作成功&quot;);
    }

    /**
     * 返回成功数据
     *
     * @return 成功消息
     */
    public static AjaxResult success(Object data) {
        return AjaxResult.success(&quot;操作成功&quot;, data);
    }

    /**
     * 返回成功消息
     *
     * @param msg 返回内容
     * @return 成功消息
     */
    public static AjaxResult success(String msg) {
        return AjaxResult.success(msg, null);
    }

    /**
     * 返回成功消息
     *
     * @param msg 返回内容
     * @param data 数据对象
     * @return 成功消息
     */
    public static AjaxResult success(String msg, Object data) {
        return new AjaxResult(Type.SUCCESS, msg, data);
    }

    /**
     * 返回警告消息
     *
     * @param msg 返回内容
     * @return 警告消息
     */
    public static AjaxResult warn(String msg) {
        return AjaxResult.warn(msg, null);
    }

    /**
     * 返回警告消息
     *
     * @param msg 返回内容
     * @param data 数据对象
     * @return 警告消息
     */
    public static AjaxResult warn(String msg, Object data) {
        return new AjaxResult(Type.WARN, msg, data);
    }

    /**
     * 返回错误消息
     *
     * @return
     */
    public static AjaxResult error() {
        return AjaxResult.error(&quot;操作失败&quot;);
    }

    /**
     * 返回错误消息
     *
     * @param msg 返回内容
     * @return 警告消息
     */
    public static AjaxResult error(String msg) {
        return AjaxResult.error(msg, null);
    }

    /**
     * 返回错误消息
     *
     * @param msg 返回内容
     * @param data 数据对象
     * @return 警告消息
     */
    public static AjaxResult error(String msg, Object data) {
        return new AjaxResult(Type.ERROR, msg, data);
    }

    /**
     * 返回错误消息
     *
     * @param msg 返回内容
     * @return 警告消息
     */
    public static AjaxResult unauthorized(String msg) {
        return AjaxResult.unauthorized(msg, null);
    }

    /**
     * 返回错误消息
     *
     * @param msg 返回内容
     * @param data 数据对象
     * @return 警告消息
     */
    public static AjaxResult unauthorized(String msg, Object data) {
        return new AjaxResult(Type.UNAUTHORIZED, msg, data);
    }
}
</code></pre>
<h1 id="效果演示">效果演示</h1>
<p>访问selectByPhoneOrEmail接口<br>
<img src="http://blog.ludangxin.club/post-images/1589987424474.jpg" alt="" loading="lazy"><br>
访问selectByPhoneOrEmail2接口<br>
<img src="http://blog.ludangxin.club/post-images/1589987514865.jpg" alt="" loading="lazy"><br>
访问add接口<br>
<img src="http://blog.ludangxin.club/post-images/1589987602210.jpg" alt="" loading="lazy"><br>
访问testException接口测试业务异常提示<br>
<img src="http://blog.ludangxin.club/post-images/1589987670484.jpg" alt="" loading="lazy"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx]]></title>
        <id>http://blog.ludangxin.club/post/nginx/</id>
        <link href="http://blog.ludangxin.club/post/nginx/">
        </link>
        <updated>2020-05-17T04:18:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="nginx简介">nginx简介</h1>
<h2 id="nginx概述">nginx概述</h2>
<p>Nginx (&quot;engine x&quot;) 是一个高性能的 HTTP 和反向代理服务器,特点是占有内存少，并发能<br>
力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx<br>
网站用户有：百度、京东、新浪、网易、腾讯、淘宝等</p>
<h2 id="nginx作为web服务器">nginx作为web服务器</h2>
<p>Nginx 可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 perl、php<br>
等。但是不支持 java。Java 程序只能通过与 tomcat 配合完成。Nginx 专为性能优化而开发，<br>
性能是其最重要的考量,实现上非常注重效率 ，能经受高负载的考验,有报告表明能支持高<br>
达 50,000 个并发连接数。<br>
https://lnmp.org/nginx.html</p>
<h2 id="正向代理">正向代理</h2>
<p>Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。<br>
正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访<br>
问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。<br>
<img src="https://i.loli.net/2020/04/16/LXnVcihqUCKS5FG.png" alt="image.png" loading="lazy"></p>
<h2 id="反向代理">反向代理</h2>
<p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只<br>
需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返<br>
回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器<br>
地址，隐藏了真实服务器 IP 地址。<br>
<img src="https://i.loli.net/2020/04/16/ecldAyw4K9MaufG.png" alt="image.png" loading="lazy"></p>
<h2 id="负载均衡">负载均衡</h2>
<p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。<br>
这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？<br>
我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么呢？<br>
上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的<strong>负载均衡</strong><br>
<img src="https://i.loli.net/2020/04/16/C6BqOvr3slDyTme.png" alt="image.png" loading="lazy"></p>
<h2 id="动静分离">动静分离</h2>
<p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。<br>
<img src="https://i.loli.net/2020/04/16/PbKDoymtFkT2fwn.png" alt="image.png" loading="lazy"></p>
<h1 id="nginx-安装">nginx 安装</h1>
<h2 id="素材介绍">素材介绍</h2>
<h3 id="pcre">PCRE</h3>
<p>PCRE库支持正则表达式。如果我们在配置文件nginx.conf中使用了正则表达式，那么在编译Nginx时就必须把PCRE库编译进Nginx，因为Nginx的HTTP模块需要靠它来解析正则表达式。另外，pcre-devel是使用PCRE做二次开发时所需要的开发库，包括头文件等，这也是编译Nginx所必须使用的.</p>
<h3 id="zlib">zlib</h3>
<p>zlib库用于对HTTP包的内容做gzip格式的压缩，如果我们在nginx.conf中配置了gzip on，并指定对于某些类型（content-type）的HTTP响应使用gzip来进行压缩以减少网络传输量，则在编译时就必须把zlib编译进Nginx。zlib-devel是二次开发所需要的库.</p>
<h3 id="openssl">openSSL</h3>
<p>如果服务器不只是要支持HTTP，还需要在更安全的SSL协议上传输HTTP，那么需要拥有OpenSSL。另外，如果我们想使用MD5、SHA1等散列函数，那么也需要安装它。</p>
<h3 id="nginx安装包">nginx安装包</h3>
<h2 id="开始安装">开始安装</h2>
<h3 id="安装pcre">安装pcre</h3>
<ul>
<li><code>cd /usr/local/</code> : 到安装目录下</li>
<li><code>wget https://sourceforge.net/projects/pcre/files/pcre/8.44/pcre-8.44.tar.gz</code>:下载pcre</li>
<li><code>tar -zxvf pcre-8.44.tar.gz</code>: 解压</li>
<li><code>cd pcre-8.44</code>:切换到文件夹下</li>
<li><code>./configure</code>:执行配置文件</li>
<li><code>make &amp;&amp; make install</code>:编译安装pcre</li>
</ul>
<p><strong>特别注意</strong>:make 命令执行不了的同学 <code>./configure</code>后 最后一行会出现</p>
<p>configure: error: You need a C++ compiler for C++ support.</p>
<p>安装一下这个即可：<code>yum install -y gcc gcc-c++</code></p>
<p>（安装完毕后在执行 ./configure 在执行make 就OK了 我就是这样）</p>
<h3 id="安装openssl和zlib">安装openssl和zlib</h3>
<p><code>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</code>:一键安装</p>
<h3 id="安装nginx">安装nginx</h3>
<ul>
<li><code>cd /usr/local/</code> : 到安装目录下并且把tar文件放到该目录中</li>
<li><code>tar -zxvf nginx-1.16.1.tar.gz</code> : 解压文件</li>
<li><code>cd nginx-1.16.1</code>: 切换到文件目录下</li>
<li><code>./configure</code>: 执行安装配置文件</li>
<li><code>make &amp;&amp; make install</code>: 编译安装</li>
<li><code>cd /usr/local/nginx/sbin/</code>: 进去nginx可执行文件目录中</li>
<li><code>./nginx</code>:启动nginx服务</li>
<li>访问系统80端口查看服务是否启动</li>
</ul>
<p><strong>特别注意</strong>:</p>
<p>在 windows 系统中访问linux 中 <strong>nginx</strong>，默认不能访问的，因为<strong>防火墙</strong>问题</p>
<ul>
<li>
<p>查看开放的端口号</p>
<ul>
<li>firewall-cmd --list-all</li>
</ul>
</li>
<li>
<p>设置开放的端口号</p>
<ul>
<li>firewall-cmd --add-service=http –permanent</li>
<li>firewall-cmd --add-port=80/tcp --permanent</li>
</ul>
</li>
<li>
<p>重启防火墙</p>
<ul>
<li>firewall-cmd –reload</li>
</ul>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2020/04/18/vo1gCVjNGi2mYzE.png" alt="image.png" loading="lazy"></figure>
<h1 id="nginx-常用命令和配置文件">nginx 常用命令和配置文件</h1>
<h2 id="常用命令">常用命令</h2>
<ul>
<li>
<p><code>cd /usr/local/nginx/sbin</code>: 进入nginx目录中</p>
</li>
<li>
<p><code>./nginx -v</code>:查看nginx版本号</p>
</li>
<li>
<p><code>./nginx</code>: 启动nginx</p>
</li>
<li>
<p><code>./nginx -s stop</code>: 停止nginx</p>
</li>
<li>
<p><code>./nginx -s reload</code>:重新加载nginx(不是重启)</p>
</li>
</ul>
<h2 id="配置文件">配置文件</h2>
<ul>
<li>
<p><code>cd /usr/local/nginx/conf/nginx.conf</code> : 配置文件的目录</p>
</li>
<li>
<p>配置文件中的内容</p>
<ul>
<li>
<p>全局块</p>
</li>
<li>
<pre><code></code></pre>
</li>
</ul>
<p>worker_processes;</p>
<pre><code>
* 从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配置指令，主要包括配置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。比如上面第一行配置的 `worker_processes  1;`
 这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约.

* events块
* ``````json
  events {
      worker_connections  1024;
  }
  ``````
* events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word  process 可以同时支持的最大连接数等。
上述例子就表示每个 work process 支持的最大连接数为 1024.
 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。

* http块

* ``````json
  http {
      include       mime.types;
      default_type  application/octet-stream;
  
      #log_format  main  '$remote_addr - $remote_user [$time_local] &quot;$request&quot; '
      #                  '$status $body_bytes_sent &quot;$http_referer&quot; '
      #                  '&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;';
  
      #access_log  logs/access.log  main;
  
      sendfile        on;
      #tcp_nopush     on;
  
      #keepalive_timeout  0;
      keepalive_timeout  65;
  
      #gzip  on;
  
      server {
          listen       80;
          server_name  localhost;
  ``````

* 这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。需要注意的是：http 块也可以包括 **http 全局块**、**server 块**

* http全局块

   * http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。

* server块
  * 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。每个 http 块可以包括多个server 块，而每个 server 块就相当于一个虚拟主机。而每个 server 块也分为全局server 块，以及可以同时包含多个 locaton 块。
  * 全局server块
    * 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。
  * location块
    * 一个 server 块可以配置多个 location 块。
</code></pre>
</li>
</ul>
<p>这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟 主机名称（也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p>
<h2 id="location-指令说明">location 指令说明</h2>
<p>该指令用于匹配URL</p>
<p>语法如下</p>
<pre><code class="language-json">location [ = | ~ | ~* | ^~] uri {

}
</code></pre>
<ul>
<li>
<p>= : 用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求</p>
</li>
<li>
<p>~ : 用于表示 uri 包含正则表达式，并且区分大小写</p>
</li>
<li>
<p>~* : 用于表示 uri 包含正则表达式，并且不区分大小写</p>
</li>
<li>
<p>^~ : 用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配</p>
</li>
</ul>
<p>*<em>注意 : ** 如果 uri 包含正则表达式，则必须要有 ~ 或者 ~</em> 标识</p>
<h1 id="nginx配置实例-反向代理">nginx配置实例-反向代理</h1>
<h2 id="反向代理实例一">反向代理实例一</h2>
<p>实现效果:使用nginx反向代理,访问www.123.com直接跳转到127.0.0.1:8080</p>
<h3 id="实现过程">实现过程:</h3>
<ol>
<li>启动一个tomcat,浏览器地址栏输入127.0.0.1:8080,启动访问正常后</li>
<li>修改本地host<code>C:\Windows\System32\drivers\etc\hosts</code>文件,将<code>www.123.com</code>映射到127.0.0.1</li>
</ol>
<pre><code class="language-tex">配置完成之后，我们便可以通过 www.123.com:8080 访问到第一步出现的 Tomcat 初始界面。那么如何只需要输入 www.123.com 便可以跳转到 Tomcat 初始界面呢？便用到 nginx的反向代理。
</code></pre>
<ol start="3">
<li>在 nginx.conf 配置文件中增加如下配置</li>
</ol>
<pre><code class="language-json">server {
	listen  80;
	server_name www.123.com;
	
	location / {
		proxy_pass http://127.0.0.1:8080;
		index index.html index.htm index.jsp;
	}
}
</code></pre>
<ol start="4">
<li>如上配置，我们监听 80 端口，访问域名为 www.123.com，不加端口号时默认为 80 端口，故 访问该域名时会跳转到 127.0.0.1:8080 路径上。在浏览器端输入 www.123.com 会看到tomcat index.jsp 页面：</li>
</ol>
<h2 id="反向代理实例二">反向代理实例二</h2>
<p>实现效果：使用 nginx 反向代理，根据访问的路径跳转到不同端口的服务中nginx 监听端口为 9001，</p>
<p>访问 http://127.0.0.1:9001/edu/ 直接跳转到 127.0.0.1:8081</p>
<p>访问 http://127.0.0.1:9001/vod/ 直接跳转到 127.0.0.1:8082</p>
<h3 id="实现过程-2">实现过程</h3>
<ol>
<li>
<p>准备两个 tomcat，一个 8001 端口，一个 8002 端口，并准备好测试的页面</p>
</li>
<li>
<p>修改 nginx 的配置文件 ,在 http 块中添加 server{}</p>
</li>
</ol>
<pre><code class="language-json">server {
	listen 9001;
    server_name localhost;
    
    location ~ /edu/ {
    	proxy_pass http://localhost:8001;
	}
    location ~ /vod/ {
    	proxy_pass http://localhost:8002;
	}
}
</code></pre>
<ol start="3">
<li>访问测试</li>
</ol>
<h1 id="nginx-配置实例-负载均衡">nginx 配置实例-负载均衡</h1>
<p>实现效果:</p>
<p>浏览器地址栏输入地址 <code>http://192.168.17.129/edu/a.html</code>，负载均衡效果,平均8080和 8081 端口中</p>
<h2 id="实现过程-3">实现过程</h2>
<ol>
<li>
<p>准备两个同时启动的tomcat,一台8080,一台8081</p>
</li>
<li>
<p>在两台 tomcat里面 webapps目录中，创建名称 edu 文件夹，在 edu 文件夹中创建页面 a.html，用于测试</p>
</li>
<li>
<p>在nginx的配置文件中进行负载均衡的配置</p>
</li>
</ol>
<pre><code class="language-json">upstream myserver {
	server 192.168.17.129:8080;
	server 192.168.17.129:8081;
}
</code></pre>
<pre><code class="language-json">server {
	listen 80;
	server_name 192.168.17.129;
	
	location /{
		proxy_pass http://myserver;
		root html;
		index index.html index.htm;
	}
}
</code></pre>
<ol start="4">
<li>地址栏中访问测试<code>http://192.168.17.129/edu/a.html</code></li>
</ol>
<h2 id="nginx负载均衡-分配策略">nginx负载均衡 分配策略</h2>
<ol>
<li>轮询（默认）</li>
</ol>
<pre><code>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。
</code></pre>
<ol start="2">
<li>weight</li>
</ol>
<pre><code class="language-json">weight 代表权,重默认为 1,权重越高被分配的客户端越多
指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况。例如:

upstream server_pool{ 
	server 192.168.5.21 weight=5; 
	server 192.168.5.22 weight=10; 
}

</code></pre>
<ol start="3">
<li>ip_hash</li>
</ol>
<pre><code class="language-json">每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。 例如：

upstream server_pool{ 
	ip_hash; 
	server 192.168.5.21:80; 
	server 192.168.5.22:80; 
}
</code></pre>
<ol start="4">
<li>fair (第三方)</li>
</ol>
<pre><code class="language-json">按后端服务器的响应时间来分配请求，响应时间短的优先分配。

upstream server_pool{ 
	server 192.168.5.21:80; 
	server 192.168.5.22:80; 
	fair; 
}
</code></pre>
<h1 id="nginx-配置实例-动静分离">nginx 配置实例-动静分离</h1>
<p>Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx处理静态页面，Tomcat 处理动态页面。动静分离从目前实现角度来讲大致分为两种，</p>
<p>​	一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案；</p>
<p>​	另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用Expires 来缓存），我这里设置 3d，表示在这 3 天之内访问这个 URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码 200。</p>
<h2 id="实现过程-4">实现过程</h2>
<ol>
<li>现在系统中准备静态资源,用于访问</li>
</ol>
<pre><code>在linux 跟目录中创建image和www文件夹,并给文件夹下放入静态资源
</code></pre>
<ol start="2">
<li>具体配置</li>
</ol>
<pre><code class="language-json">server {
    listen 80;
    server_name 192.168.17.129;
    
    location /www/ {
    	root /data/;
    	index index.html index.htm;
	}
	location /image/ {
        root /data/;
        autoindex on;
    }
}
</code></pre>
<ol start="3">
<li>浏览器中输入地址<code>http://192.168.17.129/image/01.jpg</code>,<code>http://192.168.17.129/www/a.html</code></li>
</ol>
<p><strong>特别注意</strong>: 因为配置文件中配置了 autoindex on;所以在浏览器中访问<code>http://192.168.17.129/image/</code>结果如下:</p>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2020/04/19/ig8TzoqZWMU4Fhu.png" alt="image.png" loading="lazy"></figure>
<h1 id="nginx-处理跨域请求">nginx 处理跨域请求</h1>
<p>当出现403跨域错误的时候 <code>No 'Access-Control-Allow-Origin' header is present on the requested resource</code>，需要给Nginx服务器配置响应的header参数：</p>
<h2 id="解决方案">解决方案</h2>
<pre><code class="language-json">location / {  
    add_header Access-Control-Allow-Origin *;
    add_header Access-Control-Allow-Methods 'GET, POST, OPTIONS';
    add_header Access-Control-Allow-Headers 'DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization';

    if ($request_method = 'OPTIONS') {
        return 204;
    }
} 
</code></pre>
<h2 id="解释">解释</h2>
<h4 id="1-access-control-allow-origin">1. <strong>Access-Control-Allow-Origin</strong></h4>
<pre><code>服务器默认是不被允许跨域的。给Nginx服务器配置`Access-Control-Allow-Origin *`后，表示服务器可以接受所有的请求源（Origin）,即接受所有跨域的请求。
</code></pre>
<h4 id="2-access-control-allow-headers-是为了防止出现以下错误">2. <strong>Access-Control-Allow-Headers</strong> 是为了防止出现以下错误：</h4>
<pre><code>Request header field Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.
</code></pre>
<p>这个错误表示当前请求Content-Type的值不被支持。其实是我们发起了&quot;application/json&quot;的类型请求导致的。这里涉及到一个概念：<code>预检请求（preflight request）</code>,请看下面&quot;预检请求&quot;的介绍。</p>
<h4 id="3-access-control-allow-methods-是为了防止出现以下错误">3. <strong>Access-Control-Allow-Methods</strong> 是为了防止出现以下错误：</h4>
<pre><code>Content-Type is not allowed by Access-Control-Allow-Headers in preflight response.
</code></pre>
<h4 id="4给options-添加-204的返回是为了处理在发送post请求时nginx依然拒绝访问的错误">4.给<code>OPTIONS</code> 添加 <code>204</code>的返回，是为了处理在发送POST请求时Nginx依然拒绝访问的错误</h4>
<p>发送&quot;预检请求&quot;时，需要用到方法 <code>OPTIONS</code> ,所以服务器需要允许该方法。</p>
<h2 id="预检请求preflight-request">预检请求（preflight request）</h2>
<p>其实上面的配置涉及到了一个W3C标准：<code>CROS</code>,全称是跨域资源共享 (Cross-origin resource sharing)，它的提出就是为了解决跨域请求的。</p>
<blockquote>
<p>跨域资源共享(CORS)标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，<code>对那些可能对服务器数据产生副作用的HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求）</code>，浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。</p>
</blockquote>
<p>那么, 允许跨域, 不就是服务端(例如Nginx或者后端代码)设置<code>Access-Control-Allow-Origin: *</code>就可以了吗?</p>
<p>普通的请求确实是这样子的, 除此之外, 还一种叫请求叫Preflighted Request（带预检的跨域请求）</p>
<p>Preflighted Request在发送真正的请求前, 会先发送一个方法为OPTIONS的预请求(Preflighted Request), 用于试探服务端是否能接受真正的请求.</p>
<p>如果options获得的回应是拒绝性质的，比如404\403\500等http状态，就会停止post、get等请求的发出。</p>
<p>那么, 什么情况下请求会变成Preflighted Request呢? 翻看了MDN的文档发现如下：(文档地址：https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#The_HTTP_request_headers)</p>
<ol>
<li>请求方法不是GET/HEAD/POST</li>
<li>POST请求的<code>Content-Type</code>并非<code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, 或<code>text/plain</code></li>
<li>请求设置了自定义的<code>header</code>字段</li>
</ol>
<p>举个例子, 如果POST请求要传输的数据为 XML文档, <code>Content-Type</code>为<code>application/xml</code>或<code>text/xml</code>, 则发送这个请求前会发送一个预请求，或者自定义的header字段也是一样的道理。</p>
<p>有了上面的知识点, 再去看项目中ajax调用</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2020/04/20/hyRJi2OaCktSAEB.png" alt="image.png" loading="lazy"></figure>
<p>可以看出, 跨域请求中设置了自定义的<code>header</code>字段, 所以该请求是<code>preflighted request</code>, 则请求前一定会发送一个OPTIONS作为预请求.</p>
<p>所以说, 在项目中ajax对后台API的调用, OPTIONS请求是没办法去掉的, 除非后台接口不再需要在请求<code>header</code>中设置<code>openId</code>但是由于该项目中用户信息是采用的JWT的方式，所以只好作罢。</p>
<p>但是由于该项目在后台中自定义了请求频率限制的拦截器，例如限制同一个客户端一秒内对某一个接口只能访问1次。如果超过限制，则第二次会返回状态码500，不予处理。如果每次请求前都带着一次OPTIONS请求，则该拦截器无法正常实现功能，反正会导致大批接口调用失败的情况。</p>
<p>鉴于上述分析，既然前端发起请求时OPTIONS请求没有办法去除，那么是否可以考虑从后台拦截器进行改造。</p>
<p>改造后的代码如下：</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2020/04/20/9623BrEtSPhFRfL.png" alt="image.png" loading="lazy"></figure>
<p>如果拦截到的请求不是项目中常规的GET或者POST请求，则该拦截器直接放行。至此，问题完美解决。</p>
<h1 id="nginx-原理">nginx 原理</h1>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2020/04/19/oBvuNLaUpHGICMX.png" alt="image.png" loading="lazy"></figure>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2020/04/19/6oJX1jz9IWbD37Z.png" alt="1587305293_1_.jpg" loading="lazy"></figure>
<h2 id="master-workers-的机制的好处">master-workers 的机制的好处</h2>
<p>首先，对于每个 worker 进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，</p>
<p>同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会</p>
<p>影响，一个进程退出后，其它进程还在工作，服务不会中断，master 进程则很快启动新的</p>
<p>worker 进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当</p>
<p>前 worker 上的所有请求失败，不过不会影响到所有请求，所以降低了风险。</p>
<h2 id="需要设置多少个worker">需要设置多少个worker</h2>
<p>Nginx 同 redis 类似都采用了 io 多路复用机制，每个 worker 都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求， 即使是千上万个请求也不在话下。每个 worker 的线程可以把一个 cpu 的性能发挥到极致。所以 worker 数和服务器的cpu数相等是最为适宜的。设少了会浪费 cpu，设多了会造成 cpu 频繁切换上下文带来的损耗。</p>
<p><strong>设置 worker 数量</strong></p>
<p>worker_processes 4</p>
<p>#work 绑定 cpu(4 work 绑定 4cpu)。</p>
<p>worker_cpu_affinity 0001 0010 0100 1000</p>
<p>#work 绑定 cpu (4 work 绑定 8cpu 中的 4 个) 。</p>
<p>worker_cpu_affinity 0000001 00000010 00000100 00001000</p>
<p><strong>连接数</strong> <strong>worker_connection</strong></p>
<p>这个值是表示每个 worker 进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接数，应该是</p>
<p><code>worker_connections * worker_processes</code></p>
<p>当然，这里说的是最大连接数，对于HTTP 请 求 本 地 资 源 来 说 ， 能 够 支 持 的 最 大 并 发 数 量 是</p>
<p><code>worker_connections * worker_processes</code></p>
<p>如果是支持 http1.1 的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： <code>worker_connections * worker_processes /2</code></p>
<p>而如果是 HTTP 作 为反向代理来说，最大并发数量应该是</p>
<p><code>worker_connections * worker_processes/4</code></p>
<p>因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。</p>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2020/04/19/LcyKewbUuTN2kF4.png" alt="image.png" loading="lazy"></figure>
]]></content>
    </entry>
</feed>