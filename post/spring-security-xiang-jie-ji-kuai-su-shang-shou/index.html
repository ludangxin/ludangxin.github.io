<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
<title>
    断剑重铸之日，骑士归来之时。
</title>
<!--[if lt IE 9]><script src="//cdn.bootcss.com/html5shiv/r29/html5.js"></script><![endif]-->
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
<meta name="author" content="鲁档信">
<meta name="description" content="Hello World !">
<meta name="keywords" content="鲁档信,ludangxin">
<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
<link rel="stylesheet" href="http://blog.ludangxin.club/styles/main.css" />
<link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
<script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js"></script>

        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/css/style.min.css" />
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/tocbot.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/script.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/icon.min.js"></script>
        
            <script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/Card/prism.min.js"></script>
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/css/Card/prism.min.css" />
            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css">
            <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js"></script>
            
                <!--点击特效-->
                <script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/love.min.js"></script>
                
                        <!--CDN样式-->
                        <script src="https://cdn.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/hit-kounter-lc-0.3.0.js"></script>
                        <script src="https://cdn1.lncld.net/static/js/av-min-1.5.0.js"></script>
                        
                            <script>
                                (function() {
                                    var bp = document.createElement('script');
                                    var curProtocol = window.location.protocol.split(':')[0];
                                    if (curProtocol === 'https') {
                                        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                                    } else {
                                        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                                    }
                                    var s = document.getElementsByTagName("script")[0];
                                    s.parentNode.insertBefore(bp, s);
                                })();
                            </script>
                            
</head>

<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <a href="http://blog.ludangxin.club">
                    断剑重铸之日，骑士归来之时。
                </a>
            </div>
            <div id="tp-weather-widget"></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">
                        🏠首页
                    </a>
                    
                    <a class="menu-item" href="/archives">
                        📚归档
                    </a>
                    
                    <a class="menu-item" href="/tags">
                        🏷️标签
                    </a>
                    
                    <a class="menu-item" href="/posts">
                        ✍️博客
                    </a>
                    
                    <a class="menu-item" href="/post/about/">
                        👦关于
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
            <form id="gridea-search-form" data-update="1597935637693" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
            </form>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="http://blog.ludangxin.club">
                            断剑重铸之日，骑士归来之时。
                        </a>
                        <!--en-->
                        <a id="mobile-toggle-theme-en" class="a en">&nbsp;Dark</a>
                        <!--zh-->
                        <a id="mobile-toggle-theme-zh" class="a zh">&nbsp;&#x6697;&#x9ED1;</a>
                    </div>
                    <form id="gridea-search-form" data-update="1597935637693" action="/search/index.html">
                        <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
                    </form>
                    <!--en-->
                    <div class="menu-toggle" id="menu-toggle-en" onclick="mobileBtn()">&#9776; Menu</div>
                    <!--zh-->
                    <div class="menu-toggle" id="menu-toggle-zh" onclick="mobileBtn()">&#9776; &#x83DC;&#x5355;</div>

                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/">
                            🏠首页
                        </a>
                        
                        <a class="menu-item" href="/archives">
                            📚归档
                        </a>
                        
                        <a class="menu-item" href="/tags">
                            🏷️标签
                        </a>
                        
                        <a class="menu-item" href="/posts">
                            ✍️博客
                        </a>
                        
                        <a class="menu-item" href="/post/about/">
                            👦关于
                        </a>
                        
                </div>
            </div>
        </nav>
</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementById("menu-toggle-en");
        var toggleMenu_zh = document.getElementById("menu-toggle-zh");

        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.display != "none") {
            if (toggleMenu.classList.contains("active")) {
                toggleMenu.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu.classList.add("active")
                mobileMenu.classList.add("active")
            }
        } else if (toggleMenu_zh.display != "none") {
            if (toggleMenu_zh.classList.contains("active")) {
                toggleMenu_zh.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu_zh.classList.add("active")
                mobileMenu.classList.add("active")
            }
        }

    }
</script>



    <script>
        (function(a, h, g, f, e, d, c, b) {
            b = function() {
                d = h.createElement(g);
                c = h.getElementsByTagName(g)[0];
                d.src = e;
                d.charset = "utf-8";
                d.async = 1;
                c.parentNode.insertBefore(d, c)
            };
            a["SeniverseWeatherWidgetObject"] = f;
            a[f] || (a[f] = function() {
                (a[f].q = a[f].q || []).push(arguments)
            });
            a[f].l = +new Date();
            if (a.attachEvent) {
                a.attachEvent("onload", b)
            } else {
                a.addEventListener("load", b, false)
            }
        }(window, document, "script", "SeniverseWeatherWidget", "//cdn.sencdn.com/widget2/static/js/bundle.js?t=" + parseInt((new Date().getTime() / 100000000).toString(), 10)));
        window.SeniverseWeatherWidget('show', {
            flavor: "slim",
            location: "WWEFQFPJZ7T8",
            geolocation: true,
            language: "auto",
            unit: "c",
            theme: "auto",
            token: "61bcc333-3305-4728-9465-6785274bb0a3",
            hover: "enabled",
            container: "tp-weather-widget"
        })
    </script>
    
            <div class="main">
                <div class="container">
                    <article class="post-wrap">
                        <header class="post-header">
                            <h1 class="post-title">
                                Spring Security 详解 及 快速上手
                            </h1>
                            
                                <!--en-->
                                <div class="post-meta en">
                                    Author:
                                    <a itemprop="author" rel="author" href="/">
                                        断剑重铸之日，骑士归来之时。
                                    </a>
                                    <span class="post-time">
                                Date: <a href="#">2020-06-02</a>
                            </span>
                                    <span class="post-readtime">Reading Time:<a
                                    href="#">35.6
                                    mins</a></span>
                                    <span class="post-words">words:<a href="#">8336</a></span>
                                    
                                        <span class="post-category">
                                Category:
                                
                                <a href="http://blog.ludangxin.club/tag/LSBz4Ej4I/">springboot</a>
                                
                            </span>
                                        
                                            Views:
                                            <span data-hk-page="current"> - </span>
                                            
                                </div>
                                
                        </header>
                        
                            <img class="post-feature-image" src="http://blog.ludangxin.club/post-images/spring-security-xiang-jie-ji-kuai-su-shang-shou.jpg" alt="">
                          
                        <div class="post-content">
                            <h1 id="什么是认证">什么是认证</h1>
<p>用户认证就是判断一个用户的身份是否合法的过程，用户去访问系统资源时系统要求验证用户的身份信 息，身份合法方可继续访问，不合法则拒绝访问。常见的用户身份认证方式有：用户名密码登录，二维码登录，手机短信登录，指纹认证等方式。<br>
<strong>系统为什么要认证？</strong><br>
认证是为了保护系统的隐私数据与资源，用户的身份合法方可访问该系统的资源。</p>
<h1 id="什么是会话">什么是会话</h1>
<p>用户认证通过后，为了避免用户的每次操作都进行认证可将用户的信息保证在会话中。会话就是系统为了保持当前 用户的登录状态所提供的机制，常见的有基于session方式、基于token方式等。</p>
<h2 id="session-会话">session 会话</h2>
<p>用户认证成功后，在服务端生成用户相关的数据保存在session(当前会话)中，发给客户端的 sesssion_id 存放到 cookie 中，这样用户客户端请求时带上 session_id 就可以验证服务器端是否存在 session 数 据，以此完成用户的合法校验，当用户退出系统或session过期销毁时,客户端的session_id也就无效了。<br>
<img src="http://blog.ludangxin.club/post-images/1591110991875.jpg" alt="" loading="lazy"></p>
<h2 id="token-会话">token 会话</h2>
<p>用户认证成功后，服务端生成一个token发给客户端，客户端可以放到 cookie 或 localStorage等存储中，每次请求时带上 token，服务端收到token通过验证后即可确认用户身份。<br>
<img src="http://blog.ludangxin.club/post-images/1591111017782.jpg" alt="" loading="lazy"><br>
基于session的认证方式由Servlet规范定制，服务端要存储session信息需要占用内存资源，客户端需要支持 cookie；基于token的方式则一般不需要服务端存储token，并且不限制客户端的存储方式。如今移动互联网时代 更多类型的客户端需要接入系统，系统多是采用前后端分离的架构进行实现，所以基于token的方式更适合。</p>
<h1 id="什么是授权">什么是授权</h1>
<p>授权是用户认证通过根据用户的权限来控制用户访问资源的过程，拥有资源的访问权限则正常访问，没有权限则拒绝访问。<br>
<strong>为什么要授权？</strong><br>
认证是为了保证用户身份的合法性，授权则是为了更细粒度的对隐私数据进行划分，授权是在认证通过后发生的，控制不同的用户能够访问不同的资源。</p>
<h1 id="springsecurity">SpringSecurity</h1>
<p>Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。由于它是Spring生态系统中的一员，因此它伴随着整个Spring生态系统不断修正、升级，在spring boot项目中加入spring security更是十分简单，使用Spring Security 减少了为企业系统安全控制编写大量重复代码的工作。</p>
<h2 id="快速上手">快速上手</h2>
<h3 id="引入所需依赖">引入所需依赖</h3>
<pre><code class="language-xml">        &lt;!-- spring security 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- web支持 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="添加spring-security-配置类">添加spring security 配置类</h3>
<pre><code class="language-java">package com.ldx.springboot.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.password.NoOpPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

/**
 * springsecurity 配置类
 * @author ludangxin
 * @Date 2020-06-01
 **/
@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    /**
     * 定义用户信息服务（查询用户信息）
     */
    @Bean
    @Override
    public UserDetailsService userDetailsService(){
        //基于内存的userDetail
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        //用户zhangsan 拥有访问p1资源权限
        manager.createUser(User.withUsername(&quot;zhangsan&quot;).password(&quot;123&quot;).authorities(&quot;p1&quot;).build());
        //用户lisi 拥有访问p2资源权限
        manager.createUser(User.withUsername(&quot;lisi&quot;).password(&quot;456&quot;).authorities(&quot;p2&quot;).build());
        return manager;
    }

    /**
     * 密码编码器
     */
    @Bean
    public PasswordEncoder passwordEncoder(){
        //无加密机制
        return NoOpPasswordEncoder.getInstance();
    }

    /**
     * 安全拦截机制（最重要）
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                .antMatchers(&quot;/r/r1&quot;).hasAuthority(&quot;p1&quot;)
                .antMatchers(&quot;/r/r2&quot;).hasAuthority(&quot;p2&quot;)
                //所有的请求必须通过认证
                .anyRequest().authenticated()
                .and()
                //允许表单登录
                .formLogin()
                //自定义登录成功的页面地址
                .successForwardUrl(&quot;/login-success&quot;);
    }
}

</code></pre>
<h3 id="编写测试接口">编写测试接口</h3>
<pre><code class="language-java">import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class TestController {

    @RequestMapping(value = &quot;/login-success&quot;)
    public String loginSuccess(){
        return &quot; 登录成功&quot;;
    }

    /**
     * 测试资源1
     * @return
     */
    @GetMapping(value = &quot;/r/r1&quot;)
    public String r1(){
        return &quot; 访问资源1&quot;;
    }

    /**
     * 测试资源2
     * @return
     */
    @GetMapping(value = &quot;/r/r2&quot;)
    public String r2(){
        return &quot; 访问资源2&quot;;
    }
}
</code></pre>
<h3 id="测试">测试</h3>
<ol>
<li>测试登陆功能,访问 <code>localhost:8080</code><br>
<img src="http://blog.ludangxin.club/post-images/1591111117908.jpg" alt="" loading="lazy"></li>
<li>输入 账号:<code>zhangsan</code> 密码: <code>123</code>登陆成功<br>
<img src="http://blog.ludangxin.club/post-images/1591111121642.jpg" alt="" loading="lazy"></li>
<li>访问 <code>/r/r1</code>资源<br>
<img src="http://blog.ludangxin.club/post-images/1591111124609.jpg" alt="" loading="lazy"></li>
<li>访问<code>r/r2</code>资源, 403无权限<br>
<img src="http://blog.ludangxin.club/post-images/1591111127688.jpg" alt="" loading="lazy"></li>
</ol>
<h3 id="小结">小结</h3>
<p>通过快速上手，咱们使用Spring Security实现了认证和授权，Spring Security提供了基于账号和密码的认证方式，通过安全配置即可实现请求拦截，授权功能，Spring Security能完成的不仅仅是这些。</p>
<h2 id="工作原理">工作原理</h2>
<h3 id="结构总览">结构总览</h3>
<p>Spring Security所解决的问题就是<strong>安全访问控制</strong>，而安全访问控制功能其实就是对所有进入系统的请求进行拦截，校验每个请求是否能够访问它所期望的资源。<br>
当初始化Spring Security时，会创建一个名为 SpringSecurityFilterChain 的Servlet过滤器，类型为 org.springframework.security.web.FilterChainProxy，它实现了javax.servlet.Filter，因此外部的请求会经过此类，下图是Spring Security过虑器链结构图：<br>
<img src="http://blog.ludangxin.club/post-images/1591111142292.jpg" alt="" loading="lazy"><br>
FilterChainProxy是一个代理，真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter，同时这些Filter作为Bean被Spring管理，它们是Spring Security核心，各有各的职责，但他们并不直接处理用户的<strong>认证</strong>，也不直接处理用户的<strong>授权</strong>，而是把它们交给了认证管理（AuthenticationManager）和决策管理器（AccessDecisionManager）进行处理.<br>
下面介绍过滤器链中主要的几个过滤器及其作用：<br>
<img src="http://blog.ludangxin.club/post-images/1591111150999.jpg" alt="" loading="lazy"><br>
<strong>SecurityContextPersistenceFilter :</strong><br>
这个Filter是整个拦截过程的入口和出口（也就是第一个和最后一个拦截器），会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext，然后把它设置给SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository，同时清除 securityContextHolder 所持有的SecurityContext；<br>
<strong>UsernamePasswordAuthenticationFilter :</strong><br>
用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码，其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，这些都可以根据需求做相关改变；<br>
<strong>FilterSecurityInterceptor :</strong><br>
是用于保护web资源的，使用AccessDecisionManager对当前用户进行授权访问；<br>
<strong>ExceptionTranslationFilter :</strong><br>
能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常：AuthenticationException 和 AccessDeniedException，其它的异常它会继续抛出。</p>
<h3 id="认证">认证</h3>
<h4 id="流程">流程</h4>
<figure data-type="image" tabindex="1"><img src="http://blog.ludangxin.club/post-images/1591111163947.jpg" alt="" loading="lazy"></figure>
<ol>
<li>用户提交用户名、密码被SecurityFilterChain中的 UsernamePasswordAuthenticationFilter 过滤器获取到，封装为请求Authentication，通常情况下是UsernamePasswordAuthenticationToken这个实现类。</li>
<li>然后过滤器将Authentication提交至认证管理器（AuthenticationManager）进行认证</li>
<li>认证成功后， AuthenticationManager 身份管理器返回一个被填充满了信息的（包括上面提到的权限信息，身份信息，细节信息，但密码通常会被移除） Authentication 实例。</li>
<li>SecurityContextHolder 安全上下文容器将第3步填充了信息的 Authentication ，通过SecurityContextHolder.getContext().setAuthentication(…)方法，设置到其中。可以看出AuthenticationManager接口（认证管理器）是认证相关的核心接口，也是发起认证的出发点，它 的实现类为ProviderManager。而Spring Security支持多种认证方式，因此ProviderManager维护着一个 List<AuthenticationProvider> 列表，存放多种认证方式，最终实际的认证工作是由 AuthenticationProvider完成的。咱们知道web表单的对应的AuthenticationProvider实现类为 DaoAuthenticationProvider，它的内部又维护着一个UserDetailsService负责UserDetails的获取。最终AuthenticationProvider将UserDetails填充至Authentication。</li>
</ol>
<h4 id="authenticationprovider">AuthenticationProvider</h4>
<p>通过前面的<strong>Spring Security认证流程</strong>我们得知，认证管理器（AuthenticationManager）委托AuthenticationProvider完成认证工作。<br>
AuthenticationProvider是一个接口，定义如下：</p>
<pre><code class="language-java">public interface AuthenticationProvider { 
    Authentication authenticate(Authentication authentication) throws AuthenticationException; 
    boolean supports(Class&lt;?&gt; var1); 
}
</code></pre>
<p><strong>authenticate</strong>()方法定义了<strong>认证的实现过程</strong>，它的参数是一个Authentication，里面包含了登录用户所提交的用户、密码等。而返回值也是一个Authentication，这个Authentication则是在认证成功后，将用户的权限及其他信息重新组装后生成。<br>
Spring Security中维护着一个 List<AuthenticationProvider> 列表，存放多种认证方式，不同的认证方式使用不同的AuthenticationProvider。如使用用户名密码登录时，使用AuthenticationProvider1，短信登录时使用AuthenticationProvider2等等这样的例子很多。<br>
每个AuthenticationProvider需要实现<strong>supports()<strong>方法来表明自己支持的认证方式，如我们使用表单方式认证，在提交请求时Spring Security会生成UsernamePasswordAuthenticationToken，它是一个Authentication，里面封装着用户提交的用户名、密码信息。而对应的，哪个AuthenticationProvider来处理它？<br>
我们在</strong>DaoAuthenticationProvider</strong>的基类AbstractUserDetailsAuthenticationProvider发现以下代码：</p>
<pre><code class="language-java">public boolean supports(Class&lt;?&gt; authentication) { 
    return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);
}
</code></pre>
<p><strong>也就是说当web表单提交用户名密码时，Spring Security由DaoAuthenticationProvider处理。</strong><br>
最后，我们来看一下<strong>Authentication</strong>(认证信息)的结构，它是一个接口，我们之前提到的<br>
UsernamePasswordAuthenticationToken就是它的实现之一：</p>
<pre><code class="language-java">public interface Authentication extends Principal, Serializable { 
    Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); 
    Object getCredentials(); 
    Object getDetails(); 
    Object getPrincipal();
    boolean isAuthenticated(); 
    void setAuthenticated(boolean var1) throws IllegalArgumentException; 
}
</code></pre>
<ol>
<li>Authentication是spring security包中的接口，直接继承自Principal类，而Principal是位于 java.security包中的。它是表示着一个抽象主体身份，任何主体都有一个名称，因此包含一个getName()方法。</li>
<li>getAuthorities()，权限信息列表，默认是GrantedAuthority接口的一些实现类，通常是代表权限信息的一系列字符串。</li>
<li>getCredentials()，凭证信息，用户输入的密码字符串，在认证过后通常会被移除，用于保障安全。</li>
<li>getDetails()，细节信息，web应用中的实现接口通常为 WebAuthenticationDetails，它记录了访问者的ip地址和sessionId的值。</li>
<li><strong>getPrincipal()</strong>，身份信息，大部分情况下返回的是UserDetails接口的实现类，UserDetails代表用户的详细信息，那从Authentication中取出来的UserDetails就是当前登录用户信息，它也是框架中的常用接口之一。</li>
</ol>
<h4 id="userdetailsservice">UserDetailsService</h4>
<ol>
<li>认识UserDetailsService<br>
现在咱们现在知道DaoAuthenticationProvider处理了web表单的认证逻辑，认证成功后既得到一个 Authentication(UsernamePasswordAuthenticationToken实现)，里面包含了身份信息（Principal）。这个身份信息就是一个 Object ，大多数情况下它可以被强转为UserDetails对象。 DaoAuthenticationProvider中包含了一个UserDetailsService实例，它负责根据用户名提取用户信息UserDetails(包含密码)，而后DaoAuthenticationProvider会去对比UserDetailsService提取的用户密码与用户提交的密码是否匹配作为认证成功的关键依据，因此可以通过将自定义的 UserDetailsService 公开为spring bean来定义自定义身份验证。</li>
</ol>
<pre><code class="language-java">public interface UserDetailsService { 
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException; 
}
</code></pre>
<p>很多人把DaoAuthenticationProvider和UserDetailsService的职责搞混淆，其实UserDetailsService只负责从特定的地方（通常是数据库）加载用户信息，仅此而已。而DaoAuthenticationProvider的职责更大，它完成完整的认证流程，同时会把UserDetails填充至Authentication。上面一直提到UserDetails是用户信息，咱们看一下它的真面目：</p>
<pre><code class="language-java">public interface UserDetails extends Serializable { 
    Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); 
    String getPassword(); 
    String getUsername();
    boolean isAccountNonExpired(); 
    boolean isAccountNonLocked(); 
    boolean isCredentialsNonExpired();
    boolean isEnabled(); 
}
</code></pre>
<p>它和Authentication接口很类似，比如它们都拥有username，authorities。Authentication的getCredentials()与UserDetails中的getPassword()需要被区分对待，前者是用户提交的密码凭证，后者是用户实际存储的密码，认证其实就是对这两者的比对。Authentication中的getAuthorities()实际是由UserDetails的getAuthorities()传递而形成的。还记得Authentication接口中的getDetails()方法吗？其中的UserDetails用户详细信息便是经过了AuthenticationProvider认证之后被填充的。 通过实现UserDetailsService和UserDetails，我们可以完成对用户信息获取方式以及用户信息字段的扩展。<br>
Spring Security提供的InMemoryUserDetailsManager(内存认证)，JdbcUserDetailsManager(jdbc认证)就是UserDetailsService的实现类，主要区别无非就是从内存还是从数据库加载用户。<br>
2. 自定义UserDetailsService</p>
<pre><code class="language-java">@Service 
public class SpringDataUserDetailsService implements UserDetailsService { 
    @Override 
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { 
        //登录账号 
        System.out.println(&quot;username=&quot;+username); 
        //根据账号去数据库查询... 
        //这里暂时使用静态数据 
        UserDetails userDetails = User.withUsername(username).password(&quot;123&quot;).authorities(&quot;p1&quot;).build(); return userDetails; 
    } 
}
</code></pre>
<h4 id="passwordencoder">PasswordEncoder</h4>
<ol>
<li>认识PasswordEncoder<br>
DaoAuthenticationProvider认证处理器通过UserDetailsService获取到UserDetails后，它是如何与请求Authentication中的密码做对比呢？<br>
在这里Spring Security为了适应多种多样的加密类型，又做了抽象，DaoAuthenticationProvider通过PasswordEncoder接口的matches方法进行密码的对比，而具体的密码对比细节取决于实现：</li>
</ol>
<pre><code class="language-java">public interface PasswordEncoder { 
    String encode(CharSequence var1);
    boolean matches(CharSequence var1, String var2); 
    default boolean upgradeEncoding(String encodedPassword) { 
        return false; 
    } 
}
</code></pre>
<p>而Spring Security提供很多内置的PasswordEncoder，能够开箱即用，使用某种PasswordEncoder只需要进行如下声明即可，如下：</p>
<pre><code class="language-java">@Bean 
public PasswordEncoder passwordEncoder() { 
    //NoOpPasswordEncoder采用字符串匹配方法，不对密码进行加密比较处理
    return NoOpPasswordEncoder.getInstance(); 
}
</code></pre>
<ol start="2">
<li>密码比较流程如下
<ol>
<li>用户输入密码（明文 ）</li>
<li>DaoAuthenticationProvider获取UserDetails（其中存储了用户的正确密码）</li>
<li>DaoAuthenticationProvider使用PasswordEncoder对输入的密码和正确的密码进行校验，密码一致则校验通过，否则校验失败。<br>
NoOpPasswordEncoder的校验规则拿 输入的密码和UserDetails中的正确密码进行字符串比较，字符串内容一致则校验通过，否则 校验失败。<br>
实际项目中推荐使用BCryptPasswordEncoder, Pbkdf2PasswordEncoder, SCryptPasswordEncoder等，感兴趣的大家可以看看这些PasswordEncoder的具体实现。</li>
</ol>
</li>
<li>使用BCryptPasswordEncoder
<ol>
<li>配置BCryptPasswordEncoder<br>
在安全配置类中定义：</li>
</ol>
</li>
</ol>
<pre><code class="language-java">@Bean 
public PasswordEncoder passwordEncoder() { 
    return new BCryptPasswordEncoder(); 
}
</code></pre>
<p>测试发现认证失败，提示：<code>Encoded password does not look like BCrypt</code>。<br>
原因：<br>
由于UserDetails中存储的是原始密码（比如：123），它不是BCrypt格式。跟踪 DaoAuthenticationProvider第33行代码查看 userDetails中的内容 ，跟踪第38行代码查看PasswordEncoder的类型。<br>
​	2. 测试BCrypt<br>
通过下边的代码测试BCrypt加密及校验的方法<br>
编写测试方法：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class) 
public class TestBCrypt {
    @Test
    public void test1(){ 
        //对原始密码加密 
        String hashpw = BCrypt.hashpw(&quot;123&quot;,BCrypt.gensalt()); 
        System.out.println(hashpw);
        //校验原始密码和BCrypt密码是否一致 
        boolean checkpw = BCrypt.checkpw(&quot;123&quot;, &quot;$2a$10$NlBC84MVb7F95EXYTXwLneXgCca6/GipyWR5NHm8K0203bSQMLpvm&quot;); 
        System.out.println(checkpw); 
    } 
}
</code></pre>
<h3 id="授权">授权</h3>
<h4 id="流程-2">流程</h4>
<p>通过<strong>快速上手</strong>我们知道，Spring Security可以通过 http.authorizeRequests() 对web请求进行授权保护。Spring Security使用标准Filter建立了对web请求的拦截，最终实现对资源的授权访问。<br>
Spring Security的授权流程如下：<br>
<img src="http://blog.ludangxin.club/post-images/1591111185336.jpg" alt="" loading="lazy"></p>
<ol>
<li><strong>拦截请求</strong>，已认证用户访问受保护的web资源将被SecurityFilterChain中的 FilterSecurityInterceptor 的子类拦截。</li>
<li><strong>获取资源访问策略</strong>，FilterSecurityInterceptor会从 SecurityMetadataSource 的子类 DefaultFilterInvocationSecurityMetadataSource 获取要访问当前资源所需要的权限Collection<ConfigAttribute> 。 SecurityMetadataSource其实就是读取访问策略的抽象，而读取的内容，其实就是我们配置的访问规则， 读 取访问策略如：</li>
</ol>
<pre><code class="language-java">http.authorizeRequests() 
    .antMatchers(&quot;/r/r1&quot;).hasAuthority(&quot;p1&quot;) 
    .antMatchers(&quot;/r/r2&quot;).hasAuthority(&quot;p2&quot;) ...
</code></pre>
<ol start="3">
<li>最后，FilterSecurityInterceptor会调用 AccessDecisionManager 进行授权决策，若决策通过，则允许访问资源，否则将禁止访问。<br>
AccessDecisionManager（访问决策管理器）的核心接口如下:</li>
</ol>
<pre><code class="language-java">public interface AccessDecisionManager { 
    /** * 通过传递的参数来决定用户是否有访问对应受保护资源的权限 */
    void decide(Authentication authentication , Object object, Collection&lt;ConfigAttribute&gt; configAttributes ) throws AccessDeniedException, InsufficientAuthenticationException;
    //略.. 
}
</code></pre>
<p>这里着重说明一下decide的参数：<br>
authentication：要访问资源的访问者的身份<br>
object：要访问的受保护资源，web请求对应FilterInvocation<br>
confifigAttributes：是受保护资源的访问策略，通过SecurityMetadataSource获取。<br>
<strong>decide接口就是用来鉴定当前用户是否有访问对应受保护资源的权限。</strong></p>
<h4 id="授权决策">授权决策</h4>
<p>AccessDecisionManager采用<strong>投票</strong>的方式来确定是否能够访问受保护资源。<br>
AccessDecisionManager中包含的一系列AccessDecisionVoter将会被用来对Authentication是否有权访问受保护对象进行投票，AccessDecisionManager根据投票结果，做出最终决策。<br>
AccessDecisionVoter是一个接口，其中定义有三个方法，具体结构如下所示。</p>
<pre><code class="language-java">public interface AccessDecisionVoter&lt;S&gt; { 
    int ACCESS_GRANTED = 1; 
    int ACCESS_ABSTAIN = 0; 
    int ACCESS_DENIED = ‐1; 
    boolean supports(ConfigAttribute var1); 
    boolean supports(Class&lt;?&gt; var1); 
    int vote(Authentication var1, S var2, Collection&lt;ConfigAttribute&gt; var3); 
}
</code></pre>
<p>vote()方法的返回结果会是AccessDecisionVoter中定义的三个常量之一。ACCESS_GRANTED表示同意，ACCESS_DENIED表示拒绝，ACCESS_ABSTAIN表示弃权。如果一个AccessDecisionVoter不能判定当前Authentication是否拥有访问对应受保护对象的权限，则其vote()方法的返回值应当为弃权ACCESS_ABSTAIN。<br>
Spring Security内置了三个基于投票的AccessDecisionManager实现类如下，它们分别是<br>
<strong>AffirmativeBased</strong>、<strong>ConsensusBased</strong>和<strong>UnanimousBased</strong>，<strong>Spring security默认使用的是AffirmativeBased。</strong></p>
<p><strong>AffirmativeBased</strong>：</p>
<ol>
<li>只要有AccessDecisionVoter的投票为ACCESS_GRANTED则同意用户进行访问；</li>
<li>如果全部弃权也表示通过；</li>
<li>如果没有一个人投赞成票，但是有人投反对票，则将抛出AccessDeniedException。</li>
</ol>
<p><strong>ConsensusBased</strong>：</p>
<ol>
<li>如果赞成票多于反对票则表示通过。</li>
<li>反过来，如果反对票多于赞成票则将抛出AccessDeniedException。</li>
<li>如果赞成票与反对票相同且不等于0，并且属性allowIfEqualGrantedDeniedDecisions的值为true，则表示通过，否则将抛出异常AccessDeniedException。参数allowIfEqualGrantedDeniedDecisions的值默认为true。</li>
<li>如果所有的AccessDecisionVoter都弃权了，则将视参数allowIfAllAbstainDecisions的值而定，如果该值为true则表示通过，否则将抛出异常AccessDeniedException。参数allowIfAllAbstainDecisions的值默认为false。</li>
</ol>
<p><strong>UnanimousBased</strong>:<br>
UnanimousBased与另外两种实现有点不一样，另外两种会一次性把受保护对象的配置属性全部传递给AccessDecisionVoter进行投票，而UnanimousBased会一次只传递一个ConfifigAttribute给AccessDecisionVoter进行投票。这也就意味着如果我们的AccessDecisionVoter的逻辑是只要传递进来的 ConfifigAttribute中有一个能够匹配则投赞成票，但是放到UnanimousBased中其投票结果就不一定是赞成了。</p>
<ol>
<li>如果受保护对象配置的某一个ConfifigAttribute被任意的AccessDecisionVoter反对了，则将抛出AccessDeniedException。</li>
<li>如果没有反对票，但是有赞成票，则表示通过。</li>
<li>如果全部弃权了，则将视参数allowIfAllAbstainDecisions的值而定，true则通过，false则抛出 AccessDeniedException。<br>
Spring Security也内置一些投票者实现类如<strong>RoleVoter</strong>、<strong>AuthenticatedVoter</strong>和<strong>WebExpressionVoter</strong>等。</li>
</ol>
<h2 id="自定义认证">自定义认证</h2>
<h3 id="创建数据库表">创建数据库表</h3>
<pre><code class="language-sql">CREATE DATABASE `test` CHARACTER SET 'utf8' COLLATE 'utf8_general_ci';
CREATE TABLE `t_user` ( 
    `id` bigint(20) NOT NULL COMMENT '用户id', 
    `username` varchar(64) NOT NULL, 
    `password` varchar(64) NOT NULL, 
    `fullname` varchar(255) NOT NULL COMMENT '用户姓名', 
    `mobile` varchar(11) DEFAULT NULL COMMENT '手机号', 
    PRIMARY KEY (`id`) USING BTREE 
) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC
</code></pre>
<h3 id="添加所需依赖">添加所需依赖</h3>
<pre><code class="language-xml">        &lt;!-- spring security 依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- web支持 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- mysql依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;5.1.47&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- mybatis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!-- lombok 工具--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;optional&gt;true&lt;/optional&gt;
        &lt;/dependency&gt;
        &lt;!-- 单元测试 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre>
<h3 id="配置applicationyml">配置application.yml</h3>
<pre><code class="language-yaml">spring:
  datasource:
    type: com.zaxxer.hikari.HikariDataSource
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;zeroDateTimeBehavior=convertToNull&amp;autoReconnect=true&amp;characterEncoding=utf-8
    username: root
    password: root
    hikari:
      minimum-idle: 5
      idle-timeout: 600000
      maximum-pool-size: 10
      auto-commit: true
      pool-name: MyHikariCP
      max-lifetime: 1800000
      connection-timeout: 30000
      connection-test-query: SELECT 1
</code></pre>
<h3 id="修改springboot-启动类">修改springboot 启动类</h3>
<pre><code class="language-java">import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan(basePackages = &quot;com.ldx.springboot.dao&quot;)
public class SpringbootSpringSecurityApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootSpringSecurityApplication.class, args);
    }
}
</code></pre>
<h3 id="创建securityconfig">创建securityConfig</h3>
<pre><code class="language-java">/**
 * springsecurity 配置类
 * @author ludangxin
 * @Date 2020-06-01
 **/
@Configuration
@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    /**
     * 密码编码器
     */
    @Bean public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    /**
     * 安全拦截机制（最重要）
     */
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.
                //屏蔽CSRF控制，即spring security不再限制CSRF
                csrf().disable().
                authorizeRequests()
                .antMatchers(&quot;/r/r1&quot;).hasAuthority(&quot;p1&quot;)
                .antMatchers(&quot;/r/r2&quot;).hasAuthority(&quot;p2&quot;)
                //所有的请求必须通过认证
                .anyRequest().authenticated()
                .and()
                //允许表单登录
                .formLogin()
                //自定义登录成功的页面地址
                .successForwardUrl(&quot;/login-success&quot;);
    }
}
</code></pre>
<h3 id="创建model">创建model</h3>
<pre><code class="language-java">import lombok.Data;

@Data
public class UserDto {

    private String id;

    private String username;

    private String password;

    private String fullname;

    private String mobile;
}
</code></pre>
<h3 id="创建controller">创建controller</h3>
<pre><code class="language-java">import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class LoginController {

    /**
     *  用户登录成功
    */
    @RequestMapping(value = &quot;/login-success&quot;)
    public String loginSuccess() {
        String username = getUsername();
        return username + &quot; 登录成功&quot;;
    }

    /**
     *  获取当前登录用户名
     */
    private String getUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (!authentication.isAuthenticated()) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        String username = null;
        if (principal instanceof org.springframework.security.core.userdetails.UserDetails) {
            username = ((org.springframework.security.core.userdetails.UserDetails) principal).getUsername();
        } else {
            username = principal.toString();
        }
        return username;
    }

    /**
     * 测试资源1
     */
    @GetMapping(value = &quot;/r/r1&quot;)
    public String r1() {
        String username = getUsername();
        return username + &quot; 访问资源1&quot;;
    }

    /**
     * 测试资源2
     */
    @GetMapping(value = &quot;/r/r2&quot;)
    public String r2() {
        String username = getUsername();
        return username + &quot; 访问资源2&quot;;
    }
}
</code></pre>
<h3 id="创建userdetailsservice">创建userdetailsService</h3>
<pre><code class="language-java">import com.ldx.springboot.dao.UserMapper;
import com.ldx.springboot.model.UserDto;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class SpringDataUserDetailsService implements UserDetailsService {

    @Autowired
    UserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //登录账号
        System.out.println(&quot;username=&quot; + username);
        //根据账号去数据库查询...
        UserDto user = userMapper.getUserByUsername(username);
        if (user == null) {
            return null;
        }
        //这里暂时使用静态数据
        UserDetails userDetails = User.withUsername(user.getFullname()).password(user.getPassword()).authorities(&quot;p1&quot;).build();
        return userDetails;
    }
}
</code></pre>
<h3 id="创建mapper">创建mapper</h3>
<pre><code class="language-java">import com.ldx.springboot.model.UserDto;
import org.apache.ibatis.annotations.Select;

public interface UserMapper {

    @Select(&quot;select id,username,password,fullname from t_user where username = #{username}&quot;)
    UserDto getUserByUsername(String username);
}
</code></pre>
<h3 id="创建bcrypt密码测试类">创建BCrypt密码测试类</h3>
<pre><code class="language-java">import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.security.crypto.bcrypt.BCrypt;
import org.springframework.test.context.junit4.SpringRunner;

@RunWith(SpringRunner.class)
public class TestBCrypt {

    @Test
    public void test1(){ 
        //对原始密码加密 
        String hashpw = BCrypt.hashpw(&quot;123&quot;,BCrypt.gensalt());
        System.out.println(hashpw);
        //校验原始密码和BCrypt密码是否一致 
        boolean checkpw = BCrypt.checkpw(&quot;123&quot;, &quot;$2a$10$NlBC84MVb7F95EXYTXwLneXgCca6/GipyWR5NHm8K0203bSQMLpvm&quot;); 
        System.out.println(checkpw); 
    } 
}
</code></pre>
<h3 id="测试结果">测试结果</h3>
<ol>
<li>使用BCrypt密码测试类生成指定密码且将用户信息写入数据库用户表</li>
<li>启动项目访问<code>localhost:8080</code></li>
<li>输入用户名密码进行测试</li>
<li>暂时使用静态权限数据,测试<code>r/r1</code>: 正常,<code>r/r2</code>:无权限</li>
</ol>
<h2 id="会话">会话</h2>
<p>用户认证通过后，为了避免用户的每次操作都进行认证可将用户的信息保存在会话中。spring security提供会话管理，认证通过后将身份信息放入SecurityContextHolder上下文，SecurityContext与当前线程进行绑定，方便获取用户身份。</p>
<h3 id="获取当前用户名">获取当前用户名</h3>
<pre><code class="language-java">/**
     *  获取当前登录用户名
     */
    private String getUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (!authentication.isAuthenticated()) {
            return null;
        }
        Object principal = authentication.getPrincipal();
        String username = null;
        if (principal instanceof org.springframework.security.core.userdetails.UserDetails) {
            username = ((org.springframework.security.core.userdetails.UserDetails) principal).getUsername();
        } else {
            username = principal.toString();
        }
        return username;
    }
</code></pre>
<h3 id="会话控制">会话控制</h3>
<p>我们可以通过以下选项准确控制会话何时创建以及Spring Security如何与之交互：</p>
<table>
<thead>
<tr>
<th>机制</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>如果没有session存在就创建一个</td>
</tr>
<tr>
<td>ifRequired</td>
<td>如果需要就创建一个Session（默认）登录时</td>
</tr>
<tr>
<td>never</td>
<td>SpringSecurity 将不会创建Session，但是如果应用中其他地方创建了Session，那么SpringSecurity将会使用它。</td>
</tr>
<tr>
<td>stateles</td>
<td>SpringSecurity将绝对不会创建Session，也不使用Session</td>
</tr>
</tbody>
</table>
<p>通过以下配置方式对该选项进行配置：</p>
<pre><code class="language-java">@Override 
protected void configure(HttpSecurity http) throws Exception { 
    http.sessionManagement() .sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED) 
}
</code></pre>
<p>默认情况下，Spring Security会为每个登录成功的用户会新建一个Session，就是<strong>ifRequired</strong> 。<br>
若选用<strong>never</strong>，则指示Spring Security对登录成功的用户不创建Session了，但若你的应用程序在某地方新建了session，那么Spring Security会用它的。<br>
若使用<strong>stateless</strong>，则说明Spring Security对登录成功的用户不会创建Session了，你的应用程序也不会允许新建session。并且它会暗示不使用cookie，所以每个请求都需要重新进行身份验证。这种无状态架构适用于REST API及其无状态认证机制。</p>
<h3 id="会话超时">会话超时</h3>
<p>可以再sevlet容器中设置Session的超时时间，如下设置Session有效期为3600s；<br>
springboot配置:</p>
<pre><code class="language-properties">server.servlet.session.timeout=3600s
</code></pre>
<p>session超时之后，可以通过Spring Security 设置跳转的路径。</p>
<pre><code class="language-java">http.sessionManagement() 
    .expiredUrl(&quot;/login‐view?error=EXPIRED_SESSION&quot;) 
    .invalidSessionUrl(&quot;/login‐view?error=INVALID_SESSION&quot;);
</code></pre>
<p>expired指session过期，invalidSession指传入的sessionid无效。</p>
<h3 id="安全会话cookie">安全会话cookie</h3>
<p>我们可以使用httpOnly和secure标签来保护我们的会话cookie：<br>
<strong>httpOnly</strong>：如果为true，那么浏览器脚本将无法访问cookie<br>
<strong>secure</strong>：如果为true，则cookie将仅通过HTTPS连接发送<br>
spring boot 配置文件：</p>
<pre><code class="language-properties">server.servlet.session.cookie.http‐only=true 
server.servlet.session.cookie.secure=true
</code></pre>
<h2 id="退出">退出</h2>
<p>Spring security默认实现了logout退出，访问<code>/logout</code>实现退出操作。<br>
这里也可以自定义退出成功的页面：<br>
在WebSecurityConfifig的protected void confifigure(HttpSecurity http)中配置：</p>
<pre><code class="language-java">.and() 
    .logout() 
    .logoutUrl(&quot;/logout&quot;) 
    .logoutSuccessUrl(&quot;/login‐view?logout&quot;);
</code></pre>
<p>当退出操作出发时，将发生：</p>
<ul>
<li>使HTTP Session 无效</li>
<li>清除 SecurityContextHolder</li>
<li>跳转到 /login-view?logout<br>
但是，类似于配置登录功能，咱们可以进一步自定义退出功能：</li>
</ul>
<pre><code class="language-java">@Override protected void configure(HttpSecurity http) throws Exception { 
    http 
        .authorizeRequests() //... 
        .and() 
        .logout() (1) 
        .logoutUrl(&quot;/logout&quot;) (2) 
        .logoutSuccessUrl(&quot;/login‐view?logout&quot;) (3) 
        .logoutSuccessHandler(logoutSuccessHandler) (4) 
        .addLogoutHandler(logoutHandler) (5) 
        .invalidateHttpSession(true); (6) }
</code></pre>
<p>（1）提供系统退出支持，使用 WebSecurityConfigurerAdapter 会自动被应用<br>
（2）设置触发退出操作的URL (默认是 /logout ).<br>
（3）退出之后跳转的URL。默认是 /login?logout 。<br>
（4）定制的 LogoutSuccessHandler ，用于实现用户退出成功时的处理。如果指定了这个选项那么logoutSuccessUrl() 的设置会被忽略。<br>
（5）添加一个 LogoutHandler ，用于实现用户退出时的清理工作.默认 SecurityContextLogoutHandler 会被添加为最后一个 LogoutHandler 。<br>
（6）指定是否在退出时让 HttpSession 无效。 默认设置为 <strong>true</strong>。<br>
<strong>注意：如果让logout在GET请求下生效，必须关闭防止CSRF攻击csrf().disable()。如果开启了CSRF，必须使用post方式请求/logout</strong><br>
<strong>logoutHandler：</strong><br>
一般来说， LogoutHandler 的实现类被用来执行必要的清理，因而他们不应该抛出异常。<br>
下面是Spring Security提供的一些实现：</p>
<ol>
<li>PersistentTokenBasedRememberMeServices 基于持久化token的<strong>RememberMe</strong>功能的相关清理</li>
<li>TokenBasedRememberMeService 基于token的<strong>RememberMe</strong>功能的相关清理</li>
<li>CookieClearingLogoutHandler 退出时Cookie的相关清理</li>
<li>CsrfLogoutHandler 负责在退出时移除csrfToken</li>
<li>SecurityContextLogoutHandler 退出时SecurityContext的相关清理<br>
链式API提供了调用相应的 LogoutHandler 实现的快捷方式，比如deleteCookies()。</li>
</ol>
<h2 id="自定义授权">自定义授权</h2>
<p>授权的方式包括 web授权和方法授权，web授权是通过 url拦截进行授权，方法授权是通过 方法拦截进行授权。他们都会调用accessDecisionManager进行授权决策，若为web授权则拦截器为FilterSecurityInterceptor；若为方法授权则拦截器为MethodSecurityInterceptor。如果同时通过web授权和方法授权则先执行web授权，再执行方法授权，最后决策通过，则允许访问资源，否则将禁止访问。</p>
<h3 id="创建数据库表-2">创建数据库表</h3>
<pre><code class="language-sql"># 角色表
CREATE TABLE `t_role` ( 
    `id` varchar(32) NOT NULL, 
    `role_name` varchar(255) DEFAULT NULL,
    `description` varchar(255) DEFAULT NULL, 
    `create_time` datetime DEFAULT NULL,
    `update_time` datetime DEFAULT NULL, 
    `status` char(1) NOT NULL, PRIMARY KEY (`id`), 
    UNIQUE KEY `unique_role_name` (`role_name`) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    insert into 
    `t_role`
    (`id`,`role_name`,`description`,`create_time`,`update_time`,`status`)
    values 
    ('1','管理员',NULL,NULL,NULL,'');
# 用户角色关系表
CREATE TABLE `t_user_role` (
    `user_id` varchar(32) NOT NULL,
    `role_id` varchar(32) NOT NULL, 
    `create_time` datetime DEFAULT NULL,
    `creator` varchar(255) DEFAULT NULL, 
    PRIMARY KEY (`user_id`,`role_id`) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    insert into 
    `t_user_role`
    (`user_id`,`role_id`,`create_time`,`creator`)
    values 
    ('1','1',NULL,NULL);
# 权限表
CREATE TABLE `t_permission`( 
    `id` varchar(32) NOT NULL, 
    `code` varchar(32) NOT NULL COMMENT '权限标识符', 
    `description` varchar(64) DEFAULT NULL COMMENT '描述', 
    `url` varchar(128) DEFAULT NULL COMMENT '请求地址', PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    insert into 
    `t_permission`
    (`id`,`code`,`description`,`url`)
    values 
    ('1','p1','测试资源 1','/r/r1'),('2','p3','测试资源2','/r/r2');
# 角色权限关系表
CREATE TABLE `t_role_permission` ( 
    `role_id` varchar(32) NOT NULL,
    `permission_id` varchar(32) NOT NULL, 
    PRIMARY KEY (`role_id`,`permission_id`) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
    insert into 
    `t_role_permission`
    (`role_id`,`permission_id`)
    values 
    ('1','1'),('1','2');
</code></pre>
<h3 id="创建model-2">创建model</h3>
<pre><code class="language-java">import lombok.Data;

@Data
public class PermissionDto {

    private String id;

    private String code;

    private String description;

    private String url;
}
</code></pre>
<h3 id="修改userdatailsservice">修改userdatailsService</h3>
<pre><code class="language-java">import com.ldx.springboot.dao.PermissionMapper;
import com.ldx.springboot.dao.UserMapper;
import com.ldx.springboot.model.PermissionDto;
import com.ldx.springboot.model.UserDto;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class SpringDataUserDetailsService implements UserDetailsService {

    @Autowired
    UserMapper userMapper;

    @Autowired
    PermissionMapper permissionMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //登录账号
        System.out.println(&quot;username=&quot; + username);
        //根据账号去数据库查询...
        UserDto user = userMapper.getUserByUsername(username);
        if (user == null) {
            return null;
        }
        //查询用户权限
        List&lt;PermissionDto&gt; permissions = permissionMapper.findPermissionsByUserId(user.getId());
        List&lt;String&gt; permissionCodes = permissions.stream().map(PermissionDto::getCode).collect(Collectors.toList());
        String[] permissionCodeArr = permissionCodes.toArray(new String[permissionCodes.size()]);
        //创建userDetails
        UserDetails userDetails = User.withUsername(user.getFullname()).password(user.getPassword()).authorities(permissionCodeArr).build();
        return userDetails;
    }
}
</code></pre>
<h3 id="创建mapper-2">创建mapper</h3>
<pre><code class="language-java">import com.ldx.springboot.model.PermissionDto;
import org.apache.ibatis.annotations.Select;

import java.util.List;

public interface PermissionMapper {

    @Select(&quot;SELECT * FROM t_permission WHERE id &quot; +
            &quot;IN(SELECT permission_id FROM t_role_permission WHERE role_id &quot; +
            &quot;IN(SELECT role_id FROM t_user_role WHERE user_id = #{id}))&quot;)
    List&lt;PermissionDto&gt; findPermissionsByUserId(String id);
}
</code></pre>
<h3 id="测试-2">测试</h3>
<ol>
<li>启动项目访问<code>localhost:8080</code></li>
<li>登陆用户</li>
<li>测试访问<code>r/r1</code>,<code>r/r2</code> 资源</li>
</ol>
<h2 id="web授权">web授权</h2>
<p>在上面例子中我们完成了认证拦截，并对/r/**下的某些资源进行简单的授权保护，但是我们想进行灵活的授权控制该怎么做呢？通过给 http.authorizeRequests() 添加多个子节点来定制需求到我们的URL，如下代码：</p>
<pre><code class="language-java">@Override protected void configure(HttpSecurity http) throws Exception { 
    http 
        .authorizeRequests() (1) 
        .antMatchers(&quot;/r/r1&quot;)
        .hasAuthority(&quot;p1&quot;) (2) 
        .antMatchers(&quot;/r/r2&quot;)
        .hasAuthority(&quot;p2&quot;) (3) 
        .antMatchers(&quot;/r/r3&quot;)
        .access(&quot;hasAuthority('p1') and hasAuthority('p2')&quot;) (4) 
        .antMatchers(&quot;/r/**&quot;)
        .authenticated() (5) 
        .anyRequest().permitAll() (6) 
        .and() .formLogin() 
        // ... 
}
</code></pre>
<p>（1） http.authorizeRequests() 方法有多个子节点，每个macher按照他们的声明顺序执行。</p>
<p>（2）指定&quot;/r/r1&quot;URL，拥有p1权限能够访问</p>
<p>（3）指定&quot;/r/r2&quot;URL，拥有p2权限能够访问</p>
<p>（4）指定了&quot;/r/r3&quot;URL，同时拥有p1和p2权限才能够访问</p>
<p>（5）指定了除了r1、r2、r3之外&quot;/r/**&quot;资源，同时通过身份认证就能够访问，这里使用SpEL（Spring Expression Language）表达式。。</p>
<p>（6）剩余的尚未匹配的资源，不做保护。</p>
<p><strong>注意</strong>：</p>
<p><strong>规则的顺序是重要的,更具体的规则应该先写</strong>.现在以/ admin开始的所有内容都需要具有ADMIN角色的身份验证用</p>
<p>户,即使是/ admin / login路径(因为/ admin / login已经被/ admin / **规则匹配,因此第二个规则被忽略).</p>
<pre><code class="language-java">.antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;) 
.antMatchers(&quot;/admin/login&quot;).permitAll()
</code></pre>
<p>因此,登录页面的规则应该在/ admin / **规则之前.例如.</p>
<pre><code class="language-java">.antMatchers(&quot;/admin/login&quot;).permitAll() 
.antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)
</code></pre>
<p>保护URL常用的方法有：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>authenticated()</strong></td>
<td>保护URL，需要用户登录</td>
</tr>
<tr>
<td><strong>permitAll()</strong></td>
<td>指定URL无需保护，一般应用与静态资源文件</td>
</tr>
<tr>
<td><strong>hasRole(String role)</strong></td>
<td>限制单个角色访问，角色将被增加 “ROLE_” .所以”ADMIN” 将和 “ROLE_ADMIN”进行比较.</td>
</tr>
<tr>
<td><strong>hasAuthority(String authority)</strong></td>
<td>限制单个权限访问</td>
</tr>
<tr>
<td><strong>hasAnyRole(String… roles)</strong></td>
<td>允许多个角色访问.</td>
</tr>
<tr>
<td><strong>hasAnyAuthority(String… authorities)</strong></td>
<td>允许多个权限访问.</td>
</tr>
<tr>
<td><strong>access(String attribute)</strong></td>
<td>该方法使用 SpEL表达式, 所以可以创建复杂的限制.</td>
</tr>
<tr>
<td><strong>hasIpAddress(String ipaddressExpression)</strong></td>
<td>限制IP地址或子网</td>
</tr>
</tbody>
</table>
<h2 id="方法授权">方法授权</h2>
<p>现在我们已经掌握了使用如何使用 http.authorizeRequests() 对web资源进行授权保护，从Spring Security2.0版 本开始，它支持服务层方法的安全性的支持。本节学习@PreAuthorize,@PostAuthorize, @Secured三类注解。我们可以在任何 @Configuration 实例上使用 @EnableGlobalMethodSecurity 注释来启用基于注解的安全性。以下内容将启用Spring Security的 @Secured 注释。</p>
<pre><code class="language-java">@EnableGlobalMethodSecurity(securedEnabled = true) 
public class MethodSecurityConfig {
    // ...
}
</code></pre>
<p>然后向方法（在类或接口上）添加注解就会限制对该方法的访问。 Spring Security的原生注释支持为该方法定义了一组属性。 这些将被传递给AccessDecisionManager以供它作出实际的决定：</p>
<pre><code class="language-java">public interface BankService { 
    @Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;) 
    public Account readAccount(Long id); 
    @Secured(&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;) 
    public Account[] findAccounts();
    @Secured(&quot;ROLE_TELLER&quot;) 
    public Account post(Account account, double amount); 
}
</code></pre>
<p>以上配置标明readAccount、findAccounts方法可匿名访问，底层使用WebExpressionVoter投票器，可从 AffirmativeBased第23行代码跟踪。。</p>
<p>post方法需要有TELLER角色才能访问，底层使用RoleVoter投票器。</p>
<p>使用如下代码可启用prePost注解的支持</p>
<pre><code class="language-java">@EnableGlobalMethodSecurity(prePostEnabled = true)
public class MethodSecurityConfig { 
    // ... 
}
</code></pre>
<p>相应Java代码如下：</p>
<pre><code class="language-java">public interface BankService { 
    @PreAuthorize(&quot;isAnonymous()&quot;) 
    public Account readAccount(Long id);
    @PreAuthorize(&quot;isAnonymous()&quot;)
    public Account[] findAccounts(); 
    @PreAuthorize(&quot;hasAuthority('p_transfer') and hasAuthority('p_read_account')&quot;) 
    public Account post(Account account, double amount); 
}
</code></pre>
<p>以上配置标明readAccount、findAccounts方法可匿名访问，post方法需要同时拥有p_transfer和p_read_account 权限才能访问，底层使用WebExpressionVoter投票器，可从AffirmativeBased第23行代码跟踪。</p>

                        </div>
                        
                            <div class="post-toc">
                                <ul class="markdownIt-TOC">
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%A4%E8%AF%81">什么是认证</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%9A%E8%AF%9D">什么是会话</a>
<ul>
<li><a href="#session-%E4%BC%9A%E8%AF%9D">session 会话</a></li>
<li><a href="#token-%E4%BC%9A%E8%AF%9D">token 会话</a></li>
</ul>
</li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%88%E6%9D%83">什么是授权</a></li>
<li><a href="#springsecurity">SpringSecurity</a>
<ul>
<li><a href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B">快速上手</a>
<ul>
<li><a href="#%E5%BC%95%E5%85%A5%E6%89%80%E9%9C%80%E4%BE%9D%E8%B5%96">引入所需依赖</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0spring-security-%E9%85%8D%E7%BD%AE%E7%B1%BB">添加spring security 配置类</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E6%8E%A5%E5%8F%A3">编写测试接口</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95">测试</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
</li>
<li><a href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">工作原理</a>
<ul>
<li><a href="#%E7%BB%93%E6%9E%84%E6%80%BB%E8%A7%88">结构总览</a></li>
<li><a href="#%E8%AE%A4%E8%AF%81">认证</a>
<ul>
<li><a href="#%E6%B5%81%E7%A8%8B">流程</a></li>
<li><a href="#authenticationprovider">AuthenticationProvider</a></li>
<li><a href="#userdetailsservice">UserDetailsService</a></li>
<li><a href="#passwordencoder">PasswordEncoder</a></li>
</ul>
</li>
<li><a href="#%E6%8E%88%E6%9D%83">授权</a>
<ul>
<li><a href="#%E6%B5%81%E7%A8%8B-2">流程</a></li>
<li><a href="#%E6%8E%88%E6%9D%83%E5%86%B3%E7%AD%96">授权决策</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%A4%E8%AF%81">自定义认证</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8">创建数据库表</a></li>
<li><a href="#%E6%B7%BB%E5%8A%A0%E6%89%80%E9%9C%80%E4%BE%9D%E8%B5%96">添加所需依赖</a></li>
<li><a href="#%E9%85%8D%E7%BD%AEapplicationyml">配置application.yml</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9springboot-%E5%90%AF%E5%8A%A8%E7%B1%BB">修改springboot 启动类</a></li>
<li><a href="#%E5%88%9B%E5%BB%BAsecurityconfig">创建securityConfig</a></li>
<li><a href="#%E5%88%9B%E5%BB%BAmodel">创建model</a></li>
<li><a href="#%E5%88%9B%E5%BB%BAcontroller">创建controller</a></li>
<li><a href="#%E5%88%9B%E5%BB%BAuserdetailsservice">创建userdetailsService</a></li>
<li><a href="#%E5%88%9B%E5%BB%BAmapper">创建mapper</a></li>
<li><a href="#%E5%88%9B%E5%BB%BAbcrypt%E5%AF%86%E7%A0%81%E6%B5%8B%E8%AF%95%E7%B1%BB">创建BCrypt密码测试类</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C">测试结果</a></li>
</ul>
</li>
<li><a href="#%E4%BC%9A%E8%AF%9D">会话</a>
<ul>
<li><a href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E5%90%8D">获取当前用户名</a></li>
<li><a href="#%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6">会话控制</a></li>
<li><a href="#%E4%BC%9A%E8%AF%9D%E8%B6%85%E6%97%B6">会话超时</a></li>
<li><a href="#%E5%AE%89%E5%85%A8%E4%BC%9A%E8%AF%9Dcookie">安全会话cookie</a></li>
</ul>
</li>
<li><a href="#%E9%80%80%E5%87%BA">退出</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%88%E6%9D%83">自定义授权</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8-2">创建数据库表</a></li>
<li><a href="#%E5%88%9B%E5%BB%BAmodel-2">创建model</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9userdatailsservice">修改userdatailsService</a></li>
<li><a href="#%E5%88%9B%E5%BB%BAmapper-2">创建mapper</a></li>
<li><a href="#%E6%B5%8B%E8%AF%95-2">测试</a></li>
</ul>
</li>
<li><a href="#web%E6%8E%88%E6%9D%83">web授权</a></li>
<li><a href="#%E6%96%B9%E6%B3%95%E6%8E%88%E6%9D%83">方法授权</a></li>
</ul>
</li>
</ul>

                            </div>
                            
                                
                                    
                                        <!--en-->
                                        <section class="post-copyright en">
                                            <p class="copyright-item">
                                                <span>Author:</span>
                                                <span>断剑重铸之日，骑士归来之时。</span>
                                            </p>

                                            <p class="copyright-item">
                                                <span>Permalink:</span>
                                                <span><a href="http://blog.ludangxin.club/post/spring-security-xiang-jie-ji-kuai-su-shang-shou/">http://blog.ludangxin.club/post/spring-security-xiang-jie-ji-kuai-su-shang-shou/</a></span>
                                            </p>

                                            <p class="copyright-item">
                                                <span>License:</span>
                                                <span>MIT License</span>
                                            </p>
                                        </section>
                                        
                                                
                                                    
                                                        <!-- Share-->
                                                        <span style="margin-right:15px">
                                                    <i class="post-share"></i>
                                                    <span>Share:</span>
                                                        <a title="QR Code" target="_blank" href="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://blog.ludangxin.club/post/spring-security-xiang-jie-ji-kuai-su-shang-shou/"><i class="fa fa-qrcode"></i></a>
                                                        <a title="QQ" target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://blog.ludangxin.club/post/spring-security-xiang-jie-ji-kuai-su-shang-shou/&sharesource=qzone&title=Spring Security 详解 及 快速上手&pics=http://blog.ludangxin.club/images/avatar.png?v=1597935637693&summary="><i class="fa fa-qq"></i></a>
                                                        <a title="Weibo" target="_blank" href="https://service.weibo.com/share/share.php?url=http://blog.ludangxin.club/post/spring-security-xiang-jie-ji-kuai-su-shang-shou/&sharesource=weibo&title=Spring Security 详解 及 快速上手 + " - " + &pic="http://blog.ludangxin.club/images/avatar.png?v=1597935637693 "><i class="fa fa-weibo "></i></a>
                                                        
                                                                </span>
                                                                <!--en-->
                                                                <section class="post-tags en ">
                                                                    <div>
                                                                        <span>Tag(s):</span>
                                                                        <span class="tag ">
                        
                        
                        <a href="http://blog.ludangxin.club/tag/LSBz4Ej4I/">#
                                                springboot
                                                    </a>
                                                    
                                                        
                                                            </span>
                                                                    </div>
                                                                    <div>
                                                                        <a href="javascript:window.history.back();">back</a>
                                                                        <span>&dot;</span>
                                                                        <a href="#">home</a>
                                                                    </div>
                                                                </section>
                                                                
                                                                                <!---->
                                                                                <section class="post-nav">
                                                                                    
                                                                                        <a class="prev" rel="prev" href="http://blog.ludangxin.club/post/oauth20/">
                                                                                            OAuth2.0
                                                                                        </a>
                                                                                        
                                                                                            
                                                                                                <a class="next" rel="next" href="http://blog.ludangxin.club/post/chu-shi-dubbo/">
                                                                                                    初识 Dubbo
                                                                                                </a>
                                                                                                
                                                                                </section>
                    </article>
                </div>
                
                                            
                                                <script type="application/javascript" src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
<div id="vlaine-comment"></div>
<script type="application/javascript">
    new Valine({
        el: '#vlaine-comment',
        appId: '6v8KE1xPEnnI3VycbaTHPQvD-gzGzoHsz',
        appKey: 'tCAPkuAx3JWn7YrPKlEpyaMH',
        pageSize: 10,
        avatar: 'mp',
        placeholder: '来都来了，不妨评论一下',
        visitor: true,
        highlight: false,
        recordIP: true,
    })
</script>
                                                    
            </div>
    </div>
    </div>
    </div>
    
        <footer id="footer" class="footer">
            <div class="copyright">
                
                    <div class="Like">
                        <div class="tip" data-tooltip="Do you like it?">
                            <a href="https://github.com/ITJoker233/Gridea-theme-Chic" target="_blank" title=""><svg class="icon"
                        aria-hidden="true">
                        <use xlink:href="#like"></use>
                    </svg><b class="like_text" id="star"></b></a>
                        </div>
                    </div>
                    
                        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
                            
                                <b id="hitokoto"></b><br>
                                
                                        <svg viewBox="0 0 1024 1024" style="margin-left: 5px;margin-right: 5px;" version="1.0" width="8" height="8" class="my-face">
            <path
                d="M863.597631 513.574282l-271.33965-140.213484L729.783667 81.926656c3.583731-7.87141 7.167462-15.742819 7.167462-25.214109C736.887134 25.226908 708.345275 0.012799 672.635953 0.012799a63.611229 63.611229 0 0 0-39.293053 12.607055c-1.791866 1.59988-3.519736 3.19976-5.311602 3.19976L147.87531 418.925381a55.547834 55.547834 0 0 0-19.646527 47.356448c1.791866 17.278704 14.27093 33.021523 32.125591 42.492813l271.33965 141.749369L292.504463 945.221908c-12.479064 25.214109-1.791866 53.563983 23.166262 69.306802 10.751194 6.335525 23.230258 9.47129 35.709322 9.47129 16.062795 0 32.125591-4.735645 44.604655-15.742819l480.091993-403.297753a55.547834 55.547834 0 0 0 19.646526-47.228458 61.243407 61.243407 0 0 0-32.12559-44.156688z"
                fill="#93b5cf"></path>
        </svg>
                                        断剑重铸之日，骑士归来之时。 &copy;Copyright
                                            <script>
                                                var date = new Date();
                                                document.write("" + date.getFullYear());
                                            </script>
                                            | Powered by
                                            <a href="https://coding.net" target="_blank">
                                                Coding.net
                                            </a>
            </div>
            <div id="update" style="display:none;">
                on
            </div>
            
                <div id="version" style="display:none;">
                    1.7.4
                </div>
                
                    <script>
                        var port = '';
                        
                        document.write('<div id="home_path" style="display:none;">' + document.location.protocol + '//' + window.document.location.hostname + port + '</div>')
                    </script>
        </footer>
        
            <script src='https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js'></script>
            
                <script>
                    
                    
                    loadlive2d();
                    
                    
                    hitokoto();
                    
                    getStar();
                    hljs.initHighlighting();
                    console.clear();
                    
                    CheckVersion();
                    
                    var newDate = new Date();
                    newDate.setTime(1597935637693);
                    console.log(" Blog Update Time: " + newDate.toLocaleDateString());
                    console.log("\n %c \u26a1Theme:Chic Author's Blog:https://blog.itjoker.cn  Write By ITJoker  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;");
                </script>
        </div>
</body>
<script>
    scroll();
</script>

</html>